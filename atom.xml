<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[liuxing's blog]]></title>
  <subtitle><![CDATA[青春须早为,岂能长少年！]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://liuxing.info//"/>
  <updated>2016-01-05T03:50:48.000Z</updated>
  <id>http://liuxing.info//</id>
  
  <author>
    <name><![CDATA[liuxing]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Tomcat-Jdbc-Pool参数说明]]></title>
    <link href="http://liuxing.info/2016/01/05/Tomcat-Jdbc-Pool%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/"/>
    <id>http://liuxing.info/2016/01/05/Tomcat-Jdbc-Pool参数说明/</id>
    <published>2016-01-05T03:36:00.000Z</published>
    <updated>2016-01-05T03:50:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>Tomcat 在 7.0 以前的版本都是使用commons-dbcp做为连接池的实现，但是DBCP存在一些问题： </p>
<ul>
<li>DBCP 是单线程的，为了保证线程安全会锁整个连接池 </li>
<li>DBCP 性能不佳</li>
<li>DBCP 太复杂，超过60个类，发展滞后。 </li>
</ul>
<p>因此，通常J2EE中还会使用其它的高性能连接池，如C3P0，还有阿里系的druid等。<br>为此，Tomcat 从 7.0 开始引入一个新的模块： Tomcat Jdbc Pool<br>Tomcat Jdbc Pool 近乎兼容 DBCP，性能更高 </p>
<ul>
<li>异步方式获取连接 </li>
<li>Tomcat Jdbc Pool是Tomcat的一个模块，基于Tomcat-Juli，使用Tomcat的日志框架 </li>
<li>使用 javax.sql.PooledConnection 接口获取连接 </li>
<li>支持高并发应用环境 </li>
<li>超简单，核心文件只有8个，比 c3p0 还少 </li>
<li>更好的空闲连接处理机制 </li>
<li>支持 JMX </li>
<li>支持 XA Connection。 </li>
<li>Tomcat Jdbc Pool 可在 Tomcat 中直接使用，也可以在独立的应用中使用。 </li>
</ul>
<h2 id="属性">属性</h2><p>通用属性</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名</th>
<th style="text-align:left">描述(DBCP/Tomcat jdbc-pool 差别 )</th>
<th style="text-align:left">DBCP默认值</th>
<th style="text-align:left">jdbc-pool默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">username</td>
<td style="text-align:left">用户名</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">password</td>
<td style="text-align:left">密码</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">url</td>
<td style="text-align:left">建立连接的URL</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">driverClassName</td>
<td style="text-align:left">驱动的完整有效的java类名</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">connectionProperties</td>
<td style="text-align:left">(String) 当建立新连接时被发送给JDBC 驱动的连接参数，格式必须是 [propertyName=property;]<br>*注意 ：参数user/password 将被明确传递，所以不需要包括在这里。</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">defaultAutoCommit</td>
<td style="text-align:left">(boolean) 连接池创建的连接的默认的auto-commit 状态</td>
<td style="text-align:left">true</td>
<td style="text-align:left">driver default</td>
</tr>
<tr>
<td style="text-align:left">defaultReadOnly</td>
<td style="text-align:left">(boolean) 连接池创建的连接的默认的read-only 状态。 如果没有设置则setReadOnly 方法将不会被调用。 ( 某些驱动不支持只读模式， 比如：Informix)</td>
<td style="text-align:left">driver default</td>
<td style="text-align:left">driver default</td>
</tr>
<tr>
<td style="text-align:left">defaultTransactionIsolation</td>
<td style="text-align:left">(String) 连接池创建的连接的默认的TransactionIsolation 状态。 下面列表当中的某一个： ( 参考javadoc) <br>NONE <br>READ_COMMITTED <br>READ_UNCOMMITTED <br>REPEATABLE_READ <br>SERIALIZABLE</td>
<td style="text-align:left">driver default</td>
<td style="text-align:left">driver default</td>
</tr>
<tr>
<td style="text-align:left">defaultCatalog</td>
<td style="text-align:left">(String) 连接池创建的连接的默认的catalog</td>
<td style="text-align:left">-</td>
<td style="text-align:left">driver default</td>
</tr>
<tr>
<td style="text-align:left">initialSize</td>
<td style="text-align:left">(int) 初始化连接： 连接池启动时创建的初始化连接数量，1。2 版本后支持</td>
<td style="text-align:left">0</td>
<td style="text-align:left">10</td>
</tr>
<tr>
<td style="text-align:left">maxActive</td>
<td style="text-align:left">(int) 最大活动连接： 连接池在同一时间能够分配的最大活动连接的数量， 如果设置为非正数则表示不限制</td>
<td style="text-align:left">8</td>
<td style="text-align:left">100</td>
</tr>
<tr>
<td style="text-align:left">maxIdle</td>
<td style="text-align:left">(int) 最大空闲连接： 连接池中容许保持空闲状态的最大连接数量， 超过的空闲连接将被释放， 如果设置为负数表示不限制 <br><code>如果启用，将定期检查限制连接，如果空闲时间超过minEvictableIdleTimeMillis 则释放连接 （ 参考testWhileIdle ）</code></td>
<td style="text-align:left">8</td>
<td style="text-align:left">与maxActive相同</td>
</tr>
<tr>
<td style="text-align:left">minIdle</td>
<td style="text-align:left">(int) 最小空闲连接： 连接池中容许保持空闲状态的最小连接数量， 低于这个数量将创建新的连接， 如果设置为0 则不创建 <br><code>如果连接验证失败将缩小这个值（ 参考testWhileIdle ）</code></td>
<td style="text-align:left">0</td>
<td style="text-align:left">与initialSize 相同</td>
</tr>
<tr>
<td style="text-align:left">maxWait</td>
<td style="text-align:left">(int) 最大等待时间： 当没有可用连接时， 连接池等待连接被归还的最大时间( 以毫秒计数)， 超过时间则抛出异常， 如果设置为-1 表示无限等待</td>
<td style="text-align:left">无限</td>
<td style="text-align:left">30000（30秒）</td>
</tr>
<tr>
<td style="text-align:left">validationQuery</td>
<td style="text-align:left">(String) SQL 查询， 用来验证从连接池取出的连接， 在将连接返回给调用者之前。 如果指定， 则查询必须是一个SQL SELECT 并且必须返回至少一行记录 <br> <code>查询不必返回记录，但这样将不能抛出SQL异常</code></td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">testOnBorrow</td>
<td style="text-align:left">(boolean) 指明是否在从池中取出连接前进行检验， 如果检验失败， 则从池中去除连接并尝试取出另一个。注意： 设置为true 后如果要生效，validationQuery 参数必须设置为非空字符串 <br> <code>参考validationInterval以获得更有效的验证</code></td>
<td style="text-align:left">true</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">testOnReturn</td>
<td style="text-align:left">(boolean) 指明是否在归还到池中前进行检验 注意： 设置为true 后如果要生效，validationQuery 参数必须设置为非空字符串</td>
<td style="text-align:left">false</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">testWhileIdle</td>
<td style="text-align:left">(boolean) 指明连接是否被空闲连接回收器( 如果有) 进行检验。 如果检测失败， 则连接将被从池中去除。注意： 设置为true 后如果要生效，validationQuery 参数必须设置为非空字符串</td>
<td style="text-align:left">false</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">timeBetweenEvictionRunsMillis</td>
<td style="text-align:left">(int) 在空闲连接回收器线程运行期间休眠的时间值， 以毫秒为单位。 如果设置为非正数， 则不运行空闲连接回收器线程 <br> <code>这个值不应该小于1秒，它决定线程多久验证连接或丢弃连接</code></td>
<td style="text-align:left">-1</td>
<td style="text-align:left">5000（5秒）</td>
</tr>
<tr>
<td style="text-align:left">numTestsPerEvictionRun</td>
<td style="text-align:left">(int) 在每次空闲连接回收器线程( 如果有) 运行时检查的连接数量</td>
<td style="text-align:left">false</td>
<td style="text-align:left">未使用</td>
</tr>
<tr>
<td style="text-align:left">minEvictableIdleTimeMillis</td>
<td style="text-align:left">连接在池中保持空闲而不被空闲连接回收器线程( 如果有) 回收的最小时间值，单位毫秒</td>
<td style="text-align:left">1000 <em> 60 </em> 30（30分钟）</td>
<td style="text-align:left">60000（60秒）</td>
</tr>
<tr>
<td style="text-align:left">poolPreparedStatements</td>
<td style="text-align:left">(boolean) 开启池的prepared statement 池功能</td>
<td style="text-align:left">false</td>
<td style="text-align:left">未使用</td>
</tr>
<tr>
<td style="text-align:left">maxOpenPreparedStatements</td>
<td style="text-align:left">(int)statement 池能够同时分配的打开的statements 的最大数量， 如果设置为0 表示不限制</td>
<td style="text-align:left">不限制</td>
<td style="text-align:left">未使用</td>
</tr>
<tr>
<td style="text-align:left">accessToUnderlyingConnectionAllowed</td>
<td style="text-align:left">(boolean) 控制PoolGuard 是否容许获取底层连接 <br> <code>jdbc-pool中未使用此属性；可以通过调用连接的unwrap方法取得控制权。参考javax。sql。DataSource接口，通过反射调用getConnection方法，或强制转换为javax。sql。PooledConnection对象。</code></td>
<td style="text-align:left">false</td>
<td style="text-align:left">未使用</td>
</tr>
<tr>
<td style="text-align:left">removeAbandoned</td>
<td style="text-align:left">(boolean) 标记是否删除泄露的连接， 如果他们超过了removeAbandonedTimout 的限制。 如果设置为true， 连接被认为是被泄露并且可以被删除， 如果空闲时间超过removeAbandonedTimeout。 设置为true 可以为写法糟糕的没有关闭连接的程序修复数据库连接。<br> <code>参考logAbandoned</code></td>
<td style="text-align:left">false</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">removeAbandonedTimeout</td>
<td style="text-align:left">(int) 泄露的连接可以被删除的超时值， 单位秒 <br> 应设置为应用中查询执行最长的时间</td>
<td style="text-align:left">300</td>
<td style="text-align:left">60</td>
</tr>
<tr>
<td style="text-align:left">logAbandoned</td>
<td style="text-align:left">(boolean) 标记当Statement 或连接被泄露时是否打印程序的stack traces 日志。被泄露的Statements 和连接的日志添加在每个连接打开或者生成新的Statement， 因为需要生成stack trace 。</td>
<td style="text-align:left">false</td>
<td style="text-align:left">false</td>
</tr>
</tbody>
</table>
<hr>
<p>Tomcat jdbc-pool 新增属性</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">validatorClassName</td>
<td style="text-align:left">(String)实现org.apache.tomcat.jdbc.pool.Validator接口的类名，必须存在默认或明确的无参构造方 法。将建立一个指定类的实例作为验证器，用来代替执行查询的连接验证。例如：com.mycompany.project.SimpleValidator。</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">initSQL</td>
<td style="text-align:left">(String) 当连接第一次建立时执行的SQL</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">jdbcInterceptors</td>
<td style="text-align:left">(String)（jdbc拦截器——jdbc-pool的高级扩展属 性）用分号分隔的、继承org.apache.tomcat.jdbc.pool.JdbcInterceptor的类名列表。这些拦截器将被插入到对 java.sql.Connection操作之前的拦截器链上。<br>预制的拦截器有：<br>org.apache.tomcat.jdbc.pool.interceptor.ConnectionState - 追踪自动提交、只读状态、catalog和事务隔离等级等状态。（keeps track of auto commit， read only， catalog and transaction isolation level.）org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer - 追踪打开的statement，当连接被归还时关闭它们。（keeps track of opened statements， and closes them when the connection is returned to the pool.）<br>更多预制拦截器详细描述请参见JDBC拦截器部分</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">validationInterval</td>
<td style="text-align:left">(long) 避免过度验证，保证验证不超过这个频率——以毫秒为单位。如果一个连接应该被验证，但上次验证未达到指定间隔，将不再次验证。</td>
<td style="text-align:left">30000（30秒）</td>
</tr>
<tr>
<td style="text-align:left">jmxEnabled</td>
<td style="text-align:left">(boolean) 是否将连接注册到JMX</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">fairQueue</td>
<td style="text-align:left">(boolean) 如果被设为true ，getConnection 方法将被以先进先出的方式对待。此属性使用 org.apache.tomcat.jdbc.pool.FairBlockingQueue 实现闲置连接列表。<br>如果需要使用异步连接回收，这个标记是必须的。<br>这个标记确保线程取得连接的顺序和他们调用getConnection 方法的顺序是相同的。<br>在性能测试中，这个标记对锁和锁等待有非常大的影响。当fairQueue=true ，将有一个依赖于操作系统的线程作为决定线程。如果是Linux 系统（ 系统属性os.name=Linux ）可以在线程池的类加载之前设置系统属性 org.apache.tomcat.jdbc.pool.FairBlockingQueue.ignoreOS=true 关闭Linux 特定行为但仍然使用公平队列</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">abandonWhenPercentageFull</td>
<td style="text-align:left">(int)正在被使用的连接超过这个百分比以前被丢弃的连接不会被断开或报告。这个值应被设为0-100之间。默认值为0，意味着达到 removeAbandonedTimeout 时将被尽快关闭。</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">maxAge</td>
<td style="text-align:left">(long)保持连接的最大毫秒数。当一个连接被归还时，连接池将检查是否满足：现在时间-连接时长&gt;maxAge，如果条件满足，连接将被关闭而不是回到池中。默认值为0，标识禁用该功能。</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">useEquals</td>
<td style="text-align:left">(boolean)如果希望ProxyConnection类使用String.equals方法对比方法名，设为true；否则将使用==判断。这个属性不会影响单独配置的拦截器。</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">suspectTimeout</td>
<td style="text-align:left">(int)以秒为单位的超时时间（怀疑超时）。类似 removeAbandonedTimeout，但不会将连接丢弃甚至关闭，如果logAbandoned为true，则 只是记录一个警告。如果这个值小于等于0，不会有怀疑超时检测被执行。怀疑检测只有当超时时间大于0并且连接未丢弃，或者丢弃检测被禁用的情况下才占用空间。如果一个连接被怀疑，将记录一条警告消息，并发送一个JMX通知。</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">rollbackOnReturn</td>
<td style="text-align:left">(boolean)如果autoCommit==false，当连接被归还时，通过调用连接的rollback方法中断事务。</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">commitOnReturn</td>
<td style="text-align:left">(boolean)如果autoCommit==false，当连接被归还时，通过调用连接的commit方法完成事务。如果rollbackOnReturn==ture，这个属性将被忽略。</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">alternateUsernameAllowed</td>
<td style="text-align:left">(boolean)为了提高性能，默认情况下，jdbc-pool将忽略 DataSource.getConnection(username,password)调用，直接返回一个以已有的全局配置的用户名和密码创建的连 接。连接池仍然可以用不同的用户名和密码，但已经通过旧的用户名和密码创建的连接将被关闭，然后重新以新的用户名和密码连接。这样连接池将以全局级别管理 连接数，而不是schema级别。设置这个属性为true来启用 DataSource.getConnection(username,password)方法描述的行为。<br> 这个属性为bug 50025 增加。</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">dataSource</td>
<td style="text-align:left">(javax.sql.DataSource)向连接池注入一个数据源，连接池将使用这个数据源索取连接，而不是通过java.sql.Driver接口建立。当您希望池化XA连接或者使用数据源而不是url时，这个属性非常有用。</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">dataSourceJNDI</td>
<td style="text-align:left">(String)用来建立数据连接的JNDI名称。参考dataSource属性。</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">useDisposableConnectionFacade</td>
<td style="text-align:left">(boolean)如果您希望在连接上建立一道屏障防止连接关闭之后被重新使用，设置这个属性为true。这个属性用来预防线程保持已关闭连接的引用，并在上面执行查询动作。</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">logValidationErrors</td>
<td style="text-align:left">(boolean)如果设置为true，将在验证相位时向日志文件写入错误。如果值为true，错误将被记录为SEVER。默认值是false以向后兼容。</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">propagateInterruptState</td>
<td style="text-align:left">(boolean)设置这个属性为true，可以传播一个被中断的线程（还没有清除中断状态）的中断状态。默认值为false以向后兼容。</td>
<td style="text-align:left">false</td>
</tr>
</tbody>
</table>
<h2 id="样例">样例</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"parentDataSource"</span> <span class="attribute">abstract</span>=<span class="value">"true"</span> <span class="attribute">class</span>=<span class="value">"org.apache.tomcat.jdbc.pool.DataSource"</span> <span class="attribute">destroy-method</span>=<span class="value">"close"</span></span><br><span class="line">          <span class="attribute">p:maxWait</span>=<span class="value">"5000"</span></span><br><span class="line">          <span class="attribute">p:removeAbandoned</span>=<span class="value">"true"</span></span><br><span class="line">          <span class="attribute">p:removeAbandonedTimeout</span>=<span class="value">"180"</span></span><br><span class="line">          <span class="attribute">p:connectionProperties</span>=<span class="value">"clientEncoding=UTF-8"</span></span><br><span class="line">          <span class="attribute">p:validationQuery</span>=<span class="value">"SELECT 1"</span></span><br><span class="line">          <span class="attribute">p:validationQueryTimeout</span>=<span class="value">"1"</span></span><br><span class="line">          <span class="attribute">p:validationInterval</span>=<span class="value">"30000"</span></span><br><span class="line">          <span class="attribute">p:testOnBorrow</span>=<span class="value">"false"</span></span><br><span class="line">          <span class="attribute">p:testOnReturn</span>=<span class="value">"false"</span></span><br><span class="line">          <span class="attribute">p:testWhileIdle</span>=<span class="value">"true"</span></span><br><span class="line">          <span class="attribute">p:timeBetweenEvictionRunsMillis</span>=<span class="value">"10000"</span></span><br><span class="line">          <span class="attribute">p:minEvictableIdleTimeMillis</span>=<span class="value">"60000"</span></span><br><span class="line">          <span class="attribute">p:numTestsPerEvictionRun</span>=<span class="value">"20"</span></span><br><span class="line">          <span class="attribute">p:logAbandoned</span>=<span class="value">"false"</span></span><br><span class="line">          <span class="attribute">p:jmxEnabled</span>=<span class="value">"true"</span></span><br><span class="line">          <span class="attribute">p:defaultAutoCommit</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">          </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">parent</span>=<span class="value">"parentDataSource"</span></span><br><span class="line">          <span class="attribute">p:driverClassName</span>=<span class="value">"com.microsoft.sqlserver.jdbc.SQLServerDriver"</span></span><br><span class="line">          <span class="attribute">p:url</span>=<span class="value">"jdbc:sqlserver://127.0.0.1:1433;DatabaseName=test;sendStringParametersAsUnicode=false"</span></span><br><span class="line">          <span class="attribute">p:username</span>=<span class="value">"test"</span></span><br><span class="line">          <span class="attribute">p:password</span>=<span class="value">"test"</span></span><br><span class="line">          <span class="attribute">p:initialSize</span>=<span class="value">"100"</span></span><br><span class="line">          <span class="attribute">p:maxActive</span>=<span class="value">"500"</span></span><br><span class="line">          <span class="attribute">p:maxIdle</span>=<span class="value">"100"</span></span><br><span class="line">          <span class="attribute">p:minIdle</span>=<span class="value">"50"</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="介绍">介绍</h2><p>Tomcat 在 7.0 以前的版本都是使用commons-dbcp做为连接池的实现，但是DBCP存在一些问题： </p>
<ul>
<li>DBCP 是单线程的，为了保证线程安全会锁整个连接池 </li>
<li>DBCP 性能不佳<]]>
    </summary>
    
      <category term="Jdbc" scheme="http://liuxing.info/tags/Jdbc/"/>
    
      <category term="数据源" scheme="http://liuxing.info/tags/%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    
      <category term="连接池" scheme="http://liuxing.info/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[shadowsocks科学上网]]></title>
    <link href="http://liuxing.info/2015/09/09/shadowsocks%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://liuxing.info/2015/09/09/shadowsocks科学上网/</id>
    <published>2015-09-09T02:09:00.000Z</published>
    <updated>2015-10-12T06:53:48.000Z</updated>
    <content type="html"><![CDATA[<p>由于一些大家都懂的原因，访问GitHub或者Google需要进行特殊的”配置”。<br>之前一直用红杏的方式，后来红杏不行了，最近发现了ShadowSocks，折腾一下发现稳定性、速度都比红杏要好很多，推荐给大家使用。</p>
<hr>
<p><code>有内网代理的可以直接跳到</code><a href="#配置浏览器插件">配置浏览器插件</a><br><code>有内网代理的可以直接跳到</code><a href="#配置浏览器插件">配置浏览器插件</a><br><code>有内网代理的可以直接跳到</code><a href="#配置浏览器插件">配置浏览器插件</a><br>重要的事情说三遍!</p>
<hr>
<p>先购买ss套餐，推荐下面两个</p>
<p>只是看看网页,推荐<strong>按需订购套餐</strong>,支持 电脑/手机/平板 等多客户端同时在线<br><a href="http://ss.fanque.wang/aff.php?aff=102" target="_blank" rel="external">http://ss.fanque.wang/aff.php?aff=102</a></p>
<p>这个是按年付费,只能单平台同时在线,限制比较多,但是不限流量<br><a href="https://portal.shadowsocks.com/aff.php?aff=2773" target="_blank" rel="external">https://portal.shadowsocks.com/aff.php?aff=2773</a></p>
<h2 id="安装shadowsocks">安装shadowsocks</h2><ul>
<li>下载各平台的软件<br>  Windows 链接: <a href="http://pan.baidu.com/s/1mggYFNy" target="_blank" rel="external">http://pan.baidu.com/s/1mggYFNy</a> 密码: w9qw<br>  MAC 链接: <a href="http://pan.baidu.com/s/1o6EK2Oq" target="_blank" rel="external">http://pan.baidu.com/s/1o6EK2Oq</a> 密码: 4erq<br>  Android 链接: <a href="http://pan.baidu.com/s/1dDflgBZ" target="_blank" rel="external">http://pan.baidu.com/s/1dDflgBZ</a> 密码: 75wt</li>
<li>运行软件,设置账号信息(以<code>MAC</code>平台为例)<br>  <img src="/images/ss/01.png" alt="打开设置"><br>  <img src="/images/ss/03.png" alt="设置服务器信息"><br>  <img src="/images/ss/02.png" alt="使用自动代理模式"></li>
</ul>
<h2 id="配置浏览器插件">配置浏览器插件</h2><p><code>以下教程的使用场景是chrome</code></p>
<p><strong>离线插件地址</strong><br>链接: <a href="http://pan.baidu.com/s/1o607yjg" target="_blank" rel="external">http://pan.baidu.com/s/1o607yjg</a> 密码: wxrt</p>
<p><strong>安装到chrome</strong></p>
<p><img src="/images/ss/04.png" alt="chrome安装插件"></p>
<p><strong>配置插件</strong></p>
<p>1.使用自己购买的服务,启动shadowsocks后,本机启动一个socks5的代理<br>代理协议选择<code>socks5</code>,地址是<code>127.0.0.1</code>,端口是<code>1080</code><br>配置完成后,点应用选项保存</p>
<p>2.使用内网代理地址的设置对应的 协议 IP 端口<br>socks5 192.168.3.51 1080<br>http 192.168.3.51 8123<br>配置完成后,点应用选项保存</p>
<p><img src="/images/ss/05.png" alt="配置代理信息"></p>
<p>3.设置自动切换<br><img src="/images/ss/06.png" alt="添加规则列表"></p>
<p>规则列表地址:<code>http://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt</code><br><img src="/images/ss/07.png" alt="添加规则列表"></p>
<p><img src="/images/ss/08.png" alt="改为自动切换"></p>
<h2 id="视频教程">视频教程</h2><object width="541" height="450"><param name="allowFullScreen" value="true"><param name="movie" value="http://i7.imgs.letv.com/player/swfPlayer.swf?autoPlay=0&id=23744815"><embed src="http://i7.imgs.letv.com/player/swfPlayer.swf?autoPlay=0&id=23744815" width="541" height="450" allowfullscreen="true" type="application/x-shockwave-flash"></object>

<p>有问题欢迎留言交流!!!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于一些大家都懂的原因，访问GitHub或者Google需要进行特殊的”配置”。<br>之前一直用红杏的方式，后来红杏不行了，最近发现了ShadowSocks，折腾一下发现稳定性、速度都比红杏要好很多，推荐给大家使用。</p>
<hr>
<p><code>有内网代理的可以直]]>
    </summary>
    
      <category term="linux" scheme="http://liuxing.info/tags/linux/"/>
    
      <category term="shadowsocks" scheme="http://liuxing.info/tags/shadowsocks/"/>
    
      <category term="ss" scheme="http://liuxing.info/tags/ss/"/>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重试机制的分析]]></title>
    <link href="http://liuxing.info/2015/07/08/%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>http://liuxing.info/2015/07/08/重试机制的分析/</id>
    <published>2015-07-07T16:22:00.000Z</published>
    <updated>2015-07-07T19:16:07.000Z</updated>
    <content type="html"><![CDATA[<p><em>记录一下今天碰到的问题</em></p>
<hr>
<h2 id="前言">前言</h2><p>对于经常跟网络编程打交道的你来说，并不是你的每次请求，服务端都会给你想要的结果。<br>重试机制虽然并不能解决这种情况，但是却可以大大减少这种情况的发生。</p>
<h2 id="缘由">缘由</h2><p>最近几天发现系统里面的solr数据频繁的出现数据同步不及时，统计数据以及分析日志后发现</p>
<ul>
<li>近期合并了几家公司，数据量增加了1倍多，200w+ &gt; 400w+（数据量增加后优化搜索，可以另起话题）。</li>
<li>访问用户增加后随之网络IO不稳定（暂定）。</li>
<li>使用的是其他同事基于solrj开发的工具包，不知是否是最优化配置。</li>
<li>提交数据后出现异常，只是简单的捕获处理。</li>
</ul>
<h2 id="土办法">土办法</h2><p>先简单的加上一个重试机制。</p>
<p>原代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    inquirySolrService.commitBean(bean);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> retry = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> (retry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inquirySolrService.commitBean(bean);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage(), e);</span><br><span class="line">        retry --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本来这样已经满足了，但是这种逻辑在好几个地方都有，同样的代码，想想就恶心。<br>想起在使用Spring RestTemplate / HttpClient的时候，可以设置一个重试的处理器。<br>重试机制是理解的，但是很好奇Spring到底是怎么处理的？毕竟大神们整的东西还是有学习的地方的！</p>
<h2 id="对RestTemplate重试的分析">对RestTemplate重试的分析</h2><h3 id="处理器分析">处理器分析</h3><p><strong>具体使用配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认的重试处理器</span></span><br><span class="line">httpClientBuilder.setRetryHandler(<span class="keyword">new</span> DefaultHttpRequestRetryHandler(<span class="number">2</span>, <span class="keyword">true</span>));</span><br></pre></td></tr></table></figure>
<p><strong>HttpRequestRetryHandler</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpRequestRetryHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retryRequest</span><span class="params">(IOException exception, <span class="keyword">int</span> executionCount, HttpContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>DefaultHttpRequestRetryHandler</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultHttpRequestRetryHandler</span> <span class="keyword">implements</span> <span class="title">HttpRequestRetryHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultHttpRequestRetryHandler INSTANCE = <span class="keyword">new</span> DefaultHttpRequestRetryHandler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重试次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> retryCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否重试</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> requestSentRetryEnabled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这几类异常不重试</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Class&lt;? extends IOException&gt;&gt; nonRetriableClasses;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DefaultHttpRequestRetryHandler</span><span class="params">(</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> retryCount,</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> requestSentRetryEnabled,</span><br><span class="line">            <span class="keyword">final</span> Collection&lt;Class&lt;? extends IOException&gt;&gt; clazzes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.retryCount = retryCount;</span><br><span class="line">        <span class="keyword">this</span>.requestSentRetryEnabled = requestSentRetryEnabled;</span><br><span class="line">        <span class="keyword">this</span>.nonRetriableClasses = <span class="keyword">new</span> HashSet&lt;Class&lt;? extends IOException&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Class&lt;? extends IOException&gt; clazz: clazzes) &#123;</span><br><span class="line">            <span class="keyword">this</span>.nonRetriableClasses.add(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultHttpRequestRetryHandler</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> retryCount, <span class="keyword">final</span> <span class="keyword">boolean</span> requestSentRetryEnabled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(retryCount, requestSentRetryEnabled, Arrays.asList(</span><br><span class="line">                InterruptedIOException.class,</span><br><span class="line">                UnknownHostException.class,</span><br><span class="line">                ConnectException.class,</span><br><span class="line">                SSLException.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认配置3次重试，但是没有开启</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultHttpRequestRetryHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重试处理的核心方法</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retryRequest</span><span class="params">(</span><br><span class="line">            <span class="keyword">final</span> IOException exception,</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> executionCount,</span><br><span class="line">            <span class="keyword">final</span> HttpContext context)</span> </span>&#123;</span><br><span class="line">        Args.notNull(exception, <span class="string">"Exception parameter"</span>);</span><br><span class="line">        Args.notNull(context, <span class="string">"HTTP context"</span>);</span><br><span class="line">        <span class="keyword">if</span> (executionCount &gt; <span class="keyword">this</span>.retryCount) &#123;</span><br><span class="line">            <span class="comment">// Do not retry if over max retry count</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.nonRetriableClasses.contains(exception.getClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> Class&lt;? extends IOException&gt; rejectException : <span class="keyword">this</span>.nonRetriableClasses) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rejectException.isInstance(exception)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> HttpClientContext clientContext = HttpClientContext.adapt(context);</span><br><span class="line">        <span class="keyword">final</span> HttpRequest request = clientContext.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(requestIsAborted(request))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handleAsIdempotent(request)) &#123;</span><br><span class="line">            <span class="comment">// Retry if the request is considered idempotent</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!clientContext.isRequestSent() || <span class="keyword">this</span>.requestSentRetryEnabled) &#123;</span><br><span class="line">            <span class="comment">// Retry if the request has not been sent fully or</span></span><br><span class="line">            <span class="comment">// if it's OK to retry methods that have been sent</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// otherwise do not retry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong><br>这个处理器的逻辑不是很复杂，配置重试次数和重试开关，某几种异常不进行重试等等，都是Http请求特有的业务处理方法。<br>对于排除的异常配置，很好理解，就是非常明确这几类异常没必要重试了。</p>
<h3 id="底层运行逻辑">底层运行逻辑</h3><p>其实RestTemplate是没有重试的运行逻辑（配置httpclient的方式），底层还是httpclient。<br>底层有好几个地方调用了<code>retryRequest()</code>逻辑，重试处理逻辑大致一样，挑RetryExec这个类吧！因为它代码比较少！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryExec</span> <span class="keyword">implements</span> <span class="title">ClientExecChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClientExecChain requestExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpRequestRetryHandler retryHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetryExec</span><span class="params">(</span><br><span class="line">            <span class="keyword">final</span> ClientExecChain requestExecutor,</span><br><span class="line">            <span class="keyword">final</span> HttpRequestRetryHandler retryHandler)</span> </span>&#123;</span><br><span class="line">        Args.notNull(requestExecutor, <span class="string">"HTTP request executor"</span>);</span><br><span class="line">        Args.notNull(retryHandler, <span class="string">"HTTP request retry handler"</span>);</span><br><span class="line">        <span class="keyword">this</span>.requestExecutor = requestExecutor;</span><br><span class="line">        <span class="keyword">this</span>.retryHandler = retryHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CloseableHttpResponse <span class="title">execute</span><span class="params">(</span><br><span class="line">            <span class="keyword">final</span> HttpRoute route,</span><br><span class="line">            <span class="keyword">final</span> HttpRequestWrapper request,</span><br><span class="line">            <span class="keyword">final</span> HttpClientContext context,</span><br><span class="line">            <span class="keyword">final</span> HttpExecutionAware execAware)</span> <span class="keyword">throws</span> IOException, HttpException </span>&#123;</span><br><span class="line">        Args.notNull(route, <span class="string">"HTTP route"</span>);</span><br><span class="line">        Args.notNull(request, <span class="string">"HTTP request"</span>);</span><br><span class="line">        Args.notNull(context, <span class="string">"HTTP context"</span>);</span><br><span class="line">        <span class="keyword">final</span> Header[] origheaders = request.getAllHeaders();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> execCount = <span class="number">1</span>;; execCount++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.requestExecutor.execute(route, request, context, execAware);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ex) &#123;</span><br><span class="line">                <span class="comment">// 检查可确定的中断逻辑，退出</span></span><br><span class="line">                <span class="comment">// 代码略</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 校验是否重试</span></span><br><span class="line">                <span class="keyword">if</span> (retryHandler.retryRequest(ex, execCount, context)) &#123;</span><br><span class="line">                    <span class="comment">// 记录日志和其他业务方法</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 业务处理，并抛出异常，退出</span></span><br><span class="line">                    <span class="comment">// 代码略</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上还是一个递归的逻辑，方法定义一个execCount计数，正常执行完毕就跳出循环。<br>出现异常时，用计数器去检查是否重试和比较重试次数，不通过就抛异常跳出循环。<br>好吧，我也没想到其实就是这样的！<br>考虑到一些其他框架里面都有重试的机制，逻辑应该都差不多，差异的只是对自己特有业务规则的处理。</p>
<p>httpclient底层执行请求时还有几个有意思的重试。<br>它把建立连接和请求内容等步骤又额外拆分成了独立的几个重试。<br>我猜想这样的好处是避免一个步骤出错导致整个流程重复执行。</p>
<h2 id="提取重试执行工具">提取重试执行工具</h2><p>本着重复代码不要写第二次的原则，还是硬着头皮提取了一个重试执行工具</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@title</span>：RetryUtil重试执行工具类</span><br><span class="line"> * <span class="doctag">@author</span>：liuxing</span><br><span class="line"> * <span class="doctag">@date</span>：2015-07-08 01:55</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(RetryUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecuteFunction</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 重试执行</span><br><span class="line">     * <span class="doctag">@param</span> retryCount</span><br><span class="line">     * <span class="doctag">@param</span> interval</span><br><span class="line">     * <span class="doctag">@param</span> timeUnit</span><br><span class="line">     * <span class="doctag">@param</span> throwIfFail</span><br><span class="line">     * <span class="doctag">@param</span> function</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(<span class="keyword">int</span> retryCount, <span class="keyword">long</span> interval, TimeUnit timeUnit, <span class="keyword">boolean</span> throwIfFail, ExecuteFunction function)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (function == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; retryCount; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                function.execute();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == retryCount - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (throwIfFail) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (timeUnit != <span class="keyword">null</span> &amp;&amp; interval &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            timeUnit.sleep(interval);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                            LOGGER.error(e1.getMessage(), e1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 有间隔的重试</span><br><span class="line">     * <span class="doctag">@param</span> retryCount</span><br><span class="line">     * <span class="doctag">@param</span> interval</span><br><span class="line">     * <span class="doctag">@param</span> timeUnit</span><br><span class="line">     * <span class="doctag">@param</span> handler</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(<span class="keyword">int</span> retryCount, <span class="keyword">long</span> interval, TimeUnit timeUnit, ExecuteFunction handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        retry(retryCount, interval, timeUnit, <span class="keyword">false</span>, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 不间隔重试</span><br><span class="line">     * <span class="doctag">@param</span> retryCount</span><br><span class="line">     * <span class="doctag">@param</span> function</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(<span class="keyword">int</span> retryCount, ExecuteFunction function)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        retry(retryCount, -<span class="number">1</span>, <span class="keyword">null</span>, function);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用重试工具执行方法，对比下来可读性好了很多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> retry = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> (retry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inquirySolrService.commitBean(bean);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage(), e);</span><br><span class="line">        retry --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    RetryUtil.retry(<span class="number">3</span>, <span class="number">50L</span>, TimeUnit.MILLISECONDS, () -&gt; &#123;</span><br><span class="line">        inquirySolrService.commitBean(bean);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>PS：保持好奇心，平常碰到的简单问题也记录总结一下，挺有意思的！</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>记录一下今天碰到的问题</em></p>
<hr>
<h2 id="前言">前言</h2><p>对于经常跟网络编程打交道的你来说，并不是你的每次请求，服务端都会给你想要的结果。<br>重试机制虽然并不能解决这种情况，但是却可以大大减少这种情况的发生。</p>
<h2]]>
    </summary>
    
      <category term="Java" scheme="http://liuxing.info/tags/Java/"/>
    
      <category term="重试工具" scheme="http://liuxing.info/tags/%E9%87%8D%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring JMS粗译]]></title>
    <link href="http://liuxing.info/2015/07/05/Spring%20JMS%E7%B2%97%E8%AF%91/"/>
    <id>http://liuxing.info/2015/07/05/Spring JMS粗译/</id>
    <published>2015-07-05T13:30:00.000Z</published>
    <updated>2015-07-05T13:37:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="24-1介绍">24.1介绍</h2><p>Spring提供了JMS集成框架简化了JMS API的使用，像Spring JDBC API的使用。</p>
<p>JMS的功能大致上分为两块，叫做消息发送和消息监听。JmsTemplate 用于发送消息和同步消息监听。和Java EE的事件驱动Bean风格类似，对于异步接收消息，Spring提供了一些消息监听容器来创建消息驱动的POJO（MDP）。</p>
<p>包 <code>org.springframework.jms.core</code> 提供使用JMS的核心功能。 就象为JDBC提供的 JdbcTemplate一样，它提供了JMS模板类来处理资源的创建和释放以简化JMS的使用。Spring模板类的公共设计原则就是通过提供工具方法去执行公共的操作，并将实际的处理任务委派到用户实现的回调接口上，从而完成更复杂的操作。JMS模板也遵循这样的设计原则。这些类提供众多便利的方法来发送消息、同步接收消息、使用户可以接触到JMS session和消息产生者。</p>
<p>包 <code>org.springframework.jms.support</code> 提供 <code>JMSException</code> 的转换功能。它将受控的 <code>JMSException</code> 异常层次转换到一个对应的非受控异常层次。任何受控 <code>javax.jms.JMSException</code> 异常的子类都被包装在非受控  <code>UncategorizedJmsException</code> 异常里。</p>
<p>包 <code>org.springframework.jms.support.converter</code> 提供一个 <code>MessageConverter</code> 用来抽象Java对象和JMS消息之间的转换操作。</p>
<p>包 <code>org.springframework.jms.support.destination</code> 为管理JMS目的地提供多种策略，例如为存储在JNDI中的目的地提供一个服务定位器。</p>
<p>包 <code>org.springframework.jms.annotation</code> 提供了必要的基础设施 支持注解驱动的端点侦听器使用 <code>@JmsListener</code>。</p>
<p>包 <code>org.springframework.jms.config</code> 提供的解析器实现 jms 命名空间以及java配置支持容器和配置监听器、创建端点侦听器。</p>
<p>包 <code>org.springframework.jms.connection</code> 提供一个适合在独立应用中使用的 <code>ConnectionFactory</code> 的实现。它还为JMS提供了一个Spring的 <code>PlatformTransactionManager</code> 的实现（现在叫做 <code>JmsTransactionManager</code>）。这样可以把JMS作为一个事务资源无缝地集成到Spring的事务管理机制中去。</p>
<h2 id="24-2使用Spring_JMS">24.2使用Spring JMS</h2><h3 id="24-2-1_JmsTemplate">24.2.1 JmsTemplate</h3><p>使用 <strong>JmsTemplate</strong> 的代码只需要实现规范中定义的回调接口。<strong>MessageCreator</strong> 回调接口通过 <strong>JmsTemplate</strong> 中调用代码提供的<strong>Session</strong>来创建一条消息。然而，为了允许更复杂的JMS API应用，回调接口<strong>SessionCallback</strong> 为用户提供JMS session，并且回调接口<strong>ProducerCallback</strong> 将<strong>Session</strong>和<strong>MessageProducer</strong>对显露给用户。</p>
<p>JMS API有两种发送方法，一种采用发送模式、优先级和存活时间作为服务质量（QOS）参数，另一种使用无需QOS参数的缺省值方法。由于在 JmsTemplate 中有许多种发送方法，QOS参数通过bean的属性方式进行设置，从而避免在多种发送方法中重复。同样，使用 setReceiveTimeout 属性值来设置同步接收调用的超时值。</p>
<p>某些JMS供应者允许通过ConnectionFactory的配置来设置缺省的QOS值。这样在调用 MessageProducer 的发送方法 send(Destination destination, Message message) 时会使用那些不同的QOS缺省值，而不是JMS规范中定义的值。所以，为了提供对QOS值的一致管理，JmsTemplate必须通过设置布尔值属性 isExplicitQosEnabled 为true，使它能够使用自己的QOS值。</p>
<blockquote>
<p>JmsTemplate 类的实例 一经配置便是线程安全 的。 这很重要，因为这意味着你可以配置一个 JmsTemplate 的单例，然后把这个 共享的 引用安全的实例注入多个协作的对象中。 要清楚一点，JmsTemplate 是有状态的，因为它维护了 ConnectionFactory 的引用，但这个状态不属于会话状态。</p>
</blockquote>
<p>Spring Framework 4.1提供了一个<strong>JmsMessagingTemplate</strong>，这个是对JmsTemplate的包装，主要用来发送最基本的消息内容，即<code>org.springframework.messaging.Message</code></p>
<h3 id="24-2-2连接">24.2.2连接</h3><p>JmsTemplate 需要一个对 ConnectionFactory 的引用。ConnectionFactory 是JMS规范的一部分，并且是使用JMS的入口。客户端应用通常用它作工厂配合JMS提供者去创建连接，并封装许多和供应商相关的配置参数，例如SSL的配置选项。</p>
<p>当在EJB里使用JMS时，供应商会提供JMS接口的实现，这样们可以参与声明式事务管理并提供连接池和会话池。 为了使用这个JMS实现，Java EE容器通常要求你在EJB或servlet部署描述符中声明一个JMS连接工厂做为 resource-ref。 为确保可以在EJB内使用 JmsTemplate 的这些特性，客户应用应当确保它引用了被管理的ConnectionFactory实现。</p>
<p><strong>缓存消息传递资源</strong><br>标准的API执行流程如下：<br>ConnectionFactory-&gt;Connection-&gt;Session-&gt;MessageProducer-&gt;send</p>
<p>从创建到发送有三个中间对象的创建和销毁，为了提高性能，Spring提供了<strong>ConnectionFactory</strong></p>
<p><strong>SingleConnectionFactory</strong><br>Spring提供了一个 ConnectionFactory 接口的实现，SingleConnectionFactory，它将在所有的 createConnection 调用中返回一个相同的 Connection，并忽略所有对 close的调用。这在测试和独立环境中相当有用，因为多个 JmsTemplate 调用可以使用同一个连接以跨越多个事务。SingleConnectionFactory 通常引用一个来自JNDI的标准 ConnectionFactory。</p>
<p><strong>CachingConnectionFactory</strong><br>CachingConnectionFactory类扩展自SingleConnectionFactory，主要用于提供缓存JMS资源功能。具体包括MessageProducer、MessageConsumer和Session的缓存功能。<br>默认情况下，CachingConnectionFactory只缓存一个session，在它的JavaDoc中，它声明对于低并发情况下这是足够的。可以使用SessionCacheSize进行配置。</p>
<h3 id="24-2-3目的地管理">24.2.3目的地管理</h3><p>和连接工厂一样，目的地是可以在JNDI中存储和获取的JMS管理的对象。配置一个Spring应用上下文时，可以使用JNDI工厂类 JndiObjectFactoryBean 把对你对象的引用依赖注入到JMS目的地中。然而，如果在应用中有大量的目的地，或者JMS供应商提供了特有的高级目的地管理特性，这个策略常常显得很麻烦。创建动态目的地或支持目的地的命名空间层次就是这种高级目的地管理的例子。JmsTemplate 将目的地名称到JMS目的地对象的解析委派给 DestinationResolver 接口的一个实现。JndiDestinationResolver 是 JmsTemplate 使用的默认实现，并且提供动态目的地解析。同时 JndiDestinationResolver 作为JNDI中的目的地服务定位器，还可选择回退去使用 DynamicDestinationResolver 中的行为。</p>
<p>经常见到一个JMS应用中使用的目的地只有在运行时才知道，因此，当部署一个应用时，它不能用可管理的方式创建。这是经常发生的，因为在互相作用的系统组件间有些共享应用逻辑会在运行的时候按照共同的命名规范创建消息目的地。虽然动态创建目的地不是JMS规范的一部分，但是大多数供应商已经提供了这个功能。用户为动态创建的目的地定义和临时目的地不同的名字，并且通常不被注册到JNDI中。不同供应商创建动态消息目的地所使用的API差异很大，因为和目的地相关的属性是供应商特有的。然而，有时由供应商会作出一个简单的实现选择-忽略JMS规范中的警告，使用 TopicSession 的方法 createTopic(String topicName) 或者 QueueSession 的方法 createQueue(String queueName) 来创建一个带默认值属性的新目的地。依赖于供应商的实现，DynamicDestinationResolver 也可能创建一个物理上的目的地，而不再仅仅是一个解析。</p>
<p>布尔属性 pubSubDomain 用来配置 JmsTemplate 使用什么样的JMS域。这个属性的默认值是false，使用点到点的域，也就是队列。在1.0.2的实现中，这个属性值用来决定 JmsTemplate 将消息发送到一个 Queue 还是一个 Topic。这个标志在1.1的实现中对发送操作没有影响。然而，在这两个JMS版本中，这个属性决定了通过接口 DestinationResolver 的实现来决定如何解析动态消息目的地。</p>
<p>你还可以通过属性 defaultDestination 配置一个带有默认目的地的 JmsTemplate。不指明目的地的发送和接受操作将使用该默认目的地。</p>
<h3 id="24-2-4消息监听容器">24.2.4消息监听容器</h3><p>在EJB世界里，JMS消息最常用的功能之一是用于实现消息驱动Bean（MDB）。Spring提供了一个方法来创建消息驱动的POJO（MDP），并且不会把用户绑定在某个EJB容器上。</p>
<p>通常用消息监听器容器从JMS消息队列接收消息并驱动被注射进来的MDP。消息监听器容器负责消息接收的多线程处理并分发到各MDP中。一个消息侦听容器是MDP和消息提供者之间的一个中介，用来处理消息接收的注册，事务管理的参与，资源获取和释放，异常转换等等。这使得应用开发人员可以专注于开发和接收消息（可能的响应）相关的（复杂）业务逻辑，把和JMS基础框架有关的样板化的部分委托给框架处理。</p>
<p><strong>SimpleMessageListenerContainer</strong><br>这个消息侦听容器是最简单的。它在启动时创建固定数量的JMS session并在容器的整个生命周期中使用它们。这个类不能动态的适应运行时的要求或参与消息接收的事务处理。然而它对JMS提供者的要求也最低。它只需要简单的JMS API。</p>
<p><strong>DefaultMessageListenerContainer</strong><br>这个消息侦听器使用的最多。和 SimpleMessageListenerContainer 相反，这个子类可以动态适应运行时侯的要求，也可以参与事务管理。每个收到的消息都注册到一个XA事务中（如果使用 JtaTransactionManager 配置过），这样就可以利用XA事务语义的优势了。这个类在对JMS提供者的低要求和提供包括事务参于等的强大功能上取得了很好的平衡。</p>
<h3 id="24-2-5事务管理">24.2.5事务管理</h3><p>Spring提供了 JmsTransactionManager 为单个JMS ConnectionFactory 管理事务。这将允许JMS应用利用Spring的事务管理功能。JmsTransactionManager 绑定 ConnectionFactory 的一个Connection/Session对到线程上，来提供本地资源事务。JmsTemplate 自动检测到这些事务性资源从而对它们进行操作。</p>
<p>在Java EE环境中，SingleConnectionFactory将把Connection和Session放到缓冲池中，因此这些资源在事务中得到了有效的复用。在独立环境中使用Spring的 SingleConnectionFactory 会存在共享的JMS Connection，但每个事务有自己独立的 Session。另外可以考虑使用供应商特定的池适配器,，如ActiveMQ的 PooledConnectionFactory 类。</p>
<p>JmsTemplate 也可以和 JtaTransactionManager 以及具有XA能力的JMS ConnectionFactory一起使用来提供分布式事务。记住这需要使用JTA事务管理器或合适的可配置的XA ConnectionFactory！（参考你所使用的J2EE服务器/JMS供应商的文档。）</p>
<p>当使用JMS API从一个 Connection 中创建 Session 时，在受管理的和非受管理的事务环境下重用代码会可能会让人迷惑。这是因为JMS API只有一个工厂方法来创建 Session ，并且它需要用于事务和模式确认的值。在受管理的环境下，由事务结构环境负责设置这些值，这样在供应商包装的JMS连接中可以忽略这些值。当在一个非管理性的环境中使用 JmsTemplate 时，你可以通过使用属性 SessionTransacted 和 SessionAcknowledgeMode 来指定这些值。当 JmsTemplate 配合 PlatformTransactionManager 使用时，模板将一直被赋予一个事务性JMS的 Session。</p>
<h2 id="24-3发送消息">24.3发送消息</h2><p>JmsTemplate 包含许多方便的方法来发送消息。有些发送方法可以使用 javax.jms.Destination 对象指定目的地，也可以使用字符串在JNDI中查找目的地。没有目的地参数的发送方法使用默认的目的地。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Queue;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.MessageCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsQueueSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionFactory</span><span class="params">(ConnectionFactory cf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jmsTemplate = <span class="keyword">new</span> JmsTemplate(cf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQueue</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jmsTemplate.send(<span class="keyword">this</span>.queue, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(<span class="string">"hello queue world"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子使用 MessageCreator 回调接口从提供的 Session 对象中创建一个文本消息，并且通过一个 ConnectionFactory 的引用来创建 JmsTemplate。提供了一个无参数的构造器和 connectionFactory 可用于创建实例（使用一个BeanFactory或者普通Java代码）。或者考虑继承Spring的基类 JmsGatewaySupport，它对JMS配置具有内置的Bean属性。</p>
<p>方法 send(String destinationName, MessageCreator creator) 让你利用目的地的字符串名字发送消息。如果这个名字在JNDI中注册，你应当将模板中的 destinationResolver 属性设置为 JndiDestinationResolver 的一个实例。<br>如果你创建 JmsTemplate 并指定一个默认的目的地，send(MessageCreator c) 发送消息到这个目的地。</p>
<h3 id="24-3-1使用消息转换器">24.3.1使用消息转换器</h3><p>为便于发送领域模型对象，JmsTemplate 有多种以一个Java对象为参数并做为消息数据内容的发送方法。JmsTemplate 里可重载的方法 convertAndSend 和 receiveAndConvert 将转换的过程委托给接口 MessageConverter 的一个实例。这个接口定义了一个简单的合约用来在Java对象和JMS消息间进行转换。缺省的实现 SimpleMessageConverter 支持 String 和 TextMessage，byte[] 和 BytesMesssage，以及 java.util.Map 和 MapMessage 之间的转换。使用转换器，可以使你和你的应用关注于通过JMS接收和发送的业务对象而不用操心它是具体如何表达成JMS消息的。</p>
<p>目前的沙箱模型包括一个 MapMessageConverter，它使用反射转换JavaBean和 MapMessage。其他流行可选的实现方式包括使用已存在的XML编组的包，例如JAXB、Castor、XMLBeans或XStream的转换器来创建一个表示对象的 TextMessage。</p>
<p>为方便那些不能以通用方式封装在转换类里的消息属性，消息头和消息体的设置，通过 MessagePostProcessor 接口你可以在消息被转换后并且在发送前访问该消息。下例展示了如何在 java.util.Map 已经转换成一个消息后更改消息头和属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendWithConversion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"Name"</span>, <span class="string">"Mark"</span>);</span><br><span class="line">    map.put(<span class="string">"Age"</span>, <span class="keyword">new</span> Integer(<span class="number">47</span>));</span><br><span class="line">    jmsTemplate.convertAndSend(<span class="string">"testQueue"</span>, map, <span class="keyword">new</span> MessagePostProcessor() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">            message.setIntProperty(<span class="string">"AccountID"</span>, <span class="number">1234</span>);</span><br><span class="line">            message.setJMSCorrelationID(<span class="string">"123-00001"</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将产生以下消息格式<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">MapMessage=&#123;</span><br><span class="line">	Header=&#123;</span><br><span class="line">		... standard headers ...</span><br><span class="line">		CorrelationID=&#123;123-00001&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Properties=&#123;</span><br><span class="line">		AccountID=&#123;Integer:1234&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fields=&#123;</span><br><span class="line">		Name=&#123;String:Mark&#125;</span><br><span class="line">		Age=&#123;Integer:47&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="24-3-2_SessionCallback和ProducerCallback">24.3.2 SessionCallback和ProducerCallback</h3><p>虽然send操作适用于许多常见的使用场景，但是有时你需要在一个JMS Session 或者 MessageProducer 上执行多个操作。接口 SessionCallback 和 ProducerCallback 分别提供了JMS Session 和 Session / MessageProducer 对。JmsTemplate 上的 execute() 方法执行这些回调方法。</p>
<h2 id="24-4接收消息">24.4接收消息</h2><h3 id="24-4-1同步接收">24.4.1同步接收</h3><p>虽然JMS一般都和异步处理相关，但它也可以同步的方式使用消息。可重载的 receive(..) 方法提供了这种功能。在同步接收中，接收线程被阻塞直至获得一个消息，有可能出现线程被无限阻塞的危险情况。属性 receiveTimeout 指定了接收器可等待消息的延时时间。</p>
<h3 id="24-4-2异步接收消息驱动pojo">24.4.2异步接收消息驱动pojo</h3><blockquote>
<p>Spring还提供一个 @JmsListener 的注解，以非嵌入式的方式异步接受消息。</p>
</blockquote>
<p>类似于EJB世界里流行的消息驱动Bean（MDB），消息驱动POJO（MDP）作为JMS消息的接收器。MDP的一个约束（但也请看下面的有关 javax.jms.MessageListener 类的讨论）是它必须实现 javax.jms.MessageListener 接口。另外当你的POJO将以多线程的方式接收消息时必须确保你的代码是线程-安全的。</p>
<p>以下是MDP的一个简单实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> TextMessage) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(((TextMessage) message).getText());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (JMSException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must be of type TextMessage"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦你实现了 MessageListener 后就可以创建一个消息侦听容器。<br>请看下面例子是如何定义和配置一个随Sping发行的消息侦听容器的（这个例子用 DefaultMessageListenerContainer）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"messageListener"</span> <span class="attribute">class</span>=<span class="value">"jmsexample.ExampleListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- and this is the message listener container --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"jmsContainer"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connectionFactory"</span> <span class="attribute">ref</span>=<span class="value">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"destination"</span> <span class="attribute">ref</span>=<span class="value">"destination"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"messageListener"</span> <span class="attribute">ref</span>=<span class="value">"messageListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于各个消息侦听容器实现的功能请参阅相关的Spring Javadoc文档。</p>
<h3 id="24-4-3_SessionAwareMessageListener接口">24.4.3 SessionAwareMessageListener接口</h3><p>SessionAwareMessageListener 接口是一个Spring专门用来提供类似于JMS MessageListener 的接口，也提供了从接收 Message 来访问JMS Session 的消息处理方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.jms.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionAwareMessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Session session)</span> <span class="keyword">throws</span> JMSException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你希望你的MDP可以响应所有接收到的消息（使用 onMessage(Message, Session) 方法提供的 Session）那么你可以选择让你的MDP实现这个接口（优先于标准的JMS MessageListener 接口)。所有随Spring发行的支持MDP的消息侦听容器都支持 MessageListener 或 SessionAwareMessageListener 接口的实现。要注意的是实现了 SessionAwareMessageListener 接口的类通过接口和Spring有了耦合。是否选择使用它完全取决于开发者或架构师。</p>
<p>请注意 SessionAwareMessageListener 接口的 ‘onMessage(..)’ 方法会抛出 JMSException异常。和标准JMS MessageListener 接口相反，当使用 SessionAwareMessageListener 接口时，客户端代码负责处理任何抛出的异常。</p>
<h3 id="24-4-4_MessageListenerAdapter">24.4.4 MessageListenerAdapter</h3><p>MessageListenerAdapter 类是Spring的异步支持消息类中的不变类（final class）：简而言之，它允许你几乎将 任意 一个类做为MDP显露出来（当然有某些限制）。</p>
<p>考虑如下接口定义。注意虽然这个接口既不是从 MessageListener 也不是从 SessionAwareMessageListener 继承来得，但通过 MessageListenerAdapter 类依然可以当作一个MDP来使用。同时也请注意各种消息处理方法是如何根据他们可以接收并处理消息的内容来进行强类型匹配的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Map message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">byte</span>[] message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Serializable message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMessageDelegate</span> <span class="keyword">implements</span> <span class="title">MessageDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别请注意，上面的 MessageDelegate 接口（上文中 DefaultMessageDelegate 类）的实现完全 不 依赖于JMS。它是一个真正的POJO，我们可以通过如下配置把它设置成MDP。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"messageListener"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jms.listener.adapter.MessageListenerAdapter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"jmsexample.DefaultMessageDelegate"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- and this is the message listener container... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"jmsContainer"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connectionFactory"</span> <span class="attribute">ref</span>=<span class="value">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"destination"</span> <span class="attribute">ref</span>=<span class="value">"destination"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"messageListener"</span> <span class="attribute">ref</span>=<span class="value">"messageListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是另外一个只能处理接收JMS TextMessage 消息的MDP示例。注意消息处理方法是如何实际调用 ‘receive’ （在 MessageListenerAdapter 中默认的消息处理方法的名字是 ‘handleMessage’）的，但是它是可配置的（你下面就将看到）。注意 ‘receive(..)’ 方法是如何使用强制类型来只接收和处理JMS TextMessage消息的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TextMessageDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(TextMessage message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultTextMessageDelegate</span> <span class="keyword">implements</span> <span class="title">TextMessageDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>辅助的 MessageListenerAdapter 类配置文件类似如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"messageListener"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jms.listener.adapter.MessageListenerAdapter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"jmsexample.DefaultTextMessageDelegate"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"defaultListenerMethod"</span> <span class="attribute">value</span>=<span class="value">"receive"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- we don't want automatic message context extraction --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"messageConverter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">null</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请注意，如果上面的 ‘messageListener’ 收到一个不是 TextMessage 类型的JMS Message，将会产生一个 IllegalStateException 异常（随之产生的其他异常只被捕获而不处理）。<br>MessageListenerAdapter 还有一个功能就是如果处理方法返回一个非空值，它将自动返回一个响应 消息。<br>请看下面的接口及其实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponsiveTextMessageDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// notice the return type...</span></span><br><span class="line">    <span class="function">String <span class="title">receive</span><span class="params">(TextMessage message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResponsiveTextMessageDelegate</span> <span class="keyword">implements</span> <span class="title">ResponsiveTextMessageDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上面的 DefaultResponsiveTextMessageDelegate 和 MessageListenerAdapter 联合使用，那么任意从执行 ‘receive(..)’ 方法返回的非空值都将（缺省情况下）转换成一个 TextMessage。这个返回的 TextMessage 将被发送到原来的 Message 中JMS Reply-To属性定义的 目的地（如果存在），或者是 MessageListenerAdapter 设置（如果配置了）的缺省 目的地；如果没有定义 目的地，那么将产生一个 InvalidDestinationException 异常（此异常将不会只被捕获而不处理，它 将沿着调用堆栈上传）。</p>
<h3 id="24-4-5事务中的消息处理">24.4.5事务中的消息处理</h3><p>在消息监听器的调用中使用事务只需要重新配置监听器容器<br>通过监听器容器定义中的 sessionTransacted 标记可以轻松的激活本地资源事务。每次消息监听器的调用都在激活的JMS事务中执行，执行失败时，消息接收将发生回滚。这个本地事务还将包含响应信息的发送（通过 SessionAwareMessageListener），但其它资源的操作（例如访问数据库）是独立的。经常会发生类似于数据库处理已提交但消息处理提交失败的情况，因此需要在监听器的实现中进行重复消息的检测。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"jmsContainer"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connectionFactory"</span> <span class="attribute">ref</span>=<span class="value">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"destination"</span> <span class="attribute">ref</span>=<span class="value">"destination"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"messageListener"</span> <span class="attribute">ref</span>=<span class="value">"messageListener"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionTransacted"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当参与外部管理的事务时，你需要使用支持外来事务的监听器容器：通常是 DefaultMessageListenerContainer 来配置事务管理器。</p>
<p>参与XA事务时，消息监听器容器需要配置 JtaTransactionManager（默认会委托给J2EE服务器事务子系统）。注意以下JMS ConnectionFactory需要具有XA能力并注册JTA事务协调器！（参考你所使用的J2EE服务器中JNDI资源的配置。）这样，消息接收就像数据库访问一样作为同一个事务的一部分（具有统一提交的语义，仅仅增加了XA事务日志的额外开销）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.transaction.jta.JtaTransactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后你只需要把它添加到早先配置好的容器中。这个容器将处理剩下的事情。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"jmsContainer"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connectionFactory"</span> <span class="attribute">ref</span>=<span class="value">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"destination"</span> <span class="attribute">ref</span>=<span class="value">"destination"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"messageListener"</span> <span class="attribute">ref</span>=<span class="value">"messageListener"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"transactionManager"</span> <span class="attribute">ref</span>=<span class="value">"transactionManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="24-5JCA消息端点的支持">24.5JCA消息端点的支持</h2><p>从Spring2.5版本开始，Spring也提供了基于JCA MessageListener 容器的支持。 JmsMessageEndpointManager 将根据供应者 ResourceAdapter 的类名自动地决定 ActivationSpec 类名。因此，通常它只提供如下例所示的Spring的通用 JmsActivationSpecConfig 。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"resourceAdapter"</span> <span class="attribute">ref</span>=<span class="value">"resourceAdapter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"activationSpecConfig"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"destinationName"</span> <span class="attribute">value</span>=<span class="value">"myQueue"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"messageListener"</span> <span class="attribute">ref</span>=<span class="value">"myMessageListener"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外,你可以设置一个 JmsMessageEndpointManager 指定 ActivationSpec 对象。  ActivationSpec 对象可以通过JNDI查找来完成 (使用 <code>&lt;jee:jndi-lookup&gt;</code> )。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"resourceAdapter"</span> <span class="attribute">ref</span>=<span class="value">"resourceAdapter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"activationSpec"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.apache.activemq.ra.ActiveMQActivationSpec"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"destination"</span> <span class="attribute">value</span>=<span class="value">"myQueue"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"destinationType"</span> <span class="attribute">value</span>=<span class="value">"javax.jms.Queue"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"messageListener"</span> <span class="attribute">ref</span>=<span class="value">"myMessageListener"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用Spring的 ResourceAdapterFactoryBean， 目标 ResourceAdapter 可以像下例描述的那样本地配置。 在一些环境里（如WebLogic）也可以通过JNDI查找来完成。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"resourceAdapter"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jca.support.ResourceAdapterFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"resourceAdapter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.apache.activemq.ra.ActiveMQResourceAdapter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"serverUrl"</span> <span class="attribute">value</span>=<span class="value">"tcp://localhost:61616"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"workManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jca.work.SimpleTaskWorkManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请参考 JmsMessageEndpointManager、JmsActivationSpecConfig 和 ResourceAdapterFactoryBean 部分的JavaDoc，以获得更详细的信息。</p>
<p>Spring也提供了并不与JMS绑定的通用JCA消息端点管理器： org.springframework.jca.endpoint.GenericMessageEndpointManager。 它允许使用任何类型的消息监听器（例如CCI MessageListener）和任何提供者特定的ActivationSpec对象。从所涉及的JCA提供者的文档可以找到这个连接器的实际能力，从 GenericMessageEndpointManager 的JavaDoc中可以找到Spring特有的配置细节。</p>
<blockquote>
<p>基于JCA的消息端点管理器与EJB 2.1的Message-Driven Beans很相似，它使用了相同的资源提供者约定。像EJB 2.1 MDB一样，任何被JCA提供者支持的消息监听器接口都可以在Spring Context中使用。尽管如此，Spring仍为JMS提供了显式的“方便的”支持，很显然是因为JMS是JCA端点管理约定中最通用的端点API。</p>
</blockquote>
<h2 id="24-6注解驱动的监听器">24.6注解驱动的监听器</h2><p>异步接受消息最简单的方法是使用<code>@JmsListener</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@JmsListener</span>(destination = <span class="string">"myDestination"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">(String data)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>示例中，收到destination为“myDestination”的消息后，processOrder方法将被执行。</p>
<p>带注解的监听方法，底层是使用JmsListenerContainerFactory容器</p>
<h3 id="24-6-1启用端点侦听器的注解">24.6.1启用端点侦听器的注解</h3><p>Bean配置的方式：</p>
<p>为了使用@JmsListener注解，需要添加 @EnableJms 到 @Configuration 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@Configuration</span></span><br><span class="line"><span class="annotation">@EnableJms</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">jmsListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory =</span><br><span class="line">                <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory());</span><br><span class="line">        factory.setDestinationResolver(destinationResolver());</span><br><span class="line">        factory.setConcurrency(<span class="string">"3-10"</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用DefaultJmsListenerContainerFactory作为消息监听容器，setConcurrency用于配置消费线程，这里是最小3个，最大10个。</p>
<p>XML的方式：<br>使用<code>&lt;jms:annotation-driven&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">jms:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"jmsListenerContainerFactory"</span></span><br><span class="line">        <span class="attribute">class</span>=<span class="value">"org.springframework.jms.config.DefaultJmsListenerContainerFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connectionFactory"</span> <span class="attribute">ref</span>=<span class="value">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"destinationResolver"</span> <span class="attribute">ref</span>=<span class="value">"destinationResolver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"concurrency"</span> <span class="attribute">value</span>=<span class="value">"3-10"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="24-6-2编程注册端点">24.6.2编程注册端点</h3><p>JmsListenerEndpoint提供一个JMS端点模型和负责模型配置容器。允许我们以编程方式配置除了jmsListener外的端点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@Configuration</span></span><br><span class="line"><span class="annotation">@EnableJms</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> <span class="keyword">implements</span> <span class="title">JmsListenerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureJmsListeners</span><span class="params">(JmsListenerEndpointRegistrar registrar)</span> </span>&#123;</span><br><span class="line">        SimpleJmsListenerEndpoint endpoint = <span class="keyword">new</span> SimpleJmsListenerEndpoint();</span><br><span class="line">        endpoint.setId(<span class="string">"myJmsEndpoint"</span>);</span><br><span class="line">        endpoint.setDestination(<span class="string">"anotherQueue"</span>);</span><br><span class="line">        endpoint.setMessageListener(message -&gt; &#123;</span><br><span class="line">            <span class="comment">// processing</span></span><br><span class="line">        &#125;);</span><br><span class="line">        registrar.registerEndpoint(endpoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们使用SimpleJmsListenerEndpoint提供要调用的实际消息监听者，但你也可以建立自己的端点变量描述自定义调用机制。</p>
<p>值得注意的是，你也可以完全跳过使用@JmsListener，只通过JmsListenerConfigurer以编程方式注册您的端点。</p>
<h2 id="24-7JMS命名空间支持">24.7JMS命名空间支持</h2><p>Spring JMS引入了XML命名空间以简化JMS的配置。使用JMS命名空间元素时，需要引用如下的JMS Schema：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">        <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">        <span class="attribute">xmlns:jms</span>=<span class="value">"http://www.springframework.org/schema/jms"</span></span><br><span class="line">        <span class="attribute">xsi:schemaLocation</span>=<span class="value">"</span><br><span class="line">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">            http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- bean definitions here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个命名空间由两级元素组成：<code>&lt;listener-container/&gt;</code> 和 <code>&lt;jca-listener-container/&gt;</code>，它们都可以包含一个或这个多个 <listener> 子元素。下面是一个基本配置的示例，包含两个监听器。</listener></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">jms:listener-container</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">jms:listener</span> <span class="attribute">destination</span>=<span class="value">"queue.orders"</span> <span class="attribute">ref</span>=<span class="value">"orderService"</span> <span class="attribute">method</span>=<span class="value">"placeOrder"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">jms:listener</span> <span class="attribute">destination</span>=<span class="value">"queue.confirmations"</span> <span class="attribute">ref</span>=<span class="value">"confirmationLogger"</span> <span class="attribute">method</span>=<span class="value">"log"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">jms:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的例子等同于在<a href="#2444-messagelisteneradapter">24.4.4MessageListenerAdapter</a>的示例中，定义两个不同的监听器容器和两个不同的 MessageListenerAdapter 。除了上面的属性外，listener 元素还具有几个可选的属性。下面的表格列出了所有的属性：</p>
<p><strong>表24.1 JMS listener 元素的属性</strong> </p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">id</td>
<td style="text-align:left">监听器容器的Bean名称。如果没有指定，将自动生成一个Bean名称。</td>
</tr>
<tr>
<td style="text-align:left">destination （必须）</td>
<td style="text-align:left">监听器目的地的名称，由 DestinationResolver 的策略决定。</td>
</tr>
<tr>
<td style="text-align:left">ref （必须）</td>
<td style="text-align:left">处理对象的Bean名称</td>
</tr>
<tr>
<td style="text-align:left">method</td>
<td style="text-align:left">处理器中被调用的方法名。如果 ref 指向 MessageListener 或者 Spring SessionAwareMessageListener，则这个属性可以被忽略。</td>
</tr>
<tr>
<td style="text-align:left">response-destination</td>
<td style="text-align:left">默认的响应目的地是发送响应消息抵达的目的地。 这用于请求消息没有包含”JMSReplyTo”域的情况。响应目的地类型被监听器容器的”destination-type”属性决定。记住：这仅仅适用于有返回值的监听器方法，因为每个结果对象都会被转化成响应消息。</td>
</tr>
<tr>
<td style="text-align:left">subscription</td>
<td style="text-align:left">持久订阅的名称，如果需要的话。</td>
</tr>
<tr>
<td style="text-align:left">selector</td>
<td style="text-align:left">监听器的一个可选的消息选择器。</td>
</tr>
<tr>
<td style="text-align:left">concurrency</td>
<td style="text-align:left">并发的数量，格式：5（最大），3-5（最小和最大）</td>
</tr>
</tbody>
</table>
<p><code>&lt;listener-container/&gt;</code>元素也有几个可选的属性。 这些属性允许像 基本的 JMS设置和资源引用一样来定义不同的策略 （例如 taskExecutor 和 destinationResolver）。 使用这些属性，可以定义很广泛的定制监听器容器，同时仍享有命名空间的便利。</p>
<p>这样的设置可以自动公开一个 JmsListenerContainerFactory<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">jms:listener-container</span> <span class="attribute">connection-factory</span>=<span class="value">"myConnectionFactory"</span></span><br><span class="line">        <span class="attribute">task-executor</span>=<span class="value">"myTaskExecutor"</span></span><br><span class="line">        <span class="attribute">destination-resolver</span>=<span class="value">"myDestinationResolver"</span></span><br><span class="line">        <span class="attribute">transaction-manager</span>=<span class="value">"myTransactionManager"</span></span><br><span class="line">        <span class="attribute">concurrency</span>=<span class="value">"10"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">jms:listener</span> <span class="attribute">destination</span>=<span class="value">"queue.orders"</span> <span class="attribute">ref</span>=<span class="value">"orderService"</span> <span class="attribute">method</span>=<span class="value">"placeOrder"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">jms:listener</span> <span class="attribute">destination</span>=<span class="value">"queue.confirmations"</span> <span class="attribute">ref</span>=<span class="value">"confirmationLogger"</span> <span class="attribute">method</span>=<span class="value">"log"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">jms:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>下面的表格描述了所有可用的属性。参考 AbstractMessageListenerContainer 类和具体子类的Javadoc来了解每个属性的细节。这部分的Javadoc也提高那个了事务选择和消息传输场景的讨论。</p>
<p><strong>表24.2 JMS &lt; listener-container &gt;元素的属性</strong> </p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">container-type</td>
<td style="text-align:left">监听器容器的类型。可用的选项是： default、simple、default102 或者 simple102 （默认值是 ‘default’）。</td>
</tr>
<tr>
<td style="text-align:left">container-class</td>
<td style="text-align:left">定制监听器容器实现类的完全限定类名。默认是Spring标准使用DefaultMessageListenerContainer或SimpleMessageListenerContainer</td>
</tr>
<tr>
<td style="text-align:left">factory-id</td>
<td style="text-align:left">公开此元素被定义为一个JmsListenerContainerFactory与指定id，以便它们可以与其他的端点被重新使用的设置。</td>
</tr>
<tr>
<td style="text-align:left">connection-factory</td>
<td style="text-align:left">JMS ConnectionFactory Bean的引用（默认的Bean名称是 ‘connectionFactory’）。</td>
</tr>
<tr>
<td style="text-align:left">task-executor</td>
<td style="text-align:left">JMS监听器调用者Spring TaskExecutor 的引用。</td>
</tr>
<tr>
<td style="text-align:left">destination-resolver</td>
<td style="text-align:left">DestinationResolver 策略的引用，用以解析JMS Destinations。</td>
</tr>
<tr>
<td style="text-align:left">message-converter</td>
<td style="text-align:left">MessageConverter 策略的引用，用以转换JMS Messages 成监听器方法的参数。默认值是 SimpleMessageConverter。</td>
</tr>
<tr>
<td style="text-align:left">error-handler</td>
<td style="text-align:left">异常处理的策略</td>
</tr>
<tr>
<td style="text-align:left">destination-type</td>
<td style="text-align:left">监听器的JMS目的地类型。可用的选项包含： queue、topic 或者 durableTopic （默认值是 ‘queue’）。</td>
</tr>
<tr>
<td style="text-align:left">client-id</td>
<td style="text-align:left">这个监听器容器在JMS客户端的id。</td>
</tr>
<tr>
<td style="text-align:left">cache</td>
<td style="text-align:left">The cache level for JMS resources:<code>none</code>,<code>connection</code>,<code>session</code>,<code>consumer</code> or<code>auto</code>. By default (<code>auto</code>), the cache level will effectively be “consumer”, unless an external transaction manager has been specified - in which case the effective default will be<code>none</code> (assuming Java EE-style transaction management where the given ConnectionFactory is an XA-aware pool).</td>
</tr>
<tr>
<td style="text-align:left">acknowledge</td>
<td style="text-align:left">本地JMS应答模式。可用的选项包含： auto、client、dups-ok 或者 transacted （默认值是 ‘auto’）。 ‘transacted’ 的值可激活本地事务性 Session。 也可以通过指定下面介绍的 transaction-manager 属性。</td>
</tr>
<tr>
<td style="text-align:left">transaction-manager</td>
<td style="text-align:left">Spring PlatformTransactionManager 的引用。</td>
</tr>
<tr>
<td style="text-align:left">concurrency</td>
<td style="text-align:left">每个监听器可激活的Session最大并发数。</td>
</tr>
<tr>
<td style="text-align:left">prefetch</td>
<td style="text-align:left">加载进每个Session的最大消息数。记住增加这个值会造成并发空闲。</td>
</tr>
<tr>
<td style="text-align:left">receive-timeout</td>
<td style="text-align:left">接受消息的超时时间，单位是毫秒，默认是1000，-1表示没超时</td>
</tr>
<tr>
<td style="text-align:left">back-off</td>
<td style="text-align:left">发生冲突时的强制性重传延迟，如果 BackOffExecution 实现返回 <code>BackOffExecution #STOP</code> , 侦听器容器不会进一步尝试恢复，设置的recovery-interval 值将被忽略。默认是一个 FixedBackOff 与 5000毫秒的时间间隔</td>
</tr>
<tr>
<td style="text-align:left">recovery-interval</td>
<td style="text-align:left">指定时间间隔恢复的尝试,以毫秒为单位。 方便 方法创建一个 FixedBackOff 指定的时间间隔。 更多的复苏 选项,可以考虑指定一个<code>back-off</code>的实例。 默认值是5000毫秒。</td>
</tr>
<tr>
<td style="text-align:left">phase</td>
<td style="text-align:left">这个容器的生命周期阶段应该启动和停止。越低值在这个容器将开始和后来将停止。默认值是Integer.MAX_VALUE 这意味着容器尽可能晚地将开始和停止快越好。</td>
</tr>
</tbody>
</table>
<p>使用“jms” Schema支持来配置基于JCA的监听器容器很相似</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">jms:jca-listener-container</span> <span class="attribute">resource-adapter</span>=<span class="value">"myResourceAdapter"</span></span><br><span class="line">        <span class="attribute">destination-resolver</span>=<span class="value">"myDestinationResolver"</span></span><br><span class="line">        <span class="attribute">transaction-manager</span>=<span class="value">"myTransactionManager"</span></span><br><span class="line">        <span class="attribute">concurrency</span>=<span class="value">"10"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">jms:listener</span> <span class="attribute">destination</span>=<span class="value">"queue.orders"</span> <span class="attribute">ref</span>=<span class="value">"myMessageListener"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">jms:jca-listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>表24.3 JMS &lt; jca-listener-container / &gt;元素的属性</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">factory-id</td>
<td style="text-align:left">公开此元素被定义为一个JmsListenerContainerFactory与指定id，以便它们可以与其他的端点被重新使用的设置。</td>
</tr>
<tr>
<td style="text-align:left">resource-adapter</td>
<td style="text-align:left">JCA ResourceAdapter Bean 的一个引用（默认的Bean名称是’resourceAdapter’）</td>
</tr>
<tr>
<td style="text-align:left">activation-spec-factory</td>
<td style="text-align:left">JmsActivationSpecFactory 的一个引用。 默认自动检测JMS提供者和它的 ActivationSpec 类 （参考 DefaultJmsActivationSpecFactory）</td>
</tr>
<tr>
<td style="text-align:left">destination-resolver</td>
<td style="text-align:left">DestinationResolver 策略的引用，用以解析JMS Destinations。</td>
</tr>
<tr>
<td style="text-align:left">message-converter</td>
<td style="text-align:left">MessageConverter 策略的引用，用以转换JMS Messages 成监听器方法参数。 默认值是 SimpleMessageConverter</td>
</tr>
<tr>
<td style="text-align:left">destination-type</td>
<td style="text-align:left">监听器的JMS目的地类型。可用的选项包含 queue、topic 或者 durableTopic 默认是 ‘queue’）。</td>
</tr>
<tr>
<td style="text-align:left">client-id</td>
<td style="text-align:left">这个监听器容器在JMS客户端的id。</td>
</tr>
<tr>
<td style="text-align:left">acknowledge</td>
<td style="text-align:left">本地JMS应答模式。可用的选项包含：auto、client、dups-ok 或者 transacted （默认值是 ‘auto’）。 ‘transacted’ 的值可激活本地事务性 Session。 也可以通过指定下面介绍的 transaction-manager 属性</td>
</tr>
<tr>
<td style="text-align:left">transaction-manager</td>
<td style="text-align:left">Spring JtaTransactionManager 或者 javax.transaction.TransactionManager 的引用，用以为传进的消息应用XA事务。 如果没有指定，将使用本地应答模型（参见“acknowledge”属性）。</td>
</tr>
<tr>
<td style="text-align:left">concurrency</td>
<td style="text-align:left">每个监听器可激活的Session最大并发数。</td>
</tr>
<tr>
<td style="text-align:left">prefetch</td>
<td style="text-align:left">加载进每个Session的最大消息数。记住增加这个值会造成并发空闲。</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="24-1介绍">24.1介绍</h2><p>Spring提供了JMS集成框架简化了JMS API的使用，像Spring JDBC API的使用。</p>
<p>JMS的功能大致上分为两块，叫做消息发送和消息监听。JmsTemplate 用于发送消息和同步消息监听。]]>
    </summary>
    
      <category term="JMS" scheme="http://liuxing.info/tags/JMS/"/>
    
      <category term="Spring" scheme="http://liuxing.info/tags/Spring/"/>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring Cache使用]]></title>
    <link href="http://liuxing.info/2015/06/18/Spring%20Cache%E4%BD%BF%E7%94%A8/"/>
    <id>http://liuxing.info/2015/06/18/Spring Cache使用/</id>
    <published>2015-06-17T16:27:00.000Z</published>
    <updated>2015-06-30T12:15:16.000Z</updated>
    <content type="html"><![CDATA[<p><em>记录下自己项目在用的Spring Cache的使用方式。</em><br><em>Spring的抽象已经做得够好了，适合于大多数场景，非常复杂的就需要自己AOP实现了。</em><br><em>Spring官网的文档挺不错的，但是对Cache这块的介绍不是很详细，结合网上大牛的博文，汇总下文。</em></p>
<h2 id="缓存概念">缓存概念</h2><blockquote><h3 id="缓存简介">缓存简介</h3><p>缓存，我的理解是：让数据更接近于使用者；工作机制是：先从缓存中读取数据，如果没有再从慢速设备上读取实际数据（数据也会存入缓存）；缓存什么：那些经常读取且不经常修改的数据/那些昂贵（CPU/IO）的且对于相同的请求有相同的计算结果的数据。如CPU—L1/L2—内存—磁盘就是一个典型的例子，CPU需要数据时先从L1/L2中读取，如果没有到内存中找，如果还没有会到磁盘上找。还有如用过Maven的朋友都应该知道，我们找依赖的时候，先从本机仓库找，再从本地服务器仓库找，最后到远程仓库服务器找；还有如京东的物流为什么那么快？他们在各个地都有分仓库，如果该仓库有货物那么送货的速度是非常快的。</p>
<h3 id="缓存命中率">缓存命中率</h3><p>即从缓存中读取数据的次数 与 总读取次数的比率，命中率越高越好：<br>命中率 = 从缓存中读取次数 / (总读取次数[从缓存中读取次数 + 从慢速设备上读取的次数])<br>Miss率 = 没有从缓存中读取的次数 / (总读取次数[从缓存中读取次数 + 从慢速设备上读取的次数])</p>
<p>这是一个非常重要的监控指标，如果做缓存一定要健康这个指标来看缓存是否工作良好；</p>
<h3 id="缓存策略">缓存策略</h3><h4 id="Eviction_policy">Eviction policy</h4><p>移除策略，即如果缓存满了，从缓存中移除数据的策略；常见的有LFU、LRU、FIFO：</p>
<ul>
<li>FIFO（First In First Out）：先进先出算法，即先放入缓存的先被移除；</li>
<li>LRU（Least Recently Used）：最久未使用算法，使用时间距离现在最久的那个被移除；</li>
<li>LFU（Least Frequently Used）：最近最少使用算法，一定时间段内使用次数（频率）最少的那个被移除；</li>
</ul>
<h4 id="TTL（Time_To_Live_）">TTL（Time To Live ）</h4><p>存活期，即从缓存中创建时间点开始直到它到期的一个时间段（不管在这个时间段内有没有访问都将过期）</p>
<h4 id="TTI（Time_To_Idle）">TTI（Time To Idle）</h4><p>空闲期，即一个数据多久没被访问将从缓存中移除的时间。</p>
<p>到此，基本了解了缓存的知识，在Java中，我们一般对调用方法进行缓存控制，比如我调用”findUserById(Long id)”，那么我应该在调用这个方法之前先从缓存中查找有没有，如果没有再掉该方法如从数据库加载用户，然后添加到缓存中，下次调用时将会从缓存中获取到数据。</p>
<p>自Spring 3.1起，提供了类似于@Transactional注解事务的注解Cache支持，且提供了Cache抽象；在此之前一般通过AOP实现；使用Spring Cache的好处：</p>
<ul>
<li>提供基本的Cache抽象，方便切换各种底层Cache；</li>
<li>通过注解Cache可以实现类似于事务一样，缓存逻辑透明的应用到我们的业务代码上，且只需要更少的代码就可以完成；</li>
<li>提供事务回滚时也自动回滚缓存；</li>
<li>支持比较复杂的缓存逻辑；</li>
</ul>
<p>对于Spring Cache抽象，主要从以下几个方面学习：</p>
<ul>
<li>Cache API及默认提供的实现</li>
<li>Cache注解</li>
<li>实现复杂的Cache逻辑</li>
</ul>
<footer><strong>缓存简介</strong><cite><a href="http://jinnianshilongnian.iteye.com/blog/2001040" target="_blank" rel="external">开涛的博客</a></cite></footer></blockquote>
<h2 id="Spring_Cache简介">Spring Cache简介</h2><blockquote><p>Spring3.1开始引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如EHCache 或者 OSCache），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。</p>
<p>Spring的缓存技术还具备相当的灵活性，不仅能够使用 SpEL（Spring Expression Language）来定义缓存的key和各种condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存例如EHCache、memcached集成。</p>
<p>其特点总结如下：</p>
<ul>
<li>通过少量的配置 annotation 注释即可使得既有代码支持缓存</li>
<li>支持开箱即用 Out-Of-The-Box，即不用安装和部署额外第三方组件即可使用缓存</li>
<li>支持 Spring Express Language，能使用对象的任何属性或者方法来定义缓存的 key 和 condition</li>
<li>支持 AspectJ，并通过其实现任何方法的缓存支持</li>
<li>支持自定义 key 和自定义缓存管理者，具有相当的灵活性和扩展性</li>
</ul>
<footer><strong>Spring Cache 介绍</strong><cite><a href="http://www.cnblogs.com/rollenholt/p/4202631.html" target="_blank" rel="external">Spring Cache 介绍 - Rollen Holt - 博客园</a></cite></footer></blockquote>
<h2 id="API介绍">API介绍</h2><h3 id="Cache接口">Cache接口</h3><p><code>理解这个接口有助于我们实现自己的缓存管理器</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 缓存的名字</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 得到底层使用的缓存</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getNativeCache</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 根据key得到一个ValueWrapper，然后调用其get方法获取值 </span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function">ValueWrapper <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 根据key，和value的类型直接获取value  </span><br><span class="line">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Object key, Class&lt;T&gt; type)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 存数据</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 如果值不存在，则添加，用来替代如下代码</span><br><span class="line">	 * Object existingValue = cache.get(key);</span><br><span class="line">	 * if (existingValue == null) &#123;</span><br><span class="line">	 *     cache.put(key, value);</span><br><span class="line">	 *     return null;</span><br><span class="line">	 * &#125; else &#123;</span><br><span class="line">	 *     return existingValue;</span><br><span class="line">	 * &#125;</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function">ValueWrapper <span class="title">putIfAbsent</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 根据key删数据</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">evict</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 清空数据</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 缓存值的Wrapper  </span><br><span class="line">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">ValueWrapper</span> </span>&#123;</span><br><span class="line">		<span class="comment">/**</span><br><span class="line">		 * 得到value</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="function">Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认实现">默认实现</h4><p>默认已经实现了几个常用的cache<br>位于spring-context-x.RELEASE.jar和spring-context-support-x.RELEASE.jar的cache目录下</p>
<ul>
<li>ConcurrentMapCache：基于java.util.concurrent.ConcurrentHashMap</li>
<li>GuavaCache：基于Google的Guava工具</li>
<li>EhCacheCache：基于Ehcache</li>
<li>JCacheCache：基于javax.cache.Cache（不常用）</li>
</ul>
<h3 id="CacheManager">CacheManager</h3><p><code>用来管理多个cache</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 根据cache名获取cache</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function">Cache <span class="title">getCache</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 得到所有cache的名字</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function">Collection&lt;String&gt; <span class="title">getCacheNames</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认实现-1">默认实现</h4><p>对应Cache接口的默认实现</p>
<ul>
<li>ConcurrentMapCacheManager / ConcurrentMapCacheFactoryBean</li>
<li>GuavaCacheManager</li>
<li>EhCacheCacheManager / EhCacheManagerFactoryBean</li>
<li>JCacheCacheManager / JCacheManagerFactoryBean</li>
</ul>
<h3 id="CompositeCacheManager">CompositeCacheManager</h3><p>用于组合CacheManager，可以从多个CacheManager中轮询得到相应的Cache</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"cacheManager"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.cache.support.CompositeCacheManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cacheManagers"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">bean</span>=<span class="value">"concurrentMapCacheManager"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">bean</span>=<span class="value">"guavaCacheManager"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 都找不到时，不返回null，而是返回NOP的Cache --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"fallbackToNoOpCache"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="事务">事务</h3><p>除GuavaCacheManager外，其他Cache都支持Spring事务，如果注解方法出现事务回滚，对应缓存操作也会回滚</p>
<h3 id="缓存策略">缓存策略</h3><p>都是Cache自行维护，Spring只提供对外抽象API</p>
<h2 id="Cache注解">Cache注解</h2><p>每个注解都有多个参数，这里不一一列出，建议进入源码查看注释</p>
<h3 id="启用注解">启用注解</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">cache:annotation-driven</span> <span class="attribute">cache-manager</span>=<span class="value">"cacheManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="@CachePut">@CachePut</h3><p>写数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@CachePut</span>(value = <span class="string">"addPotentialNoticeCache"</span>, key = <span class="string">"targetClass + '.' + #userCode"</span>)</span><br><span class="line"><span class="keyword">public</span> List&lt;PublicAutoAddPotentialJob.AutoAddPotentialNotice&gt; put(<span class="keyword">int</span> userCode, List&lt;PublicAutoAddPotentialJob.AutoAddPotentialNotice&gt; noticeList) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">"缓存（&#123;&#125;）的公客自动添加潜在客的通知"</span>, userCode);</span><br><span class="line">    <span class="keyword">return</span> noticeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="@CacheEvict">@CacheEvict</h3><p>失效数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@CacheEvict</span>(value = <span class="string">"addPotentialNoticeCache"</span>, key = <span class="string">"targetClass + '.' + #userCode"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> userCode)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"清除（&#123;&#125;）的公客自动添加潜在客的通知"</span>, userCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="@Cacheable">@Cacheable</h3><p>这个用的比较多<br>用在查询方法上，先从缓存中读取，如果没有再调用方法获取数据，然后把数据添加到缓存中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@Cacheable</span>(value = <span class="string">"kyAreaCache"</span>, key=<span class="string">"targetClass + '.' + methodName + '.' + #areaId"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> KyArea <span class="title">findById</span><span class="params">(String areaId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行流程">运行流程</h3><ol>
<li>首先执行@CacheEvict（如果beforeInvocation=true且condition 通过），如果allEntries=true，则清空所有</li>
<li>接着收集@Cacheable（如果condition 通过，且key对应的数据不在缓存），放入cachePutRequests（也就是说如果cachePutRequests为空，则数据在缓存中）</li>
<li>如果cachePutRequests为空且没有@CachePut操作，那么将查找@Cacheable的缓存，否则result=缓存数据（也就是说只要当没有cache put请求时才会查找缓存）</li>
<li>如果没有找到缓存，那么调用实际的API，把结果放入result</li>
<li>如果有@CachePut操作(如果condition 通过)，那么放入cachePutRequests</li>
<li>执行cachePutRequests，将数据写入缓存（unless为空或者unless解析结果为false）；</li>
<li>执行@CacheEvict（如果beforeInvocation=false 且 condition 通过），如果allEntries=true，则清空所有</li>
</ol>
<h3 id="SpEL上下文数据">SpEL上下文数据</h3><p>在使用时，#root.methodName 等同于 methodName</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">位置</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">methodName</td>
<td style="text-align:left">root对象</td>
<td style="text-align:left">当前被调用的方法名</td>
<td style="text-align:left">#root.methodName</td>
</tr>
<tr>
<td style="text-align:left">method</td>
<td style="text-align:left">root对象</td>
<td style="text-align:left">当前被调用的方法</td>
<td style="text-align:left">#root.method.name</td>
</tr>
<tr>
<td style="text-align:left">target</td>
<td style="text-align:left">root对象</td>
<td style="text-align:left">当前被调用的目标对象</td>
<td style="text-align:left">#root.target</td>
</tr>
<tr>
<td style="text-align:left">targetClass</td>
<td style="text-align:left">root对象</td>
<td style="text-align:left">当前被调用的目标对象类</td>
<td style="text-align:left">#root.targetClass</td>
</tr>
<tr>
<td style="text-align:left">args</td>
<td style="text-align:left">root对象</td>
<td style="text-align:left">当前被调用的方法的参数列表</td>
<td style="text-align:left">#root.args[0]</td>
</tr>
<tr>
<td style="text-align:left">caches</td>
<td style="text-align:left">root对象</td>
<td style="text-align:left">当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个cache</td>
<td style="text-align:left">#root.caches[0].name</td>
</tr>
<tr>
<td style="text-align:left">argument name</td>
<td style="text-align:left">执行上下文</td>
<td style="text-align:left">当前被调用的方法的参数，如findById(Long id)，我们可以通过#id拿到参数</td>
<td style="text-align:left">#user.id</td>
</tr>
<tr>
<td style="text-align:left">result</td>
<td style="text-align:left">执行上下文</td>
<td style="text-align:left">方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache evict’的beforeInvocation=false）</td>
<td style="text-align:left">#result</td>
</tr>
</tbody>
</table>
<h3 id="条件缓存">条件缓存</h3><p>主要是在注解内用condition和unless的表达式分别对参数和返回结果进行筛选后缓存</p>
<h3 id="@Caching">@Caching</h3><p>多个缓存注解组合使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@Caching</span>(</span><br><span class="line">        put = &#123;</span><br><span class="line">                <span class="annotation">@CachePut</span>(value = <span class="string">"user"</span>, key = <span class="string">"#user.id"</span>),</span><br><span class="line">                <span class="annotation">@CachePut</span>(value = <span class="string">"user"</span>, key = <span class="string">"#user.username"</span>),</span><br><span class="line">                <span class="annotation">@CachePut</span>(value = <span class="string">"user"</span>, key = <span class="string">"#user.email"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义缓存注解">自定义缓存注解</h3><p>把一些特殊场景的注解包装到一个独立的注解中，比如@Caching组合使用的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@Caching</span>(</span><br><span class="line">        put = &#123;</span><br><span class="line">                <span class="annotation">@CachePut</span>(value = <span class="string">"user"</span>, key = <span class="string">"#user.id"</span>),</span><br><span class="line">                <span class="annotation">@CachePut</span>(value = <span class="string">"user"</span>, key = <span class="string">"#user.username"</span>),</span><br><span class="line">                <span class="annotation">@CachePut</span>(value = <span class="string">"user"</span>, key = <span class="string">"#user.email"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line"><span class="annotation">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> UserSaveCache &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@UserSaveCache</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例">示例</h2><h3 id="基于ConcurrentMapCache">基于ConcurrentMapCache</h3><h4 id="自定义CacheManager">自定义CacheManager</h4><p>我需要使用有容量限制和缓存失效时间策略的Cache，默认的ConcurrentMapCacheManager没法满足<br>通过实现CacheManager接口定制出自己的CacheManager。<br>还是拷贝ConcurrentMapCacheManager，使用Guava的Cache做底层容器，因为Guava的Cache容器可以设置缓存策略</p>
<p><code>新增了exp、maximumSize两个策略变量</code><br><code>修改底层Cache容器的创建</code></p>
<p>下面只列出自定义的代码，其他的都是Spring的ConcurrentMapCacheManager的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.concurrent.ConcurrentMapCache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 功能说明：自定义的ConcurrentMapCacheManager，新增超时时间和最大存储限制</span><br><span class="line"> * 作者：liuxing(2015-04-13 18:44)</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentMapCacheManager</span> <span class="keyword">implements</span> <span class="title">CacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 过期时间，秒（自定义）</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> exp = <span class="number">1800</span>;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 最大存储数量 （自定义）</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maximumSize = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExp</span><span class="params">(<span class="keyword">long</span> exp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exp = exp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaximumSize</span><span class="params">(<span class="keyword">long</span> maximumSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maximumSize = maximumSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 创建一个缓存容器，这个方法改写为使用Guava的Cache</span><br><span class="line">     * <span class="doctag">@param</span> name</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Cache <span class="title">createConcurrentMapCache</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentMapCache(name, CacheBuilder.newBuilder().expireAfterWrite(<span class="keyword">this</span>.exp, TimeUnit.SECONDS)</span><br><span class="line">                                                                     .maximumSize(<span class="keyword">this</span>.maximumSize)</span><br><span class="line">                                                                     .build()</span><br><span class="line">                                                                     .asMap(), isAllowNullValues());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化">初始化</h4><p>xml风格</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 启用缓存注解功能，这个是必须的，否则注解不会生效，指定一个默认的Manager，否则需要在注解使用时指定Manager --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">cache:annotation-driven</span> <span class="attribute">cache-manager</span>=<span class="value">"memoryCacheManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 本地内存缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"memoryCacheManager"</span> <span class="attribute">class</span>=<span class="value">"com.dooioo.ky.cache.ConcurrentMapCacheManager"</span> <span class="attribute">p:maximumSize</span>=<span class="value">"2000"</span> <span class="attribute">p:exp</span>=<span class="value">"1800"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cacheNames"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>kyMemoryCache<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="使用">使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@Cacheable</span>(value = <span class="string">"kyMemoryCache"</span>, key=<span class="string">"targetClass + '.' + methodName"</span>)</span><br><span class="line"><span class="keyword">public</span> Map&lt;String, String&gt; queryMobiles()&#123;</span><br><span class="line">    <span class="comment">// 业务代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Memcached">使用Memcached</h3><p>一般常用的缓存当属memcached了，这个就需要自己实现CacheManager和Cache<br>注意我实现的Cache里面有做一些定制化操作，比如对key的处理</p>
<h4 id="创建MemcachedCache">创建MemcachedCache</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.dooioo.common.jstl.DyFunctions;</span><br><span class="line"><span class="keyword">import</span> com.dooioo.commons.Strings;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Joiner;</span><br><span class="line"><span class="keyword">import</span> net.rubyeye.xmemcached.MemcachedClient;</span><br><span class="line"><span class="keyword">import</span> net.rubyeye.xmemcached.exception.MemcachedException;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.support.SimpleValueWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 功能说明：自定义spring的cache的实现，参考cache包实现</span><br><span class="line"> * 作者：liuxing(2015-04-12 13:57)</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemcachedCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MemcachedCache.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 缓存的别名</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * memcached客户端</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> MemcachedClient client;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 缓存过期时间，默认是1小时</span><br><span class="line">     * 自定义的属性</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> exp = <span class="number">3600</span>;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 是否对key进行base64加密</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> base64Key = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 前缀名</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNativeCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ValueWrapper <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object = <span class="keyword">this</span>.client.get(handleKey(objectToString(key)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MemcachedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (object != <span class="keyword">null</span> ? <span class="keyword">new</span> SimpleValueWrapper(object) : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Object key, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object object = <span class="keyword">this</span>.client.get(handleKey(objectToString(key)));</span><br><span class="line">            <span class="keyword">return</span> (T) object;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MemcachedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//            this.evict(key);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.set(handleKey(objectToString(key)), exp, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MemcachedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ValueWrapper <span class="title">putIfAbsent</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.delete(handleKey(objectToString(key)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MemcachedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.flushAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MemcachedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MemcachedClient <span class="title">getClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClient</span><span class="params">(MemcachedClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExp</span><span class="params">(<span class="keyword">int</span> exp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exp = exp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBase64Key</span><span class="params">(<span class="keyword">boolean</span> base64Key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.base64Key = base64Key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 处理key</span><br><span class="line">     * <span class="doctag">@param</span> key</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">handleKey</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (base64Key) &#123;</span><br><span class="line">            <span class="keyword">return</span> Joiner.on(EMPTY_SEPARATOR).skipNulls().join(<span class="keyword">this</span>.prefix, DyFunctions.base64Encode(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Joiner.on(EMPTY_SEPARATOR).skipNulls().join(<span class="keyword">this</span>.prefix, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 转换key，去掉空格</span><br><span class="line">     * <span class="doctag">@param</span> object</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">objectToString</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> Strings.replace((String) object, <span class="string">" "</span>, <span class="string">"_"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> object.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EMPTY_SEPARATOR = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建MemcachedCacheManager">创建MemcachedCacheManager</h4><p>继承AbstractCacheManager</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.support.AbstractCacheManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 功能说明：memcachedCacheManager</span><br><span class="line"> * 作者：liuxing(2015-04-12 15:13)</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemcachedCacheManager</span> <span class="keyword">extends</span> <span class="title">AbstractCacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;Cache&gt; caches;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Collection&lt;? extends Cache&gt; loadCaches() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.caches;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCaches</span><span class="params">(Collection&lt;Cache&gt; caches)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.caches = caches;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cache <span class="title">getCache</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getCache(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化-1">初始化</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 启用缓存注解功能，这个是必须的，否则注解不会生效，指定一个默认的Manager，否则需要在注解使用时指定Manager --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">cache:annotation-driven</span> <span class="attribute">cache-manager</span>=<span class="value">"cacheManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- memcached缓存管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"cacheManager"</span> <span class="attribute">class</span>=<span class="value">"com.dooioo.ky.cache.MemcachedCacheManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"caches"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.dooioo.ky.cache.MemcachedCache"</span> <span class="attribute">p:client-ref</span>=<span class="value">"ky.memcachedClient"</span> <span class="attribute">p:name</span>=<span class="value">"kyAreaCache"</span> <span class="attribute">p:exp</span>=<span class="value">"86400"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.dooioo.ky.cache.MemcachedCache"</span> <span class="attribute">p:client-ref</span>=<span class="value">"ky.memcachedClient"</span> <span class="attribute">p:name</span>=<span class="value">"kyOrganizationCache"</span> <span class="attribute">p:exp</span>=<span class="value">"3600"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="使用-1">使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@Cacheable</span>(value = <span class="string">"kyAreaCache"</span>, key=<span class="string">"targetClass + '.' + methodName + '.' + #areaId"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> KyArea <span class="title">findById</span><span class="params">(String areaId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更多">更多</h2><p>更多复杂的使用场景和注解语法请自行谷歌！</p>
<p><strong>参考</strong><br><a href="http://docs.spring.io/spring/docs/4.1.x/spring-framework-reference/html/cache.html" target="_blank" rel="external">http://docs.spring.io/spring/docs/4.1.x/spring-framework-reference/html/cache.html</a></p>
<p><a href="http://www.cnblogs.com/rollenholt/p/4202631.html" target="_blank" rel="external">http://www.cnblogs.com/rollenholt/p/4202631.html</a></p>
<p><a href="http://jinnianshilongnian.iteye.com/blog/2001040" target="_blank" rel="external">http://jinnianshilongnian.iteye.com/blog/2001040</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>记录下自己项目在用的Spring Cache的使用方式。</em><br><em>Spring的抽象已经做得够好了，适合于大多数场景，非常复杂的就需要自己AOP实现了。</em><br><em>Spring官网的文档挺不错的，但是对Cache这块的介绍不是很详细，结]]>
    </summary>
    
      <category term="Cache" scheme="http://liuxing.info/tags/Cache/"/>
    
      <category term="Spring" scheme="http://liuxing.info/tags/Spring/"/>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux统计内存块]]></title>
    <link href="http://liuxing.info/2015/06/17/linux%E7%BB%9F%E8%AE%A1%E5%86%85%E5%AD%98%E5%9D%97/"/>
    <id>http://liuxing.info/2015/06/17/linux统计内存块/</id>
    <published>2015-06-16T17:02:00.000Z</published>
    <updated>2015-06-16T17:05:07.000Z</updated>
    <content type="html"><![CDATA[<p><em>纯粹备忘</em></p>
<h2 id="统计内存块">统计内存块</h2><p>pmap -x $pid | awk ‘{ if($3 &gt; 64000 &amp;&amp; $3 &lt; 65537) count++ } END { print count }’</p>
<h2 id="导出内存块明细">导出内存块明细</h2><p>pmap -x $pid &gt; pmap.log</p>
<h2 id="导出核心进程内存">导出核心进程内存</h2><p>sudo gdb -q —pid=4990</p>
<p>—pid后面跟着的是jvm的进程id<br>(gdb) generate-core-file </p>
<p>这里调用命令生成gcore的dump文件<br>(gdb) detach </p>
<p>detach是用来断开与jvm的连接的<br>(gdb) quit</p>
<p>指定内存块：<br>内存地址从pmap结果中查询<br> dump memory memory.bin 0x0007f5f38000000 0x0007f5f394af000</p>
<p>导出核心进程内存（正式库数据太大不建议）<br>gdb —pid $pid<br>gcore   [文件名]    #   产生core dump文件</p>
<p><a href="http://blog.chinaunix.net/uid-24020646-id-2419921.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-24020646-id-2419921.html</a></p>
<h2 id="核心进程内存转换为heap_dump">核心进程内存转换为heap dump</h2><p>$JAVA_HOME/bin/jmap -dump:format=b,file=heap.hprof $JAVA_HOME/bin/java core.63278<br>/usr/java/jdk1.8.0_40/bin/jmap -dump:format=b,file=heap.hprof /usr/java/jdk1.8.0_40/bin/java memory.bin<br>/usr/local/java/jdk1.8.0_20/bin/jmap -dump:format=b,file=heap.hprof /usr/local/java/jdk1.8.0_20/bin/java memory.bin<br><a href="http://itindex.net/detail/50907-jmap-gcore-dump" target="_blank" rel="external">http://itindex.net/detail/50907-jmap-gcore-dump</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-memoryanalyzer/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-memoryanalyzer/</a></p>
<h2 id="导入本地使用MAT工具分析">导入本地使用MAT工具分析</h2><h2 id="使用libtcmalloc优化linux内存管理">使用libtcmalloc优化linux内存管理</h2><p>gperftools+libunwind</p>
<h2 id="查找文件">查找文件</h2><p>find / -name “libunwind*” </p>
<p>jhat -J-Xmx1024M heap.hprof </p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>纯粹备忘</em></p>
<h2 id="统计内存块">统计内存块</h2><p>pmap -x $pid | awk ‘{ if($3 &gt; 64000 &amp;&amp; $3 &lt; 65537) count++ } END { print coun]]>
    </summary>
    
      <category term="Java" scheme="http://liuxing.info/tags/Java/"/>
    
      <category term="linux" scheme="http://liuxing.info/tags/linux/"/>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tomcat的APR优化]]></title>
    <link href="http://liuxing.info/2015/06/17/Tomcat%E7%9A%84APR%E4%BC%98%E5%8C%96/"/>
    <id>http://liuxing.info/2015/06/17/Tomcat的APR优化/</id>
    <published>2015-06-16T16:53:00.000Z</published>
    <updated>2015-06-16T17:14:45.000Z</updated>
    <content type="html"><![CDATA[<p><em>什么是APR？</em></p>
<blockquote><p>Tomcat可以使用APR来提供超强的可伸缩性和性能，更好地集成本地服务器技术。</p>
<p>APR(Apache Portable Runtime)是一个高可移植库，它是Apache HTTP Server 2.x的核心。</p>
<p>APR有很多用途，包括访问高级IO功能(例如sendfile,epoll和OpenSSL)，OS级别功能(随机数生成，系统状态等等)，本地进程管理(共享内存，NT管道和UNIX sockets)。这些功能可以使Tomcat作为一个通常的前台WEB服务器，能更好地和其它本地web技术集成，总体上让Java更有效率作为一个高性能web服务器平台而不是简单作为后台容器。</p>
<p>在产品环境中，特别是直接使用Tomcat做WEB服务器的时候，应该使用Tomcat Native来提高其性能。</p>
<footer><strong>Apache Portable Runtime</strong><cite><a href="http://apr.apache.org/" target="_blank" rel="external">Welcome! - The Apache Portable Runtime Project</a></cite></footer></blockquote>
<h2 id="安装apr">安装apr</h2><p>yum install -y apr-devel openssl-devel gcc</p>
<p>查看安装目录<br>rpm -ql apr-devel<br>rpm -ql openssl-devel</p>
<p>apr目录：/usr/bin/apr-1-config</p>
<h2 id="安装native">安装native</h2><p>拷贝：tomcat/bin目录下的tomcat-native.tar.gz到某个位置<br>解压：tar zxvf tomcat-native.tar.gz</p>
<pre><code>cd  tomcat-<span class="reserved">native</span>-<span class="number">1.1</span>.32-src<span class="regexp">/jni/native/</span>
./configure --<span class="reserved">with</span>-apr=/usr/bin/apr-<span class="number">1</span>-config --<span class="reserved">with</span>-java-home=$JAVA_HOME 
.<span class="regexp">/configure --with-apr=/usr/local/apache2/</span> --<span class="reserved">with</span>-java-home=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home --<span class="reserved">with</span>-ssl=<span class="literal">yes</span>
</code></pre><p>可选：</p>
<pre><code>--<span class="reserved">with</span>-ssl=<span class="literal">yes</span>
make &amp; make install
</code></pre><h2 id="配置tomcat">配置tomcat</h2><pre><code>vim catalina.sh
export <span class="constant">LD_LIBRARY_PATH=</span><span class="variable">$LD_LIBRARY_PATH</span><span class="symbol">:/usr/local/apr/lib</span>
</code></pre><p>将tomcat/config/service.xml 的protocol 改为</p>
<pre><code>org<span class="class">.apache</span><span class="class">.coyote</span><span class="class">.http11</span><span class="class">.Http11AprProtocol</span>
</code></pre><h2 id="重启查看日志">重启查看日志</h2><h2 id="参考">参考</h2><p><a href="http://www.cnblogs.com/kgdxpr/archive/2013/08/07/3243657.html" target="_blank" rel="external">http://www.cnblogs.com/kgdxpr/archive/2013/08/07/3243657.html</a></p>
<p><a href="http://blog.csdn.net/qingchn/article/details/7895851" target="_blank" rel="external">http://blog.csdn.net/qingchn/article/details/7895851</a></p>
<p><a href="http://tomcat.apache.org/native-doc/" target="_blank" rel="external">http://tomcat.apache.org/native-doc/</a></p>
<p><a href="http://neptune.iteye.com/blog/125101" target="_blank" rel="external">http://neptune.iteye.com/blog/125101</a></p>
<p><a href="http://www.cnblogs.com/chuncn/archive/2010/10/17/1853915.html" target="_blank" rel="external">http://www.cnblogs.com/chuncn/archive/2010/10/17/1853915.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>什么是APR？</em></p>
<blockquote><p>Tomcat可以使用APR来提供超强的可伸缩性和性能，更好地集成本地服务器技术。</p>
<p>APR(Apache Portable Runtime)是一个高可移植库，它是Apache HTTP Se]]>
    </summary>
    
      <category term="APR" scheme="http://liuxing.info/tags/APR/"/>
    
      <category term="tomcat" scheme="http://liuxing.info/tags/tomcat/"/>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用google-perftools优化tomcat]]></title>
    <link href="http://liuxing.info/2015/06/17/%E4%BD%BF%E7%94%A8google-perftools%E4%BC%98%E5%8C%96tomcat/"/>
    <id>http://liuxing.info/2015/06/17/使用google-perftools优化tomcat/</id>
    <published>2015-06-16T16:41:00.000Z</published>
    <updated>2015-06-16T16:53:15.000Z</updated>
    <content type="html"><![CDATA[<blockquote><p>这个工具可让开发创建更强大的应用程序，特别是那些用C++模版开发的多线程应用程序，包括<a href="http://www.oschina.net/p/tcmalloc" target="_blank" rel="external">TCMalloc</a>, heap-checker, heap-profiler 和cpu-profiler。</p>
<footer><strong>开源中国社区</strong><cite><a href="http://www.oschina.net/p/perftools" target="_blank" rel="external">Google PerfTools首页、文档和下载</a></cite></footer></blockquote>
<h2 id="前置依赖">前置依赖</h2><p>避免后续安装错误</p>
<pre><code>yum install -y gcc<span class="keyword">*</span>
yum install zlib<span class="keyword">*</span> openssl<span class="keyword">*</span> -y   
</code></pre><h2 id="安装">安装</h2><p>切换到工作目录</p>
<pre><code><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src 或 ~/src
</code></pre><p>下载：</p>
<pre><code>wget <span class="symbol">http:</span>/<span class="regexp">/download.savannah.gnu.org/releases</span><span class="regexp">/libunwind/libunwind</span>-<span class="number">0</span>.<span class="number">99</span>-alpha.tar.gz
wget <span class="symbol">http:</span>/<span class="regexp">/googledrive.com/host</span><span class="regexp">/0B6NtGsLhIcf7MWxMMF9JdTN3UVk/gperftools</span>-<span class="number">2.4</span>.tar.gz
</code></pre><p>1.针对 64 位操作系统必须安装 libunwind 库</p>
<pre><code>tar zxvf libunwind-<span class="number">1.1</span>.tar.gz
<span class="built_in">cd</span> libunwind-<span class="number">1.1</span>/
CFLAGS=<span class="operator">-f</span>PIC ./configure --enable-shared --enable-frame-pointers
make CFLAGS=<span class="operator">-f</span>PIC
make CFLAGS=<span class="operator">-f</span>PIC install
<span class="built_in">cd</span> ../
</code></pre><p>查找：</p>
<pre><code><span class="keyword">find</span> <span class="regexp">/usr/</span> -name “libunwind*”
</code></pre><p>卸载：</p>
<pre><code>make CFLAGS=<span class="operator">-f</span>PIC uninstall
</code></pre><p>2.安装 google-perftools 优化</p>
<pre><code>tar zxvf gperftools-<span class="number">2.0</span><span class="class">.tar</span><span class="class">.gz</span>
cd gperftools-<span class="number">2.0</span>/
./configure --enable-shared --enable-frame-pointers
make &amp;&amp; make install
echo <span class="string">"/usr/local/lib"</span> &gt; /etc/ld<span class="class">.so</span><span class="class">.conf</span><span class="class">.d</span>/usr_local_lib<span class="class">.conf</span>
/sbin/ldconfig
</code></pre><p><code>有依赖没有安装?</code></p>
<pre><code>./configure --<span class="literal">enable</span>-<span class="literal">shared</span> --<span class="literal">enable</span>-frame-pointers  
</code></pre><p><code>make check 依然报错？</code></p>
<p><a href="http://xkorey.iteye.com/blog/1648567" target="_blank" rel="external">http://xkorey.iteye.com/blog/1648567</a></p>
<p><code>./libtool: line 1125: g++: command not found</code></p>
<pre><code>yum <span class="keyword">install</span> -y gcc* 
</code></pre><p>tomcat启动程序配置</p>
<pre><code><span class="built_in">export</span> LD_PRELOAD=/usr/<span class="built_in">local</span>/lib/libtcmalloc.so
</code></pre><p>查看是否生效</p>
<pre><code>/usr/sbin/lsof -n <span class="string">| grep tcmalloc</span>
</code></pre><h2 id="参考">参考</h2><h3 id="示例">示例</h3><p><a href="https://www.centos.bz/2012/01/google-perftools-speed-up-mysql-tcmalloc/" target="_blank" rel="external">https://www.centos.bz/2012/01/google-perftools-speed-up-mysql-tcmalloc/</a><br><a href="http://blog.sina.com.cn/s/blog_8d05143b01012b87.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_8d05143b01012b87.html</a><br><a href="http://xkorey.iteye.com/blog/1648567" target="_blank" rel="external">http://xkorey.iteye.com/blog/1648567</a><br><a href="http://shopwwi.com/thread-673-1-1.html" target="_blank" rel="external">http://shopwwi.com/thread-673-1-1.html</a><br><a href="http://blog.csdn.net/wind19/article/details/10381291" target="_blank" rel="external">http://blog.csdn.net/wind19/article/details/10381291</a></p>
<p><a href="http://blog.chinaunix.net/uid-20687780-id-3029851.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20687780-id-3029851.html</a><br><a href="http://blog.hackroad.com/operations-engineer/linux_server/1285.html" target="_blank" rel="external">http://blog.hackroad.com/operations-engineer/linux_server/1285.html</a></p>
<h3 id="linux安装软件">linux安装软件</h3><p><a href="http://www.cnblogs.com/chuncn/archive/2010/10/17/1853915.html" target="_blank" rel="external">http://www.cnblogs.com/chuncn/archive/2010/10/17/1853915.html</a></p>
<p><a href="http://www.educity.cn/wenda/353955.html" target="_blank" rel="external">http://www.educity.cn/wenda/353955.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote><p>这个工具可让开发创建更强大的应用程序，特别是那些用C++模版开发的多线程应用程序，包括<a href="http://www.oschina.net/p/tcmalloc" target="_blank" rel="external">TCMallo]]>
    </summary>
    
      <category term="linux" scheme="http://liuxing.info/tags/linux/"/>
    
      <category term="perftools" scheme="http://liuxing.info/tags/perftools/"/>
    
      <category term="tomcat" scheme="http://liuxing.info/tags/tomcat/"/>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MemAdmin管理Memcached]]></title>
    <link href="http://liuxing.info/2015/06/17/MemAdmin%E7%AE%A1%E7%90%86Memcached/"/>
    <id>http://liuxing.info/2015/06/17/MemAdmin管理Memcached/</id>
    <published>2015-06-16T16:24:00.000Z</published>
    <updated>2015-06-16T16:42:34.000Z</updated>
    <content type="html"><![CDATA[<p><em>MemAdmin是一款可视化的Memcached管理与监控工具，基于 PHP5 &amp; JQuery 开发，体积小，操作简单。</em></p>
<blockquote><p>主要功能：</p>
<ul>
<li>服务器参数监控：STATS、SETTINGS、ITEMS、SLABS、SIZES实时刷新</li>
<li>服务器性能监控：GET、DELETE、INCR、DECR、CAS等常用操作命中率实时监控</li>
<li>支持数据遍历，方便对存储内容进行监视</li>
<li>支持条件查询，筛选出满足条件的KEY或VALUE</li>
<li>数组、JSON等序列化字符反序列显示</li>
<li>兼容memcache协议的其他服务，如Tokyo Tyrant (遍历功能除外)</li>
<li>支持服务器连接池，多服务器管理切换方便简洁</li>
</ul>
<footer><strong>开源中国社区</strong><cite><a href="http://www.oschina.net/p/memadmin" target="_blank" rel="external">MemAdmin首页、文档和下载</a></cite></footer></blockquote>
<h2 id="查看依赖">查看依赖</h2><h3 id="查看Apache版本">查看Apache版本</h3><pre><code><span class="title">apachectl</span> -v
</code></pre><h3 id="查看PHP环境">查看PHP环境</h3><pre><code><span class="title">php</span> -v
</code></pre><p><a href="http://nan1hao.blog.51cto.com/753570/602610/" target="_blank" rel="external">http://nan1hao.blog.51cto.com/753570/602610/</a></p>
<h2 id="安装Apache和PHP（如果没有的话）">安装Apache和PHP（如果没有的话）</h2><p><a href="http://blog.csdn.net/czp11210/article/details/8750506" target="_blank" rel="external">http://blog.csdn.net/czp11210/article/details/8750506</a></p>
<h2 id="安装PHP的memcached扩展">安装PHP的memcached扩展</h2><pre><code><span class="tag">RPM</span> –<span class="tag">ivh</span> <span class="tag">php-pear-1</span><span class="class">.9</span><span class="class">.4-4</span><span class="class">.el6</span><span class="class">.noarch</span><span class="class">.rpm</span> 

<span class="tag">RPM</span> –<span class="tag">ivh</span> <span class="tag">php-pecl-memcache-3</span><span class="class">.0</span><span class="class">.5-4</span><span class="class">.el6</span><span class="class">.x86_64</span><span class="class">.rpm</span>
</code></pre><p>或 <code>yum install</code> 安装</p>
<h2 id="修改配置">修改配置</h2><p>追加内容</p>
<pre><code>echo <span class="string">"abcd"</span> &gt;&gt; <span class="tag">a</span><span class="class">.txt</span> #命令示例
</code></pre><p>重启Apache </p>
<pre><code><span class="keyword">service</span> httpd <span class="literal">restart</span>
</code></pre><p>找不到服务？<a href="http://blog.csdn.net/zwfcan/article/details/8231864" target="_blank" rel="external">http://blog.csdn.net/zwfcan/article/details/8231864</a></p>
<p>搜索Apache目录</p>
<pre><code><span class="keyword">find</span> / -name httpd.<span class="keyword">conf</span>
</code></pre><h2 id="安装memadmin">安装memadmin</h2><pre><code>tar –zxvf memadmin-<span class="number">1.0</span>.<span class="number">12</span><span class="class">.tar</span><span class="class">.gz</span>
mv memadmin  /var/www/<span class="tag">html</span>

vi /etc/httpd/conf/httpd.conf
</code></pre><p>1.DocumentRoot “/var/www/html”<br>2.DirectoryIndex index.html index.html.var index.php<br>3.&lt;Directory “/var/www/html”&gt; …</p>
<p><em>很久没用了，还有些使用截图需要补上，待续…</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>MemAdmin是一款可视化的Memcached管理与监控工具，基于 PHP5 &amp; JQuery 开发，体积小，操作简单。</em></p>
<blockquote><p>主要功能：</p>
<ul>
<li>服务器参数监控：STATS、SETTINGS、I]]>
    </summary>
    
      <category term="MemAdmin" scheme="http://liuxing.info/tags/MemAdmin/"/>
    
      <category term="Memcached" scheme="http://liuxing.info/tags/Memcached/"/>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux安装jdk]]></title>
    <link href="http://liuxing.info/2015/06/17/linux%E5%AE%89%E8%A3%85jdk/"/>
    <id>http://liuxing.info/2015/06/17/linux安装jdk/</id>
    <published>2015-06-16T16:17:00.000Z</published>
    <updated>2015-06-16T16:23:10.000Z</updated>
    <content type="html"><![CDATA[<p><em>记录一下</em></p>
<h2 id="安装">安装</h2><pre><code><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/java/ 
</code></pre><p>或</p>
<pre><code>cd /usr/java/

tar -zxvf 文件名<span class="class">.tar</span><span class="class">.gz</span>
</code></pre><p>可以修改文件夹读写、所有者、所属组<br><a href="http://www.tuicool.com/articles/b6bimiz" target="_blank" rel="external">http://www.tuicool.com/articles/b6bimiz</a></p>
<h2 id="环境变量配置">环境变量配置</h2><p>全局方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.<span class="number">8.0</span>_40</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JRE_HOME</span>/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile <span class="comment">#使更改的配置立即生效</span></span><br></pre></td></tr></table></figure>
<p>用户环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/java/jdk1.<span class="number">8.0</span>_40</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile <span class="comment">#使更改的配置生效</span></span><br><span class="line"></span><br><span class="line">java -version <span class="comment">#查看版本</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><em>记录一下</em></p>
<h2 id="安装">安装</h2><pre><code><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/java/ 
</code><]]>
    </summary>
    
      <category term="jdk" scheme="http://liuxing.info/tags/jdk/"/>
    
      <category term="linux" scheme="http://liuxing.info/tags/linux/"/>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[wget下载jdk]]></title>
    <link href="http://liuxing.info/2015/06/17/wget%E4%B8%8B%E8%BD%BDjdk/"/>
    <id>http://liuxing.info/2015/06/17/wget下载jdk/</id>
    <published>2015-06-16T16:02:00.000Z</published>
    <updated>2015-06-16T16:15:15.000Z</updated>
    <content type="html"><![CDATA[<p><em>通常需要下载jdk时，直接用wget命令是不行的。那么，如何解决呢？</em><br><em>只需要在wget的时候加上一个特殊的cookie就可以搞定</em></p>
<p><strong>JDK 7</strong></p>
<pre><code>wget --<span class="keyword">no</span>-cookies --<span class="keyword">no</span>-check-certificate --header <span class="string">"Cookie:gpw_e24=http<span class="variable">%3a</span><span class="variable">%2f</span><span class="variable">%2fwww</span>.oracle.com<span class="variable">%2ftechnetwork</span><span class="variable">%2fjava</span><span class="variable">%2fjavase</span><span class="variable">%2fdownloads</span><span class="variable">%2fjdk7</span>-downloads-1880260.html;oraclelicense=accept-securebackup-cookie"</span> http:<span class="regexp">//download</span>.oracle.com/otn-pub/java/jdk/<span class="number">7</span>u75-b13/jdk-<span class="number">7</span>u75-linux-x64.tar.gz
</code></pre><p><strong>JDK 8</strong></p>
<pre><code>wget --<span class="keyword">no</span>-cookies --<span class="keyword">no</span>-check-certificate --header <span class="string">"Cookie:gpw_e24=http<span class="variable">%3a</span><span class="variable">%2f</span><span class="variable">%2fwww</span>.oracle.com<span class="variable">%2ftechnetwork</span><span class="variable">%2fjava</span><span class="variable">%2fjavase</span><span class="variable">%2fdownloads</span><span class="variable">%2fjdk8</span>-downloads-2133151.html;oraclelicense=accept-securebackup-cookie"</span> http:<span class="regexp">//download</span>.oracle.com/otn-pub/java/jdk/<span class="number">8</span>u4<span class="number">0</span>-b26/jdk-<span class="number">8</span>u4<span class="number">0</span>-linux-x64.tar.gz
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><em>通常需要下载jdk时，直接用wget命令是不行的。那么，如何解决呢？</em><br><em>只需要在wget的时候加上一个特殊的cookie就可以搞定</em></p>
<p><strong>JDK 7</strong></p>
<pre><code>wget -]]>
    </summary>
    
      <category term="linux" scheme="http://liuxing.info/tags/linux/"/>
    
      <category term="wget" scheme="http://liuxing.info/tags/wget/"/>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux命令备忘]]></title>
    <link href="http://liuxing.info/2015/06/16/linux%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/"/>
    <id>http://liuxing.info/2015/06/16/linux命令备忘/</id>
    <published>2015-06-16T15:58:00.000Z</published>
    <updated>2015-06-16T17:09:16.000Z</updated>
    <content type="html"><![CDATA[<p><em>记录一下自己常用的linux命令</em></p>
<p>独立用户需要配置path,切换到根目录查看path</p>
<pre><code><span class="tag">vi</span> <span class="class">.bash_profile</span>
</code></pre><p>重新给文件夹赋权限</p>
<pre><code><span class="tag">chown</span> <span class="tag">-R</span> <span class="tag">yishou</span> <span class="tag">apache-tomcat-7</span><span class="class">.0</span><span class="class">.47</span>
</code></pre><p>修改密码</p>
<pre><code><span class="title">passwd</span> yishou
</code></pre><p>新增用户，会自动创建同名文件夹</p>
<pre><code><span class="title">useradd</span> loupan
</code></pre><p>删除用户</p>
<pre><code><span class="title">userdel</span> keybox
</code></pre><p>创建文件夹</p>
<pre><code><span class="built_in">mkdir</span> yishou
</code></pre><p>防止环境配置修改之后不立即生效，退出重新登录也可以</p>
<pre><code><span class="built_in">source</span> .bash_profile
</code></pre><p>根据名字查找进程</p>
<pre><code><span class="keyword">ps</span> -aux | <span class="keyword">grep</span> estat
</code></pre><p>关闭防火墙<br>    /etc/init.d/iptables stop</p>
<p>关闭开机启动</p>
<pre><code><span class="title">chkconfig</span> --level <span class="number">2345</span> iptables <span class="built_in">off</span>
</code></pre><p>赋权限</p>
<pre><code><span class="title">chmod</span> <span class="number">777</span> origimagesdisk
</code></pre><p>MAC修改hosts</p>
<pre><code>sudo vi <span class="regexp">/etc/</span>hosts
</code></pre><p>查看文件夹使用情况</p>
<pre><code>du --<span class="built_in">max</span>-<span class="built_in">depth</span>=<span class="number">1</span> -h
</code></pre><p>linux新建tomcat无法启动<br><code>Cannot find bin/catalina.sh</code><br><em>The file is absent or does not have execute permission</em><br><em>This file is needed to run this program</em></p>
<p>原因： 没有权限<br>解决 ： chmod 777 *.sh </p>
<p>添加开机启动</p>
<pre><code>vi /etc/rc.<span class="keyword">local</span>
</code></pre><p>jvisualvm</p>
<p>修改mac最大连接数，默认128</p>
<pre><code>sudo sysctl -w kern<span class="class">.ipc</span><span class="class">.somaxconn</span>=
</code></pre><p>linux ssh互信</p>
<pre><code>ssh-keygen -t rsa
cd ~/<span class="class">.ssh</span> 
scp -r id_rsa<span class="class">.pub</span> keyuan@<span class="number">192.168</span>.<span class="number">3.51</span>:/home/keyuan/.ssh/authorized_keys
</code></pre><p>配置java环境变量</p>
<pre><code>export JAVA_HOME=/usr/local/java/jdk1.<span class="number">8.0</span>_40
export JRE_HOME=<span class="variable">$JAVA_HOME</span>
export CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/<span class="tag">dt</span><span class="class">.jar</span>:<span class="variable">$JAVA_HOME</span>/lib/tools<span class="class">.jar</span>
export PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><em>记录一下自己常用的linux命令</em></p>
<p>独立用户需要配置path,切换到根目录查看path</p>
<pre><code><span class="tag">vi</span> <span class="class">.bash_profile</]]>
    </summary>
    
      <category term="linux" scheme="http://liuxing.info/tags/linux/"/>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GitHub博客搭建]]></title>
    <link href="http://liuxing.info/2015/06/14/GitHub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://liuxing.info/2015/06/14/GitHub博客搭建/</id>
    <published>2015-06-13T18:52:00.000Z</published>
    <updated>2015-06-16T13:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><em>GitHub带你装逼带你飞！你值得拥有！</em></p>
<hr>
<h2 id="介绍">介绍</h2><p><em><a href="https://github.com/" target="_blank" rel="external">GitHub</a>很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。</em><br><em>GitHub作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如<a href="https://github.com/jquery/jquery" target="_blank" rel="external">jQuery</a>、<a href="https://github.com/twitter/bootstrap" target="_blank" rel="external">Twitter</a>等。</em><br><em>为使项目更方便的被人理解，介绍页面少不了，甚至会需要完整的文档站，GitHub替你想到了这一点，他提供了<a href="http://pages.github.com" target="_blank" rel="external">GitHub Pages</a>的服务，不仅可以方便的为项目建立介绍站点，也可以用来建立个人博客。</em></p>
<p>GitHub Pages有以下几个优点</p>
<ul>
<li><em>轻量级的博客系统，没有麻烦的配置</em></li>
<li><em>使用标记语言，比如 <a href="http://markdown.tw" target="_blank" rel="external">Markdown</a></em></li>
<li><em>无需自己搭建服务器</em></li>
<li><em>根据GitHub的限制，对应的每个站有300MB空间</em></li>
<li><em>可以绑定自己的域名</em></li>
</ul>
<p>当然他也有缺点</p>
<ul>
<li><em>使用<a href="https://github.com/jekyll/jekyll" target="_blank" rel="external">Jekyll</a>模板系统，相当于静态页发布，适合博客，文档介绍等。</em></li>
<li><em>动态程序的部分相当局限，比如没有评论，不过还好我们有解决方案。</em></li>
<li><em>基于Git，很多东西需要动手，不像Wordpress有强大的后台。</em></li>
</ul>
<p>大致介绍到此，作为个人博客来说，简洁清爽的表达自己的工作、心得，就已达目标，所以Github Pages是我认为此需求最完美的解决方案了。</p>
<h2 id="GitHub配置">GitHub配置</h2><h3 id="注册账号">注册账号</h3><p>传送口：<a href="https://github.com/join" target="_blank" rel="external">https://github.com/join</a> ，自行搞定，否则放弃吧…</p>
<p><strong>PS</strong>：<em><code>不要取奇怪的用户名，比如大小写混合，建议小写字母+数字组合，否则pages会碰到问题！</code></em></p>
<h3 id="配置Pages">配置Pages</h3><p><strong>新增仓库</strong>：<a href="https://github.com/new" target="_blank" rel="external">https://github.com/new</a></p>
<ul>
<li>Repository name：github账号.github.io</li>
<li>Description：随便输入点描述</li>
<li>public</li>
<li>Initialize this repository with a README</li>
<li>.gitignore 选择初始的文件忽略，我选的java</li>
<li>Licenses：我选的NPL（GNU General Public License v2.0）</li>
</ul>
<p><strong>配置</strong></p>
<ul>
<li>选择右侧操作区的<code>settings</code></li>
<li>选择<code>Launch automatic page generator</code></li>
<li>输入一些基本说明，非必要</li>
<li>选择<code>Load README.md</code></li>
<li>继续<code>Continue to layouts</code></li>
<li>选择模板（随便选个）</li>
<li>发布<code>Publish page</code></li>
<li>此时进入<code>settings</code>应该会有<code>Your site is published at http://username.github.io</code>的条提示，访问一下，神奇吧！</li>
<li>如果404，请检查你的仓库名或账号名，删除仓库重来，删除也是在<code>settings</code>最底部</li>
</ul>
<h2 id="绑定独立域名">绑定独立域名</h2><h3 id="购买域名">购买域名</h3><p>不绑定独立域名则可以直接跳到 <strong>使用hexo</strong></p>
<p>传送门：<a href="https://www.godaddy.com" target="_blank" rel="external">https://www.godaddy.com</a> 支持支付宝<br>域名的购买不用多讲，注册、选域名、支付，有网购经验的都毫无压力。<br>记得先找优惠券：<a href="http://www.dute.me" target="_blank" rel="external">http://www.dute.me</a></p>
<p>推荐几个翻译插件<br><a href="https://chrome.google.com/webstore/detail/%E5%A4%9A%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg" target="_blank" rel="external">多词典划译</a><br><a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb" target="_blank" rel="external">Google翻译</a></p>
<p>没有VPN？<br>注册红杏：<a href="http://honx.in/_U9m44oIaA3c2nFTX" target="_blank" rel="external">http://honx.in/_U9m44oIaA3c2nFTX</a><br>公益红杏：<a href="http://help.honx.in/posts/view/32854" target="_blank" rel="external">http://help.honx.in/posts/view/32854</a> </p>
<h3 id="DNS解析">DNS解析</h3><p>传送门：<a href="https://www.dnspod.cn/" target="_blank" rel="external">https://www.dnspod.cn/</a></p>
<ul>
<li>首先添加域名记录，可参考DNSPod的帮助文档：<a href="https://www.dnspod.cn/Support" target="_blank" rel="external">https://www.dnspod.cn/Support</a><br>  添加域名记录后，进入会有个加载配置啥的，不要保存，使用默认的两个解析就行</li>
<li>在DNSPod自己的域名下添加一条<a href="http://baike.baidu.com/view/65575.htm" target="_blank" rel="external">A记录</a>，地址就是Github Pages的服务IP地址：103.245.222.133（最好自行ping获取最新的ip）</li>
<li>在域名注册商处修改DNS服务:去Godaddy修改Nameservers为这两个地址：f1g1ns1.dnspod.net、f1g1ns2.dnspod.net。如果你不明白在哪里修改，可以参考这里：<a href="https://www.dnspod.cn/support/index/fid/119" target="_blank" rel="external">Godaddy注册的域名如何使用DNSPod</a></li>
<li>等待域名解析生效</li>
</ul>
<h3 id="绑定">绑定</h3><p>在刚创建的GitHub仓库根目录下添加<code>CNAME</code>文件，写入你申请的域名，等待生效。</p>
<h2 id="使用hexo">使用hexo</h2><p>基于github pages的不足，我们使用hexo博客框架</p>
<p>因为hexo的文档写的太好了，就没我啥事了！</p>
<p>传送门：<a href="http://hexo.io/zh-cn/" target="_blank" rel="external">http://hexo.io/zh-cn/</a></p>
<p>有任何问题，欢迎评论交流！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>GitHub带你装逼带你飞！你值得拥有！</em></p>
<hr>
<h2 id="介绍">介绍</h2><p><em><a href="https://github.com/" target="_blank" rel="external">GitHub</a>很]]>
    </summary>
    
      <category term="Blog" scheme="http://liuxing.info/tags/Blog/"/>
    
      <category term="DNSPod" scheme="http://liuxing.info/tags/DNSPod/"/>
    
      <category term="GitHub Pages" scheme="http://liuxing.info/tags/GitHub-Pages/"/>
    
      <category term="Godaddy" scheme="http://liuxing.info/tags/Godaddy/"/>
    
      <category term="Hexo" scheme="http://liuxing.info/tags/Hexo/"/>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RestTemplate实践]]></title>
    <link href="http://liuxing.info/2015/05/21/RestTemplate%E5%AE%9E%E8%B7%B5/"/>
    <id>http://liuxing.info/2015/05/21/RestTemplate实践/</id>
    <published>2015-05-21T02:56:27.000Z</published>
    <updated>2015-07-29T16:20:02.000Z</updated>
    <content type="html"><![CDATA[<p><em>什么是RestTemplate？</em></p>
<blockquote>
<p>RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率。<br>调用RestTemplate的默认构造函数，RestTemplate对象在底层通过使用java.net包下的实现创建HTTP 请求，可以通过使用ClientHttpRequestFactory指定不同的HTTP请求方式。<br>ClientHttpRequestFactory接口主要提供了两种实现方式</p>
<ul>
<li>一种是SimpleClientHttpRequestFactory，使用J2SE提供的方式（既java.net包提供的方式）创建底层的Http请求连接。</li>
<li>一种方式是使用HttpComponentsClientHttpRequestFactory方式，底层使用HttpClient访问远程的Http服务，使用HttpClient可以配置连接池和证书等信息。</li>
</ul>
</blockquote>
<hr>
<p><a href="#完整的实例代码">最新实例代码</a> 更新于<code>2015-07-30</code></p>
<h2 id="xml配置的方式">xml配置的方式</h2><p>请查看RestTemplate源码了解细节，知其然知其所以然！</p>
<p>RestTemplate默认是使用SimpleClientHttpRequestFactory，内部是调用jdk的HttpConnection，默认超时为-1</p>
<p>@Autowired<br>RestTemplate simpleRestTemplate<br>@Autowired<br>RestTemplate restTemplate</p>
<h3 id="基于jdk的spring的RestTemplate">基于jdk的spring的RestTemplate</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span><br><span class="line">       <span class="attribute">default-autowire</span>=<span class="value">"byName"</span> <span class="attribute">default-lazy-init</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--方式一、使用jdk的实现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"ky.requestFactory"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.http.client.SimpleClientHttpRequestFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"readTimeout"</span> <span class="attribute">value</span>=<span class="value">"10000"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connectTimeout"</span> <span class="attribute">value</span>=<span class="value">"5000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"simpleRestTemplate"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.web.client.RestTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"ky.requestFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"messageConverters"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.http.converter.FormHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="title">value</span>&gt;</span>text/plain;charset=UTF-8<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用Httpclient连接池的方式">使用Httpclient连接池的方式</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span><br><span class="line">       <span class="attribute">default-autowire</span>=<span class="value">"byName"</span> <span class="attribute">default-lazy-init</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--方式二、使用httpclient的实现，带连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"ky.pollingConnectionManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.http.impl.conn.PoolingHttpClientConnectionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--整个连接池的并发--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxTotal"</span> <span class="attribute">value</span>=<span class="value">"1000"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--每个主机的并发--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"defaultMaxPerRoute"</span> <span class="attribute">value</span>=<span class="value">"1000"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"ky.httpClientBuilder"</span> <span class="attribute">class</span>=<span class="value">"org.apache.http.impl.client.HttpClientBuilder"</span> <span class="attribute">factory-method</span>=<span class="value">"create"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connectionManager"</span> <span class="attribute">ref</span>=<span class="value">"ky.pollingConnectionManager"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启重试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"retryHandler"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.apache.http.impl.client.DefaultHttpRequestRetryHandler"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"2"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"defaultHeaders"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.apache.http.message.BasicHeader"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"User-Agent"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.16 Safari/537.36"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.apache.http.message.BasicHeader"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"Accept-Encoding"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"gzip,deflate"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.apache.http.message.BasicHeader"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"Accept-Language"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"zh-CN"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"ky.httpClient"</span> <span class="attribute">factory-bean</span>=<span class="value">"ky.httpClientBuilder"</span> <span class="attribute">factory-method</span>=<span class="value">"build"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"ky.clientHttpRequestFactory"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.http.client.HttpComponentsClientHttpRequestFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"ky.httpClient"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接超时时间，毫秒--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connectTimeout"</span> <span class="attribute">value</span>=<span class="value">"5000"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--读写超时时间，毫秒--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"readTimeout"</span> <span class="attribute">value</span>=<span class="value">"10000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"restTemplate"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.web.client.RestTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"ky.clientHttpRequestFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"errorHandler"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.web.client.DefaultResponseErrorHandler"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"messageConverters"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.http.converter.FormHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="title">value</span>&gt;</span>text/plain;charset=UTF-8<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="bean初始化+静态工具">bean初始化+静态工具</h2><p><strong>线程安全的单例（懒汉模式）</strong></p>
<h3 id="基于jdk的spring的RestTemplate-1">基于jdk的spring的RestTemplate</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.client.SimpleClientHttpRequestFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.FormHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.StringHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.DefaultResponseErrorHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@title</span>：基于jdk的spring的RestTemplate</span><br><span class="line"> * <span class="doctag">@author</span>：liuxing</span><br><span class="line"> * <span class="doctag">@date</span>：2015-05-18 09:35</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="annotation">@Lazy</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SimpleRestClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SimpleClientHttpRequestFactory requestFactory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setReadTimeout(<span class="number">5000</span>);</span><br><span class="line">        requestFactory.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加转换器</span></span><br><span class="line">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> StringHttpMessageConverter(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> FormHttpMessageConverter());</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> MappingJackson2XmlHttpMessageConverter());</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter());</span><br><span class="line"></span><br><span class="line">        restTemplate = <span class="keyword">new</span> RestTemplate(messageConverters);</span><br><span class="line">        restTemplate.setRequestFactory(requestFactory);</span><br><span class="line">        restTemplate.setErrorHandler(<span class="keyword">new</span> DefaultResponseErrorHandler());</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">"SimpleRestClient初始化完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SimpleRestClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestTemplate <span class="title">getClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Httpclient连接池的方式-1">使用Httpclient连接池的方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.Header;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.HttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.DefaultConnectionKeepAliveStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.DefaultHttpRequestRetryHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.conn.PoolingHttpClientConnectionManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message.BasicHeader;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.client.HttpComponentsClientHttpRequestFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.FormHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.StringHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.DefaultResponseErrorHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@title</span>：使用spring的restTemplate替代httpclient工具</span><br><span class="line"> * <span class="doctag">@author</span>：liuxing</span><br><span class="line"> * <span class="doctag">@date</span>：2015-05-18 08:48</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SimpleRestClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 长连接保持30秒</span></span><br><span class="line">        PoolingHttpClientConnectionManager pollingConnectionManager = <span class="keyword">new</span> PoolingHttpClientConnectionManager(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 总连接数</span></span><br><span class="line">        pollingConnectionManager.setMaxTotal(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 同路由的并发数</span></span><br><span class="line">        pollingConnectionManager.setDefaultMaxPerRoute(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        HttpClientBuilder httpClientBuilder = HttpClients.custom();</span><br><span class="line">        httpClientBuilder.setConnectionManager(pollingConnectionManager);</span><br><span class="line">        <span class="comment">// 重试次数，默认是3次，没有开启</span></span><br><span class="line">        httpClientBuilder.setRetryHandler(<span class="keyword">new</span> DefaultHttpRequestRetryHandler(<span class="number">2</span>, <span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">// 保持长连接配置，需要在头添加Keep-Alive</span></span><br><span class="line">        httpClientBuilder.setKeepAliveStrategy(DefaultConnectionKeepAliveStrategy.INSTANCE);</span><br><span class="line"></span><br><span class="line">        List&lt;Header&gt; headers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        headers.add(<span class="keyword">new</span> BasicHeader(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.16 Safari/537.36"</span>));</span><br><span class="line">        headers.add(<span class="keyword">new</span> BasicHeader(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip,deflate"</span>));</span><br><span class="line">        headers.add(<span class="keyword">new</span> BasicHeader(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN,zh;q=0.8,en;q=0.6"</span>));</span><br><span class="line">        headers.add(<span class="keyword">new</span> BasicHeader(<span class="string">"Connection"</span>, <span class="string">"keep-alive"</span>));</span><br><span class="line"></span><br><span class="line">        httpClientBuilder.setDefaultHeaders(headers);</span><br><span class="line"></span><br><span class="line">        HttpClient httpClient = httpClientBuilder.build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// httpClient连接配置，底层是配置RequestConfig</span></span><br><span class="line">        HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient);</span><br><span class="line">        <span class="comment">// 连接超时</span></span><br><span class="line">        clientHttpRequestFactory.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// 数据读取超时时间，即SocketTimeout</span></span><br><span class="line">        clientHttpRequestFactory.setReadTimeout(<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// 连接不够用的等待时间，不宜过长，必须设置，比如连接不够用时，时间过长将是灾难性的</span></span><br><span class="line">        clientHttpRequestFactory.setConnectionRequestTimeout(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 缓冲请求数据，默认值是true。通过POST或者PUT大量发送数据时，建议将此属性更改为false，以免耗尽内存。</span></span><br><span class="line">        <span class="comment">// clientHttpRequestFactory.setBufferRequestBody(false);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加内容转换器</span></span><br><span class="line">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> StringHttpMessageConverter(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> FormHttpMessageConverter());</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> MappingJackson2XmlHttpMessageConverter());</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter());</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> ByteArrayHttpMessageConverter());</span><br><span class="line"></span><br><span class="line">        restTemplate = <span class="keyword">new</span> RestTemplate(messageConverters);</span><br><span class="line">        restTemplate.setRequestFactory(clientHttpRequestFactory);</span><br><span class="line">        restTemplate.setErrorHandler(<span class="keyword">new</span> DefaultResponseErrorHandler());</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">"RestClient初始化完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RestClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestTemplate <span class="title">getClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用样例">使用样例</h2><h3 id="注意点">注意点</h3><p>api里面可以做自动的参数匹配：<br>如：<a href="http://you" target="_blank" rel="external">http://you</a> domainn name/test?empNo={empNo}，则下面方法的最后一个参数为数据匹配参数，会自动根据key进行查找，然后替换</p>
<p>API没有声明异常，注意进行异常处理</p>
<p>更多使用语法请查看API文档</p>
<h3 id="完整的实例代码">完整的实例代码</h3><p>定义一个异常<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.NestedRuntimeException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.HttpClientErrorException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.HttpServerErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 包装一个RestClient请求时抛出的异常</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> ：liuxing</span><br><span class="line"> * <span class="doctag">@since</span> ：2015-07-15 21:33</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClientException</span> <span class="keyword">extends</span> <span class="title">NestedRuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 状态码</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> HttpStatus statusCode;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 状态码文本</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> String statusText;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 异常时返回的内容</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> String responseBody;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 返回的头</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> HttpHeaders responseHeaders;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RestClientException</span><span class="params">(Exception exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(exception.getMessage(), exception);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> HttpServerErrorException) &#123;</span><br><span class="line">            HttpServerErrorException e = (HttpServerErrorException) exception;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.statusCode = e.getStatusCode();</span><br><span class="line">            <span class="keyword">this</span>.statusText = e.getStatusText();</span><br><span class="line">            <span class="keyword">this</span>.responseBody = e.getResponseBodyAsString();</span><br><span class="line">            <span class="keyword">this</span>.responseHeaders = e.getResponseHeaders();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> HttpClientErrorException) &#123;</span><br><span class="line">            HttpClientErrorException e = (HttpClientErrorException) exception;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.statusCode = e.getStatusCode();</span><br><span class="line">            <span class="keyword">this</span>.statusText = e.getStatusText();</span><br><span class="line">            <span class="keyword">this</span>.responseBody = e.getResponseBodyAsString();</span><br><span class="line">            <span class="keyword">this</span>.responseHeaders = e.getResponseHeaders();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.statusText = exception.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> statusCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatusCode</span><span class="params">(HttpStatus statusCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.statusCode = statusCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> statusText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatusText</span><span class="params">(String statusText)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.statusText = statusText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResponseBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResponseBody</span><span class="params">(String responseBody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseBody = responseBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getResponseHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseHeaders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResponseHeaders</span><span class="params">(HttpHeaders responseHeaders)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseHeaders = responseHeaders;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>工具集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.dooioo.se.commons.Lang;</span><br><span class="line"><span class="keyword">import</span> com.dooioo.se.utils.RestClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.MapUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.ParameterizedTypeReference;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.LinkedMultiValueMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.MultiValueMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * httpclient工具类,基于httpclient 4.x</span><br><span class="line"> * 不需要设置header的情况：</span><br><span class="line"> * 1.普通的非校验型请求</span><br><span class="line"> * 2.普通的表单请求</span><br><span class="line"> * &lt;p/&gt;</span><br><span class="line"> * 需要设置header的情况：</span><br><span class="line"> * 1.头部带token校验的请求</span><br><span class="line"> * 2.提交json数据的请求</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> 刘兴</span><br><span class="line"> * <span class="doctag">@version</span> V1.0</span><br><span class="line"> * <span class="doctag">@since</span> 2014-3-7 下午7:48:58</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 执行请求</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> url          请求地址</span><br><span class="line">     * <span class="doctag">@param</span> method       请求方式</span><br><span class="line">     * <span class="doctag">@param</span> responseType 返回的数据类型</span><br><span class="line">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span><br><span class="line">     * <span class="doctag">@return</span> 结果对象</span><br><span class="line">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange(url, method, <span class="keyword">null</span>, <span class="keyword">null</span>, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 执行请求</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> url          请求地址</span><br><span class="line">     * <span class="doctag">@param</span> method       请求方式</span><br><span class="line">     * <span class="doctag">@param</span> headers      设置的头信息</span><br><span class="line">     * <span class="doctag">@param</span> responseType 返回的数据类型</span><br><span class="line">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span><br><span class="line">     * <span class="doctag">@return</span> 结果对象</span><br><span class="line">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, HttpHeaders headers, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange(url, method, headers, <span class="keyword">null</span>, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 执行请求</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> url          请求地址</span><br><span class="line">     * <span class="doctag">@param</span> method       请求方式</span><br><span class="line">     * <span class="doctag">@param</span> body         要提交的数据</span><br><span class="line">     * <span class="doctag">@param</span> responseType 返回数据类型</span><br><span class="line">     *                     返回bean时指定Class</span><br><span class="line">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span><br><span class="line">     * <span class="doctag">@return</span> 结果对象</span><br><span class="line">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, Object body, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange(url, method, <span class="keyword">null</span>, body, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 执行请求</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> url          请求地址</span><br><span class="line">     * <span class="doctag">@param</span> method       请求方式</span><br><span class="line">     * <span class="doctag">@param</span> httpHeaders  请求头</span><br><span class="line">     * <span class="doctag">@param</span> body         要提交的数据</span><br><span class="line">     * <span class="doctag">@param</span> responseType 返回数据类型</span><br><span class="line">     *                     返回bean时指定Class</span><br><span class="line">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span><br><span class="line">     * <span class="doctag">@return</span> 结果对象</span><br><span class="line">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, HttpHeaders httpHeaders, Object body, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpEntity&lt;?&gt; requestEntity = <span class="keyword">new</span> HttpEntity(body, httpHeaders);</span><br><span class="line">            requestEntity = convert(requestEntity);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uriVariables.length == <span class="number">1</span> &amp;&amp; uriVariables[<span class="number">0</span>] <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">                Map&lt;String, ?&gt; _uriVariables = (Map&lt;String, ?&gt;) uriVariables[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span> getClient().exchange(url, method, requestEntity, responseType, _uriVariables).getBody();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> getClient().exchange(url, method, requestEntity, responseType, uriVariables).getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RestClientException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 执行请求</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> url          请求地址</span><br><span class="line">     * <span class="doctag">@param</span> method       请求方式</span><br><span class="line">     * <span class="doctag">@param</span> responseType 返回的数据类型，例：new ParameterizedTypeReference&lt;List&lt;Bean&gt;&gt;()&#123;&#125;</span><br><span class="line">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span><br><span class="line">     * <span class="doctag">@return</span> 结果对象</span><br><span class="line">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, ParameterizedTypeReference&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange(url, method, <span class="keyword">null</span>, <span class="keyword">null</span>, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 执行请求</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> url          请求地址</span><br><span class="line">     * <span class="doctag">@param</span> method       请求方式</span><br><span class="line">     * <span class="doctag">@param</span> headers      设置的头信息</span><br><span class="line">     * <span class="doctag">@param</span> responseType 返回的数据类型，例：new ParameterizedTypeReference&lt;List&lt;Bean&gt;&gt;()&#123;&#125;</span><br><span class="line">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span><br><span class="line">     * <span class="doctag">@return</span> 结果对象</span><br><span class="line">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, HttpHeaders headers, ParameterizedTypeReference&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange(url, method, headers, <span class="keyword">null</span>, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 执行请求</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> url          请求地址</span><br><span class="line">     * <span class="doctag">@param</span> method       请求方式</span><br><span class="line">     * <span class="doctag">@param</span> body         要提交的数据</span><br><span class="line">     * <span class="doctag">@param</span> responseType 返回数据类型，例：new ParameterizedTypeReference&lt;List&lt;Bean&gt;&gt;()&#123;&#125;</span><br><span class="line">     *                     返回bean时指定Class</span><br><span class="line">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span><br><span class="line">     * <span class="doctag">@return</span> 结果对象</span><br><span class="line">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, Object body, ParameterizedTypeReference&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange(url, method, <span class="keyword">null</span>, body, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 执行请求</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> url          请求地址</span><br><span class="line">     * <span class="doctag">@param</span> method       请求方式</span><br><span class="line">     * <span class="doctag">@param</span> httpHeaders  请求头</span><br><span class="line">     * <span class="doctag">@param</span> body         要提交的数据</span><br><span class="line">     * <span class="doctag">@param</span> responseType 返回数据类型，例：new ParameterizedTypeReference&lt;List&lt;Bean&gt;&gt;()&#123;&#125;</span><br><span class="line">     *                     返回bean时指定Class</span><br><span class="line">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span><br><span class="line">     * <span class="doctag">@return</span> 结果对象</span><br><span class="line">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, HttpHeaders httpHeaders, Object body, ParameterizedTypeReference&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpEntity&lt;?&gt; requestEntity = <span class="keyword">new</span> HttpEntity(body, httpHeaders);</span><br><span class="line">            requestEntity = convert(requestEntity);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uriVariables.length == <span class="number">1</span> &amp;&amp; uriVariables[<span class="number">0</span>] <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">                Map&lt;String, ?&gt; _uriVariables = (Map&lt;String, ?&gt;) uriVariables[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span> getClient().exchange(url, method, requestEntity, responseType, _uriVariables).getBody();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> getClient().exchange(url, method, requestEntity, responseType, uriVariables).getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RestClientException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 获得一个RestTemplate客户端</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestTemplate <span class="title">getClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RestClientBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 获取一个application/x-www-form-urlencoded头</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpHeaders <span class="title">buildBasicFORMHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 获取一个application/json头</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpHeaders <span class="title">buildBasicJSONHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 获取一个text/html头</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpHeaders <span class="title">buildBasicHTMLHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        headers.setContentType(MediaType.TEXT_HTML);</span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构建一个json头</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> arrays</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpHeaders <span class="title">buildJSONHeaders</span><span class="params">(Object... arrays)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arrays.length % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"arrays 长度 必须为偶数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpHeaders headers = buildBasicJSONHeaders();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; i++) &#123;</span><br><span class="line">            headers.add(Lang.defaultEmptyStr(arrays[i]), Lang.defaultEmptyStr(arrays[++i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 对bean对象转表单模型做处理</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> requestEntity</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HttpEntity&lt;?&gt; convert(HttpEntity&lt;?&gt; requestEntity) &#123;</span><br><span class="line">        Object body = requestEntity.getBody();</span><br><span class="line">        HttpHeaders headers = requestEntity.getHeaders();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (body == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> requestEntity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">            MultiValueMap&lt;String, String&gt; multiValueMap = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            Map&lt;String, ?&gt; _body = (Map&lt;String, ?&gt;) body;</span><br><span class="line">            <span class="keyword">for</span> (String key : _body.keySet()) &#123;</span><br><span class="line">                multiValueMap.add(key, MapUtils.getString(_body, key));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            requestEntity = <span class="keyword">new</span> HttpEntity&lt;&gt;(multiValueMap, headers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (headers == <span class="keyword">null</span> || !MediaType.APPLICATION_FORM_URLENCODED.equals(headers.getContentType())) &#123;</span><br><span class="line">            <span class="keyword">return</span> requestEntity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> requestEntity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">            <span class="keyword">return</span> requestEntity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">            <span class="keyword">return</span> requestEntity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MultiValueMap&lt;String, Object&gt; formEntity = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Field[] fields = body.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            String name = fields[i].getName();</span><br><span class="line">            String value = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value = BeanUtils.getProperty(body, name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            formEntity.add(name, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpEntity&lt;&gt;(formEntity, headers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Object[] EMPTY_URI_VARIABLES = <span class="keyword">new</span> Object[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> HttpHeaders EMPTY_HEADERS = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, ?&gt; EMPTY_BODY = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> HttpEntity EMPTY_ENTITY = <span class="keyword">new</span> HttpEntity(EMPTY_HEADERS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更多">更多</h2><p><strong>RestTemplate API说明和使用参考</strong></p>
<p><a href="http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="external">http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/web/client/RestTemplate.html</a></p>
<p><a href="http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/http/client/SimpleClientHttpRequestFactory.html" target="_blank" rel="external">http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/http/client/SimpleClientHttpRequestFactory.html</a></p>
<p><a href="http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/http/client/HttpComponentsClientHttpRequestFactory.html" target="_blank" rel="external">http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/http/client/HttpComponentsClientHttpRequestFactory.html</a></p>
<p><strong>HttpClient官方示例和参数配置说明</strong></p>
<p><a href="http://hc.apache.org/httpcomponents-client-4.4.x/examples.html" target="_blank" rel="external">http://hc.apache.org/httpcomponents-client-4.4.x/examples.html</a></p>
<p><a href="http://hc.apache.org/httpcomponents-client-4.4.x/tutorial/html/index.html" target="_blank" rel="external">http://hc.apache.org/httpcomponents-client-4.4.x/tutorial/html/index.html</a></p>
<p><strong>依赖</strong><br><em>spring 3.x以上</em><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.codehaus.jackson<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>jackson-mapper-asl<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.9.13<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意点</strong></p>
<p>1.关于httpclient配置的<code>defaultMaxPerRoute</code>和<code>maxTotal</code><br><code>defaultMaxPerRoute</code>：最大路由并发数，以主机为单位<br><code>maxTotal</code>：整个连接池的并发数</p>
<p>例如：<br><code>defaultMaxPerRoute</code>为10，<code>maxTotal</code>为100<br>假设只会访问<a href="http://www.baidu.com和http://www.google.com" target="_blank" rel="external">http://www.baidu.com和http://www.google.com</a><br>那么能同时并发到客源的只能是10，房源也是10，整个连接永远不会到100</p>
<p>2.部分方法注意查看源码，默认构造里面会新增常用的数据转换器，spring对jackson比较情有独钟，在解析xml和json时，优先使用jackson</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Create a new instance of the &#123;<span class="doctag">@link</span> RestTemplate&#125; using default settings.</span><br><span class="line"> * Default &#123;<span class="doctag">@link</span> HttpMessageConverter&#125;s are initialized.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> ByteArrayHttpMessageConverter());</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> StringHttpMessageConverter());</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> ResourceHttpMessageConverter());</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> SourceHttpMessageConverter&lt;Source&gt;());</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> AllEncompassingFormHttpMessageConverter());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (romePresent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> AtomFeedHttpMessageConverter());</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> RssChannelHttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (jackson2XmlPresent) &#123;</span><br><span class="line">            messageConverters.add(<span class="keyword">new</span> MappingJackson2XmlHttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jaxb2Present) &#123;</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> Jaxb2RootElementHttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (jackson2Present) &#123;</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (gsonPresent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> GsonHttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Create a new instance of the &#123;<span class="doctag">@link</span> RestTemplate&#125; based on the given &#123;<span class="doctag">@link</span> ClientHttpRequestFactory&#125;.</span><br><span class="line"> * <span class="doctag">@param</span> requestFactory HTTP request factory to use</span><br><span class="line"> * <span class="doctag">@see</span> org.springframework.http.client.SimpleClientHttpRequestFactory</span><br><span class="line"> * <span class="doctag">@see</span> org.springframework.http.client.HttpComponentsClientHttpRequestFactory</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RestTemplate</span><span class="params">(ClientHttpRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    setRequestFactory(requestFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看添加转换器的方法外部添加转换器时，this.messageConverters.clear();会先清除已有的，需要注意</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Create a new instance of the &#123;<span class="doctag">@link</span> RestTemplate&#125; using the given list of</span><br><span class="line"> * &#123;<span class="doctag">@link</span> HttpMessageConverter&#125; to use</span><br><span class="line"> * <span class="doctag">@param</span> messageConverters the list of &#123;<span class="doctag">@link</span> HttpMessageConverter&#125; to use</span><br><span class="line"> * <span class="doctag">@since</span> 3.2.7</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RestTemplate</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(messageConverters, <span class="string">"'messageConverters' must not be empty"</span>);</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.addAll(messageConverters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Set the message body converters to use.</span><br><span class="line"> * &lt;p&gt;These converters are used to convert from and to HTTP requests and responses.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(messageConverters, <span class="string">"'messageConverters' must not be empty"</span>);</span><br><span class="line">    <span class="comment">// Take getMessageConverters() List as-is when passed in here</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.messageConverters != messageConverters) &#123;</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.clear();</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.addAll(messageConverters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><em>什么是RestTemplate？</em></p>
<blockquote>
<p>RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率。<br>调用]]>
    </summary>
    
      <category term="RestTemplate" scheme="http://liuxing.info/tags/RestTemplate/"/>
    
      <category term="Spring" scheme="http://liuxing.info/tags/Spring/"/>
    
      <category term="httpClient" scheme="http://liuxing.info/tags/httpClient/"/>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用spring4的websocket支持]]></title>
    <link href="http://liuxing.info/2015/04/21/%E4%BD%BF%E7%94%A8spring4%E7%9A%84websocket%E6%94%AF%E6%8C%81/"/>
    <id>http://liuxing.info/2015/04/21/使用spring4的websocket支持/</id>
    <published>2015-04-20T16:48:00.000Z</published>
    <updated>2015-06-16T13:47:13.000Z</updated>
    <content type="html"><![CDATA[<p>J2EE7版（JSR-356）<br><a href="http://liuxing.info/2015/02/09/websocket-demo">http://liuxing.info/2015/02/09/websocket-demo</a></p>
<p>相关依赖请参考上文，spring需要4.x</p>
<h2 id="websocket处理器">websocket处理器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.MapUtils;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.CloseStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.TextMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.handler.BinaryWebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.handler.TextWebSocketHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 功能说明：WebSocket处理器</span><br><span class="line"> * 可以继承 &#123;<span class="doctag">@link</span> TextWebSocketHandler&#125;/&#123;<span class="doctag">@link</span> BinaryWebSocketHandler&#125;，</span><br><span class="line"> * 或者简单的实现&#123;<span class="doctag">@link</span> WebSocketHandler&#125;接口</span><br><span class="line"> * 作者：liuxing(2015-01-25 03:42)</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TelWebSocketHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TelWebSocketHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 建立连接</span><br><span class="line">     * <span class="doctag">@param</span> session</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String inquiryId = MapUtils.getString(session.getAttributes(), <span class="string">"inquiryId"</span>);</span><br><span class="line">        <span class="keyword">int</span> empNo = MapUtils.getInteger(session.getAttributes(), <span class="string">"empNo"</span>);</span><br><span class="line">        TelSocketSessionUtils.add(inquiryId, empNo, session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 收到客户端消息</span><br><span class="line">     * <span class="doctag">@param</span> session</span><br><span class="line">     * <span class="doctag">@param</span> message</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String inquiryId = MapUtils.getString(session.getAttributes(), <span class="string">"inquiryId"</span>);</span><br><span class="line">        <span class="keyword">int</span> empNo = MapUtils.getInteger(session.getAttributes(), <span class="string">"empNo"</span>);</span><br><span class="line">        TelSocketSessionUtils.sendMessage(inquiryId, empNo, <span class="string">"【来自服务器的复读机】："</span> + message.getPayload().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 出现异常</span><br><span class="line">     * <span class="doctag">@param</span> session</span><br><span class="line">     * <span class="doctag">@param</span> exception</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String inquiryId = MapUtils.getString(session.getAttributes(), <span class="string">"inquiryId"</span>);</span><br><span class="line">        <span class="keyword">int</span> empNo = MapUtils.getInteger(session.getAttributes(), <span class="string">"empNo"</span>);</span><br><span class="line"></span><br><span class="line">        LOGGER.error(<span class="string">"websocket connection exception: "</span> + TelSocketSessionUtils.getKey(inquiryId, empNo));</span><br><span class="line">        LOGGER.error(exception.getMessage(), exception);</span><br><span class="line"></span><br><span class="line">        TelSocketSessionUtils.remove(inquiryId, empNo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 连接关闭</span><br><span class="line">     * <span class="doctag">@param</span> session</span><br><span class="line">     * <span class="doctag">@param</span> closeStatus</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String inquiryId = MapUtils.getString(session.getAttributes(), <span class="string">"inquiryId"</span>);</span><br><span class="line">        <span class="keyword">int</span> empNo = MapUtils.getInteger(session.getAttributes(), <span class="string">"empNo"</span>);</span><br><span class="line">        TelSocketSessionUtils.remove(inquiryId, empNo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 是否分段发送消息</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="websocket连接的拦截器">websocket连接的拦截器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServletServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 功能说明：websocket连接的拦截器</span><br><span class="line"> * 有两种方式</span><br><span class="line"> *          一种是实现接口HandshakeInterceptor，实现beforeHandshake和afterHandshake函数</span><br><span class="line"> *          一种是继承HttpSessionHandshakeInterceptor，重载beforeHandshake和afterHandshake函数</span><br><span class="line"> * 我这里是参照spring官方文档中的继承HttpSessionHandshakeInterceptor的方式</span><br><span class="line"> * 作者：liuxing(2015-01-25 03:46)</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TelWebSocketHandshakeInterceptor</span> <span class="keyword">extends</span> <span class="title">HttpSessionHandshakeInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TelWebSocketHandshakeInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 从请求中获取唯一标记参数，填充到数据传递容器attributes</span><br><span class="line">     * <span class="doctag">@param</span> serverHttpRequest</span><br><span class="line">     * <span class="doctag">@param</span> serverHttpResponse</span><br><span class="line">     * <span class="doctag">@param</span> wsHandler</span><br><span class="line">     * <span class="doctag">@param</span> attributes</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">beforeHandshake</span><span class="params">(ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getSession(serverHttpRequest) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ServletServerHttpRequest servletRequest = (ServletServerHttpRequest) serverHttpRequest;</span><br><span class="line">            HttpServletRequest request = servletRequest.getServletRequest();</span><br><span class="line">            attributes.put(<span class="string">"inquiryId"</span>, request.getParameter(<span class="string">"inquiryId"</span>));</span><br><span class="line">            attributes.put(<span class="string">"empNo"</span>, request.getParameter(<span class="string">"empNo"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.beforeHandshake(serverHttpRequest, serverHttpResponse, wsHandler, attributes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterHandshake(request, response, wsHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HttpSession <span class="title">getSession</span><span class="params">(ServerHttpRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ServletServerHttpRequest) &#123;</span><br><span class="line">            ServletServerHttpRequest serverRequest = (ServletServerHttpRequest) request;</span><br><span class="line">            <span class="keyword">return</span> serverRequest.getServletRequest().getSession(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="session工具类">session工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.TextMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 功能说明：TelSocketSessionUtils</span><br><span class="line"> * 作者：liuxing(2014-12-26 02:32)</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TelSocketSessionUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TelSocketSessionUtils.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, WebSocketSession&gt; clients = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 保存一个连接</span><br><span class="line">     * <span class="doctag">@param</span> inquiryId</span><br><span class="line">     * <span class="doctag">@param</span> empNo</span><br><span class="line">     * <span class="doctag">@param</span> session</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String inquiryId, <span class="keyword">int</span> empNo, WebSocketSession session)</span></span>&#123;</span><br><span class="line">        clients.put(getKey(inquiryId, empNo), session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 获取一个连接</span><br><span class="line">     * <span class="doctag">@param</span> inquiryId</span><br><span class="line">     * <span class="doctag">@param</span> empNo</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WebSocketSession <span class="title">get</span><span class="params">(String inquiryId, <span class="keyword">int</span> empNo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clients.get(getKey(inquiryId, empNo));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 移除一个连接</span><br><span class="line">     * <span class="doctag">@param</span> inquiryId</span><br><span class="line">     * <span class="doctag">@param</span> empNo</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String inquiryId, <span class="keyword">int</span> empNo)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        clients.remove(getKey(inquiryId, empNo));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 组装sessionId</span><br><span class="line">     * <span class="doctag">@param</span> inquiryId</span><br><span class="line">     * <span class="doctag">@param</span> empNo</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String inquiryId, <span class="keyword">int</span> empNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inquiryId + <span class="string">"_"</span> + empNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 判断是否有效连接</span><br><span class="line">     * 判断是否存在</span><br><span class="line">     * 判断连接是否开启</span><br><span class="line">     * 无效的进行清除</span><br><span class="line">     * <span class="doctag">@param</span> inquiryId</span><br><span class="line">     * <span class="doctag">@param</span> empNo</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasConnection</span><span class="params">(String inquiryId, <span class="keyword">int</span> empNo)</span> </span>&#123;</span><br><span class="line">        String key = getKey(inquiryId, empNo);</span><br><span class="line">        <span class="keyword">if</span> (clients.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 获取连接数的数量</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clients.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 发送消息到客户端</span><br><span class="line">     * <span class="doctag">@param</span> inquiryId</span><br><span class="line">     * <span class="doctag">@param</span> empNo</span><br><span class="line">     * <span class="doctag">@param</span> message</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String inquiryId, <span class="keyword">int</span> empNo, String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasConnection(inquiryId, empNo)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(getKey(inquiryId, empNo) + <span class="string">" connection does not exist"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WebSocketSession session = get(inquiryId, empNo);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            session.sendMessage(<span class="keyword">new</span> TextMessage(message));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"websocket sendMessage exception: "</span> + getKey(inquiryId, empNo));</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">            clients.remove(getKey(inquiryId, empNo));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化配置">初始化配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--websocket配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"telWebSocketHandler"</span> <span class="attribute">class</span>=<span class="value">"包.websocket.handler.TelWebSocketHandler"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">websocket:handlers</span> <span class="attribute">allowed-origins</span>=<span class="value">"*"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">websocket:mapping</span> <span class="attribute">path</span>=<span class="value">"webSocketStatus"</span> <span class="attribute">handler</span>=<span class="value">"telWebSocketHandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">websocket:handshake-interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"包.websocket.interceptor.TelWebSocketHandshakeInterceptor"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">websocket:handshake-interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxTextMessageBufferSize"</span> <span class="attribute">value</span>=<span class="value">"8192"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxBinaryMessageBufferSize"</span> <span class="attribute">value</span>=<span class="value">"8192"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxSessionIdleTimeout"</span> <span class="attribute">value</span>=<span class="value">"900000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"asyncSendTimeout"</span> <span class="attribute">value</span>=<span class="value">"5000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>spring官方文档已经写得很齐全了，更多场景和说明请参阅下文大笑<br><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#websocket" target="_blank" rel="external">http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#websocket</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>J2EE7版（JSR-356）<br><a href="http://liuxing.info/2015/02/09/websocket-demo">http://liuxing.info/2015/02/09/websocket-demo</a></p>
<p>相关依赖请]]>
    </summary>
    
      <category term="Spring" scheme="http://liuxing.info/tags/Spring/"/>
    
      <category term="websocket" scheme="http://liuxing.info/tags/websocket/"/>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring4不兼容ibatis的解决方法 ]]></title>
    <link href="http://liuxing.info/2015/04/21/spring4%E4%B8%8D%E5%85%BC%E5%AE%B9ibatis%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%20/"/>
    <id>http://liuxing.info/2015/04/21/spring4不兼容ibatis的解决方法 /</id>
    <published>2015-04-20T16:46:00.000Z</published>
    <updated>2015-06-16T13:47:13.000Z</updated>
    <content type="html"><![CDATA[<p>因为spring升级到4.x后，orm包里面移除了对ibatis的支持，<br>如果orm使用4.x版本的话项目会启动失败。<br>查看orm-3.x版本的SqlMapClientFactoryBean类，里面说的很清楚，只支持到3.x。<br>如果可以升级到mybatis的话尽量升级，否则可以使用如下方法。<br>orm包单独使用3.x的版本，项目中正式在用，还没出现问题（或许还没爆出来哭）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.2.13.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>因为spring升级到4.x后，orm包里面移除了对ibatis的支持，<br>如果orm使用4.x版本的话项目会启动失败。<br>查看orm-3.x版本的SqlMapClientFactoryBean类，里面说的很清楚，只支持到3.x。<br>如果可以升级到mybatis]]>
    </summary>
    
      <category term="Spring" scheme="http://liuxing.info/tags/Spring/"/>
    
      <category term="ibatis" scheme="http://liuxing.info/tags/ibatis/"/>
    
      <category term="框架" scheme="http://liuxing.info/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[计算地图坐标是否在多边形内]]></title>
    <link href="http://liuxing.info/2015/04/21/%E8%AE%A1%E7%AE%97%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85/"/>
    <id>http://liuxing.info/2015/04/21/计算地图坐标是否在多边形内/</id>
    <published>2015-04-20T16:44:00.000Z</published>
    <updated>2015-06-16T13:47:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="使用百度地图计算">使用百度地图计算</h2><p><a href="http://api.map.baidu.com/library/GeoUtils/1.2/examples/simple.html" target="_blank" rel="external">http://api.map.baidu.com/library/GeoUtils/1.2/examples/simple.html</a><br><a href="http://api.map.baidu.com/library/GeoUtils/1.2/docs/symbols/BMapLib.GeoUtils.html" target="_blank" rel="external">http://api.map.baidu.com/library/GeoUtils/1.2/docs/symbols/BMapLib.GeoUtils.html</a></p>
<h2 id="使用java计算">使用java计算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.geom.GeneralPath;</span><br><span class="line"><span class="keyword">import</span> java.awt.geom.Point2D;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 功能说明：坐标几何运算</span><br><span class="line"> * 作者：liuxing(2015-04-20 22:19)</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeoUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 检查一个坐标是否在多边形内</span><br><span class="line">     * <span class="doctag">@param</span> x 纬度 31.000...</span><br><span class="line">     * <span class="doctag">@param</span> y 经度 121.000...</span><br><span class="line">     * <span class="doctag">@param</span> polygonPoints 多边形边界的经纬度数组</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPointInPolygon</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, List&lt;Map&lt;String, Double&gt;&gt; polygonPoints)</span> </span>&#123;</span><br><span class="line">        Point2D.Double geoPoint = buildPoint(x, y);</span><br><span class="line">        List&lt;Point2D.Double&gt; geoPolygon = buildPolygon(polygonPoints);</span><br><span class="line">        <span class="keyword">return</span> GeoUtils.isPointInPolygon(geoPoint, geoPolygon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 检查一个坐标是否在多边形内</span><br><span class="line">     * <span class="doctag">@param</span> point 检查的点坐标</span><br><span class="line">     * <span class="doctag">@param</span> polygon 参照的多边形</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPointInPolygon</span><span class="params">(Point2D.Double point, List&lt;Point2D.Double&gt; polygon)</span> </span>&#123;</span><br><span class="line">        GeneralPath p = <span class="keyword">new</span> GeneralPath();</span><br><span class="line"></span><br><span class="line">        Point2D.Double first = polygon.get(<span class="number">0</span>);</span><br><span class="line">        p.moveTo(first.x, first.y);</span><br><span class="line">        polygon.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        polygon.forEach(d -&gt; p.lineTo(d.x, d.y));</span><br><span class="line"></span><br><span class="line">        p.lineTo(first.x, first.y);</span><br><span class="line"></span><br><span class="line">        p.closePath();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p.contains(point);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构建一个坐标点</span><br><span class="line">     * <span class="doctag">@param</span> x 纬度 31.000...</span><br><span class="line">     * <span class="doctag">@param</span> y 经度 121.000...</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point2D.<span class="function">Double <span class="title">buildPoint</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point2D.Double(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构建一个多边形</span><br><span class="line">     * <span class="doctag">@param</span> polygonPoints</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Point2D.Double&gt; buildPolygon(List&lt;Map&lt;String, Double&gt;&gt; polygonPoints) &#123;</span><br><span class="line">        List&lt;Point2D.Double&gt; geoPolygon = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        polygonPoints.forEach(map -&gt; geoPolygon.add(buildPoint(map.get(<span class="string">"x"</span>), map.get(<span class="string">"y"</span>))));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> geoPolygon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多运算场景请参考：<br><a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Polygon.html" target="_blank" rel="external">http://docs.oracle.com/javase/8/docs/api/java/awt/Polygon.html</a></p>
<h2 id="使用数据库计算">使用数据库计算</h2><p>SqlServer2008以上，暂未尝试</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="使用百度地图计算">使用百度地图计算</h2><p><a href="http://api.map.baidu.com/library/GeoUtils/1.2/examples/simple.html" target="_blank" rel="external]]>
    </summary>
    
      <category term="地图" scheme="http://liuxing.info/tags/%E5%9C%B0%E5%9B%BE/"/>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java和数据库计算两个坐标的距离]]></title>
    <link href="http://liuxing.info/2015/04/21/java%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E5%9D%90%E6%A0%87%E7%9A%84%E8%B7%9D%E7%A6%BB/"/>
    <id>http://liuxing.info/2015/04/21/java和数据库计算两个坐标的距离/</id>
    <published>2015-04-20T16:41:00.000Z</published>
    <updated>2015-06-16T13:47:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="使用Java进行计算">使用Java进行计算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 类功能说明：地图坐标距离计算工具类</span><br><span class="line"> * Title: DistanceUtil.java</span><br><span class="line"> * <span class="doctag">@author</span> liuxing</span><br><span class="line"> * <span class="doctag">@date</span> 2013-9-8 下午10:36:03</span><br><span class="line"> * <span class="doctag">@version</span> V1.0</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistanceUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> DEF_PI = Math.PI; <span class="comment">// PI</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> DEF_2PI = Math.PI * <span class="number">2</span>; <span class="comment">// 2*PI</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> DEF_PI180 = Math.PI / <span class="number">180</span>; <span class="comment">// PI/180.0</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> DEF_R = <span class="number">6370693.5</span>; <span class="comment">// 地球半径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * </span><br><span class="line">	 * 功能说明：计算两个地图坐标点之间的距离（近距离计算）</span><br><span class="line">	 * liuxing 2013-9-8 下午10:42:17</span><br><span class="line">	 * <span class="doctag">@param</span> lng1 起点经度</span><br><span class="line">	 * <span class="doctag">@param</span> lat1 起点纬度</span><br><span class="line">	 * <span class="doctag">@param</span> lng2 终点经度</span><br><span class="line">	 * <span class="doctag">@param</span> lat2 终点纬度</span><br><span class="line">	 * <span class="doctag">@return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getShortDistance</span><span class="params">(<span class="keyword">double</span> lng1, <span class="keyword">double</span> lat1, <span class="keyword">double</span> lng2, <span class="keyword">double</span> lat2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> ew1, ns1, ew2, ns2;</span><br><span class="line">		<span class="keyword">double</span> dx, dy, dew;</span><br><span class="line">		<span class="keyword">double</span> distance;</span><br><span class="line">		<span class="comment">// 角度转换为弧度</span></span><br><span class="line">		ew1 = Math.toRadians(lng1);</span><br><span class="line">		ns1 = Math.toRadians(lat1);</span><br><span class="line">		ew2 = Math.toRadians(lng2);</span><br><span class="line">		ns2 = Math.toRadians(lat2);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 经度差</span></span><br><span class="line">		dew = ew1 - ew2;</span><br><span class="line">		<span class="comment">// 若跨东经和西经180 度，进行调整</span></span><br><span class="line">		<span class="keyword">if</span> (dew &gt; DEF_PI)&#123;</span><br><span class="line">			dew = DEF_2PI - dew;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dew &lt; -DEF_PI)&#123;</span><br><span class="line">			dew = DEF_2PI + dew;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		dx = DEF_R * Math.cos(ns1) * dew; 	<span class="comment">// 东西方向长度(在纬度圈上的投影长度)</span></span><br><span class="line">		dy = DEF_R * (ns1 - ns2); 			<span class="comment">// 南北方向长度(在经度圈上的投影长度)</span></span><br><span class="line">		<span class="comment">// 勾股定理求斜边长</span></span><br><span class="line">		distance = Math.sqrt(dx * dx + dy * dy);</span><br><span class="line">		<span class="keyword">return</span> distance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * </span><br><span class="line">	 * 功能说明：计算两个地图坐标点之间的距离（远距离计算）</span><br><span class="line">	 * liuxing 2013-9-8 下午10:43:21</span><br><span class="line">	 * <span class="doctag">@param</span> lng1 起点经度</span><br><span class="line">	 * <span class="doctag">@param</span> lat1 起点纬度</span><br><span class="line">	 * <span class="doctag">@param</span> lng2 终点经度</span><br><span class="line">	 * <span class="doctag">@param</span> lat2 终点纬度</span><br><span class="line">	 * <span class="doctag">@return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getLongDistance</span><span class="params">(<span class="keyword">double</span> lng1, <span class="keyword">double</span> lat1, <span class="keyword">double</span> lng2, <span class="keyword">double</span> lat2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> ew1, ns1, ew2, ns2;</span><br><span class="line">		<span class="keyword">double</span> distance;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 角度转换为弧度</span></span><br><span class="line">		ew1 = lng1 * DEF_PI180;</span><br><span class="line">		ns1 = lat1 * DEF_PI180;</span><br><span class="line">		ew2 = lng2 * DEF_PI180;</span><br><span class="line">		ns2 = lat2 * DEF_PI180;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 求大圆劣弧与球心所夹的角(弧度)</span></span><br><span class="line">		distance = Math.sin(ns1) * Math.sin(ns2) + Math.cos(ns1) * Math.cos(ns2) * Math.cos(ew1 - ew2);</span><br><span class="line">		<span class="comment">// 调整到[-1..1]范围内，避免溢出</span></span><br><span class="line">		<span class="keyword">if</span> (distance &gt; <span class="number">1.0</span>)&#123;</span><br><span class="line">			distance = <span class="number">1.0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (distance &lt; -<span class="number">1.0</span>)&#123;</span><br><span class="line">			distance = -<span class="number">1.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 求大圆劣弧长度</span></span><br><span class="line">		distance = DEF_R * Math.acos(distance);</span><br><span class="line">		<span class="keyword">return</span> distance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> mLat1 = <span class="number">31.24081800000000</span>; 	<span class="comment">// point1纬度</span></span><br><span class="line">		<span class="keyword">double</span> mLng1 = <span class="number">121.46541700000000</span>; 	<span class="comment">// point1经度</span></span><br><span class="line">		<span class="keyword">double</span> mLat2 = <span class="number">31.239946</span>;	<span class="comment">// point2纬度</span></span><br><span class="line">		<span class="keyword">double</span> mLng2 = <span class="number">121.466417</span>;	<span class="comment">// point2经度</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">double</span> distanceByShort = getShortDistance(mLng1, mLat1, mLng2, mLat2);</span><br><span class="line">		System.out.println(distanceByShort);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">double</span> distanceByLong = getLongDistance(mLng1, mLat1, mLng2, mLat2);</span><br><span class="line">		System.out.println(distanceByLong);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用SqlServer函数计算">使用SqlServer函数计算</h2><p>其他数据库版本请找到相应的函数替换后移植</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">-- =============================================</span><br><span class="line">-- Author:      liuxing</span><br><span class="line">-- Create date: 2013-09-10</span><br><span class="line">-- Description:	计算2个坐标点的距离（短距离计算）</span><br><span class="line">-- =============================================</span><br><span class="line">CREATE function dbo.fn_getShortDistance(</span><br><span class="line">	 @lng1 decimal(19,11)</span><br><span class="line">	,@lat1 decimal(19,11)</span><br><span class="line">	,@lng2 decimal(19,11)</span><br><span class="line">	,@lat2 decimal(19,11)</span><br><span class="line">)</span><br><span class="line">returns decimal(19,11)</span><br><span class="line">AS</span><br><span class="line">BEGIN</span><br><span class="line">	--declare @lng1 decimal(19,11)</span><br><span class="line">	--declare @lat1 decimal(19,11)</span><br><span class="line">	--declare @lng2 decimal(19,11)</span><br><span class="line">	--declare @lat2 decimal(19,11)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	--set @lat1 = 31.238662--; 	// point1纬度</span><br><span class="line">	--set @lng1 = 121.466633--; // point1经度</span><br><span class="line">	--set @lat2 = 31.239727--;	// point2纬度</span><br><span class="line">	--set @lng2 = 121.462745--;	// point2经度</span><br><span class="line">	declare @ew1 decimal(19,11)</span><br><span class="line">		, @ns1 decimal(19,11)</span><br><span class="line">		, @ew2 decimal(19,11)</span><br><span class="line">		, @ns2 decimal(19,11)</span><br><span class="line">		, @dx decimal(19,11)</span><br><span class="line">		, @dy decimal(19,11)</span><br><span class="line">		, @dew decimal(19,11)</span><br><span class="line">		, @distance decimal(19,11)</span><br><span class="line">	-- 角度转换为弧度</span><br><span class="line">	set @ew1 = Radians(@lng1)-- * 0.01745329252;</span><br><span class="line">	set @ns1 = Radians(@lat1)-- * 0.01745329252;</span><br><span class="line">	set @ew2 = Radians(@lng2)-- * 0.01745329252;</span><br><span class="line">	set @ns2 = Radians(@lat2)-- * 0.01745329252;</span><br><span class="line">	-- 经度差</span><br><span class="line">	set @dew = @ew1 - @ew2;</span><br><span class="line">	-- 若跨东经和西经180 度，进行调整</span><br><span class="line">	if (@dew &gt; Pi())</span><br><span class="line">	begin</span><br><span class="line">		set @dew = 2 * Pi() - @dew;</span><br><span class="line">	end</span><br><span class="line">	else if (@dew &lt; -Pi())</span><br><span class="line">	begin</span><br><span class="line">		set @dew = 2 * Pi() + @dew;</span><br><span class="line">	end</span><br><span class="line">		</span><br><span class="line">	set @dx = 6370693.5 * Cos(@ns1) * @dew -- 东西方向长度(在纬度圈上的投影长度)</span><br><span class="line">	set @dy = 6370693.5 * (@ns1 - @ns2)   -- 南北方向长度(在经度圈上的投影长度)</span><br><span class="line">	-- 勾股定理求斜边长,开平方根</span><br><span class="line">	set @distance = sqrt(@dx * @dx + @dy * @dy);</span><br><span class="line">	return @distance;</span><br><span class="line">	--print @distance</span><br><span class="line">END</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="使用Java进行计算">使用Java进行计算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">]]>
    </summary>
    
      <category term="地图" scheme="http://liuxing.info/tags/%E5%9C%B0%E5%9B%BE/"/>
    
      <category term="坐标运算" scheme="http://liuxing.info/tags/%E5%9D%90%E6%A0%87%E8%BF%90%E7%AE%97/"/>
    
      <category term="距离" scheme="http://liuxing.info/tags/%E8%B7%9D%E7%A6%BB/"/>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java Websocket实例]]></title>
    <link href="http://liuxing.info/2015/02/09/websocket-demo/"/>
    <id>http://liuxing.info/2015/02/09/websocket-demo/</id>
    <published>2015-02-09T15:33:56.000Z</published>
    <updated>2015-06-16T13:47:13.000Z</updated>
    <content type="html"><![CDATA[<p>记录下自己在用的websocket</p>
<h2 id="介绍">介绍</h2><p>现在很多网站为了实现即时通讯，所用的技术都是轮询(polling)。轮询是在特定的的时间间隔（如每1秒），<br>由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客服端的浏览器。<br>这种传统的HTTP request 的模式带来很明显的缺点 – 浏览器需要不断的向服务器发出请求，<br>然而HTTP request 的header是非常长的，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽。</p>
<p>而最比较新的技术去做轮询的效果是Comet – 用了AJAX。但这种技术虽然可达到全双工通信，但依然需要发出请求。</p>
<p>在 WebSocket API，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>
<h2 id="运行环境：">运行环境：</h2><h3 id="客户端">客户端</h3><p>实现了websocket的浏览器</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Chrome</td>
<td style="text-align:left">Supported in version 4+</td>
</tr>
<tr>
<td style="text-align:left">Firefox</td>
<td style="text-align:left">Supported in version 4+</td>
</tr>
<tr>
<td style="text-align:left">Internet Explorer</td>
<td style="text-align:left">Supported in version 10+</td>
</tr>
<tr>
<td style="text-align:left">Opera</td>
<td style="text-align:left">Supported in version 10+</td>
</tr>
<tr>
<td style="text-align:left">Safari</td>
<td style="text-align:left">Supported in version 5+</td>
</tr>
</tbody>
</table>
<h3 id="服务端">服务端</h3><h4 id="依赖">依赖</h4><p>Tomcat 7.0.47以上 + J2EE7</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>tomcat-websocket-api<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>7.0.47<span class="tag">&lt;/<span class="title">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>javax<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>javaee-api<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>7.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：早前业界没有统一的标准，各服务器都有各自的实现，现在J2EE7的JSR356已经定义了统一的标准，请尽量使用支持最新通用标准的服务器。</p>
<p>详见：<br><a href="http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html" target="_blank" rel="external">http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html</a><br><a href="http://jinnianshilongnian.iteye.com/blog/1909962" target="_blank" rel="external">http://jinnianshilongnian.iteye.com/blog/1909962</a></p>
<p>我是用的Tomcat 7.0.57 + Java7<br>必须是Tomcat 7.0.47以上<br>详见：<a href="http://www.iteye.com/news/28414" target="_blank" rel="external">http://www.iteye.com/news/28414</a></p>
<p>ps：最早我们是用的Tomcat 7自带的实现，后来要升级Tomcat 8，结果原来的实现方式在Tomcat 8不支持了，就只好切换到支持Websocket 1.0版本的Tomcat了。</p>
<p>主流的java web服务器都有支持JSR365标准的版本了，请自行Google。 </p>
<p>用nginx做反向代理的需要注意啦，socket请求需要做特殊配置的，切记！</p>
<p>Tomcat的处理方式建议修改为NIO的方式，同时修改连接数到合适的参数，请自行Google！</p>
<p>服务端不需要在web.xml中做额外的配置，Tomcat启动后就可以直接连接了。</p>
<h4 id="实现">实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.dooioo.websocket.utils.SessionUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.PathParam;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 功能说明：websocket处理类, 使用J2EE7的标准</span><br><span class="line"> *         切忌直接在该连接处理类中加入业务处理代码</span><br><span class="line"> * 作者：liuxing(2014-11-14 04:20)</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">//relationId和userCode是我的业务标识参数,websocket.ws是连接的路径，可以自行定义</span></span><br><span class="line"><span class="annotation">@ServerEndpoint</span>(<span class="string">"/websocket.ws/&#123;relationId&#125;/&#123;userCode&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebsocketEndPoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Log log = LogFactory.getLog(WebsocketEndPoint.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 打开连接时触发</span><br><span class="line">     * <span class="doctag">@param</span> relationId</span><br><span class="line">     * <span class="doctag">@param</span> userCode</span><br><span class="line">     * <span class="doctag">@param</span> session</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(@PathParam(<span class="string">"relationId"</span>)</span> String relationId,</span><br><span class="line">                       @<span class="title">PathParam</span><span class="params">(<span class="string">"userCode"</span>)</span> <span class="keyword">int</span> userCode,</span><br><span class="line">                       Session session)</span>&#123;</span><br><span class="line">        log.info(<span class="string">"Websocket Start Connecting: "</span> + SessionUtils.getKey(relationId, userCode));</span><br><span class="line">        SessionUtils.put(relationId, userCode, session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 收到客户端消息时触发</span><br><span class="line">     * <span class="doctag">@param</span> relationId</span><br><span class="line">     * <span class="doctag">@param</span> userCode</span><br><span class="line">     * <span class="doctag">@param</span> message</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">onMessage</span><span class="params">(@PathParam(<span class="string">"relationId"</span>)</span> String relationId,</span><br><span class="line">                            @<span class="title">PathParam</span><span class="params">(<span class="string">"userCode"</span>)</span> <span class="keyword">int</span> userCode,</span><br><span class="line">                            String message) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Got your message ("</span> + message + <span class="string">").Thanks !"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 异常时触发</span><br><span class="line">     * <span class="doctag">@param</span> relationId</span><br><span class="line">     * <span class="doctag">@param</span> userCode</span><br><span class="line">     * <span class="doctag">@param</span> session</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@PathParam(<span class="string">"relationId"</span>)</span> String relationId,</span><br><span class="line">                        @<span class="title">PathParam</span><span class="params">(<span class="string">"userCode"</span>)</span> <span class="keyword">int</span> userCode,</span><br><span class="line">                        Throwable throwable,</span><br><span class="line">                        Session session) </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Websocket Connection Exception: "</span> + SessionUtils.getKey(relationId, userCode));</span><br><span class="line">        log.info(throwable.getMessage(), throwable);</span><br><span class="line">        SessionUtils.remove(relationId, userCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 关闭连接时触发</span><br><span class="line">     * <span class="doctag">@param</span> relationId</span><br><span class="line">     * <span class="doctag">@param</span> userCode</span><br><span class="line">     * <span class="doctag">@param</span> session</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(@PathParam(<span class="string">"relationId"</span>)</span> String relationId,</span><br><span class="line">                        @<span class="title">PathParam</span><span class="params">(<span class="string">"userCode"</span>)</span> <span class="keyword">int</span> userCode,</span><br><span class="line">                        Session session) </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Websocket Close Connection: "</span> + SessionUtils.getKey(relationId, userCode));</span><br><span class="line">        SessionUtils.remove(relationId, userCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工具类用来存储唯一key和连接</p>
<p>这个是我业务的需要，我的业务是服务器有对应动作触发时，推送数据到客户端，没有接收客户端数据的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 功能说明：用来存储业务定义的sessionId和连接的对应关系</span><br><span class="line"> *          利用业务逻辑中组装的sessionId获取有效连接后进行后续操作</span><br><span class="line"> * 作者：liuxing(2014-12-26 02:32)</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Session&gt; clients = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String relationId, <span class="keyword">int</span> userCode, Session session)</span></span>&#123;</span><br><span class="line">        clients.put(getKey(relationId, userCode), session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">get</span><span class="params">(String relationId, <span class="keyword">int</span> userCode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clients.get(getKey(relationId, userCode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String relationId, <span class="keyword">int</span> userCode)</span></span>&#123;</span><br><span class="line">        clients.remove(getKey(relationId, userCode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 判断是否有连接</span><br><span class="line">     * <span class="doctag">@param</span> relationId</span><br><span class="line">     * <span class="doctag">@param</span> userCode</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasConnection</span><span class="params">(String relationId, <span class="keyword">int</span> userCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clients.containsKey(getKey(relationId, userCode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 组装唯一识别的key</span><br><span class="line">     * <span class="doctag">@param</span> relationId</span><br><span class="line">     * <span class="doctag">@param</span> userCode</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String relationId, <span class="keyword">int</span> userCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> relationId + <span class="string">"_"</span> + userCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推送数据到客户端</p>
<p>在其他业务方法中调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 将数据传回客户端</span><br><span class="line"> * 异步的方式</span><br><span class="line"> * <span class="doctag">@param</span> relationId</span><br><span class="line"> * <span class="doctag">@param</span> userCode</span><br><span class="line"> * <span class="doctag">@param</span> message</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcast</span><span class="params">(String relationId, <span class="keyword">int</span> userCode, String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TelSocketSessionUtils.hasConnection(relationId, userCode)) &#123;</span><br><span class="line">        TelSocketSessionUtils.get(relationId, userCode).getAsyncRemote().sendText(message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(TelSocketSessionUtils.getKey(relationId, userCode) + <span class="string">" Connection does not exist"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我是使用异步的方法推送数据，还有同步的方法</p>
<p>详见：<a href="http://docs.oracle.com/javaee/7/api/javax/websocket/Session.html" target="_blank" rel="external">http://docs.oracle.com/javaee/7/api/javax/websocket/Session.html</a></p>
<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">var webSocket = <span class="keyword">null</span>;</span><br><span class="line">var tryTime = <span class="number">0</span>;</span><br><span class="line">$(function () &#123;</span><br><span class="line">    initSocket();</span><br><span class="line"></span><br><span class="line">    window.onbeforeunload = function () &#123;</span><br><span class="line">        <span class="comment">//离开页面时的其他操作</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 初始化websocket，建立连接</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">function <span class="title">initSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!window.WebSocket) &#123;</span><br><span class="line">        alert(<span class="string">"您的浏览器不支持websocket！"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    webSocket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:8080/websocket.ws/"</span> + relationId + <span class="string">"/"</span> + userCode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收到服务端消息</span></span><br><span class="line">    webSocket.onmessage = function (msg) &#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    webSocket.onerror = function (event) &#123;</span><br><span class="line">        console.log(event);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    webSocket.onopen = function (event) &#123;</span><br><span class="line">        console.log(event);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断线重连</span></span><br><span class="line">    webSocket.onclose = function () &#123;</span><br><span class="line">        <span class="comment">// 重试10次，每次之间间隔10秒</span></span><br><span class="line">        <span class="keyword">if</span> (tryTime &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                webSocket = <span class="keyword">null</span>;</span><br><span class="line">                tryTime++;</span><br><span class="line">                initSocket();</span><br><span class="line">            &#125;, <span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tryTime = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他调试工具</p>
<p>Java实现一个websocket的客户端</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.java-websocket<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>Java-WebSocket<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">import</span> javax.websocket.ClientEndpoint;  </span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnError;  </span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnMessage;  </span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnOpen;  </span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;  </span><br><span class="line">   </span><br><span class="line"><span class="annotation">@ClientEndpoint</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@OnOpen</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Connected to endpoint: "</span> + session.getBasicRemote());  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            session.getBasicRemote().sendText(<span class="string">"Hello"</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@OnMessage</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message)</span> </span>&#123;  </span><br><span class="line">        System.out.println(message);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@OnError</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;  </span><br><span class="line">        t.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;  </span><br><span class="line"><span class="keyword">import</span> java.net.URI;  </span><br><span class="line"><span class="keyword">import</span> javax.websocket.ContainerProvider;  </span><br><span class="line"><span class="keyword">import</span> javax.websocket.DeploymentException;  </span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;  </span><br><span class="line"><span class="keyword">import</span> javax.websocket.WebSocketContainer;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientApp</span> </span>&#123;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> Session session;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span>  </span><br><span class="line">             </span>&#123;  </span><br><span class="line">   </span><br><span class="line">            WebSocketContainer container = ContainerProvider.getWebSocketContainer();  </span><br><span class="line">   </span><br><span class="line">            String uri = <span class="string">"ws://127.0.0.1:8080/websocket.ws/relationId/12345"</span>;  </span><br><span class="line">            System.out.println(<span class="string">"Connecting to "</span> + uri);  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                session = container.connectToServer(MyClient.class, URI.create(uri));  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (DeploymentException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;               </span><br><span class="line">   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        MyClientApp client = <span class="keyword">new</span> MyClientApp();  </span><br><span class="line">        client.start();  </span><br><span class="line">   </span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));  </span><br><span class="line">        String input = <span class="string">""</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            do&#123;  </span><br><span class="line">                input = br.readLine();  </span><br><span class="line">                <span class="keyword">if</span>(!input.equals(<span class="string">"exit"</span>))  </span><br><span class="line">                    client.session.getBasicRemote().sendText(input);  </span><br><span class="line">   </span><br><span class="line">            &#125;<span class="keyword">while</span>(!input.equals(<span class="string">"exit"</span>));  </span><br><span class="line">   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span> Auto-generated catch block  </span></span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chrome安装一个websocket客户端调试 </p>
<p><img src="/images/websocket-01.png" alt="websocket-01"></p>
<p>最后</p>
<p>为了统一的操作体验，对于一些不支持websocket的浏览器，请使用socketjs技术做客户端开发。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记录下自己在用的websocket</p>
<h2 id="介绍">介绍</h2><p>现在很多网站为了实现即时通讯，所用的技术都是轮询(polling)。轮询是在特定的的时间间隔（如每1秒），<br>由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据]]>
    </summary>
    
      <category term="websocket" scheme="http://liuxing.info/tags/websocket/"/>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jquery常用选择器]]></title>
    <link href="http://liuxing.info/2015/02/01/jquery%E5%B8%B8%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://liuxing.info/2015/02/01/jquery常用选择器/</id>
    <published>2015-01-31T16:00:00.000Z</published>
    <updated>2015-06-16T13:06:06.000Z</updated>
    <content type="html"><![CDATA[<p>记录一下</p>
<h2 id="选择器">选择器</h2><h3 id="基本选择器">基本选择器</h3><p> <code>#</code>id —— 根据指定的id匹配一个元素<br> element —— 根据“元素名”匹配元素<br> .class —— 根据指定的“类名”匹配元素<br> selector1,selector2,selector3… —— 组合选择器，为并集关系</p>
<ul>
<li>—— 通用选择器， 匹配所有元素</li>
</ul>
<h3 id="层次选择器">层次选择器</h3><p> $(‘ancestor descendant’) —— 匹配ancestor下的所有descendant元素， 包括子孙节点<br> $(‘parent &gt; child’) —— 匹配parent下的所有child元素， 注意child为parent的直接子节点， 即不包含子孙节点<br> $(‘prev + next’) —— 匹配pre元素后的next元素<br> $(‘prev~siblings’) —— 匹配prev元素后的所有siblings元素</p>
<h3 id="基本过滤选择器（针对一个集合的操作，可以把这个集合想象成ArrayList）">基本过滤选择器（针对一个集合的操作，可以把这个集合想象成ArrayList）</h3><p> :first —— 选择第一个元素， 如$(‘div:first’)， 选择第一个div元素<br> :last —— 选择最后一个元素<br> :not(selector) —— 过滤掉所有与给定selector匹配的元素，如$(‘input:not(.myClass)’)选取class不是myClass的input元素<br> :even —— 选取索引是偶数的所有元素， 索引从0开始<br> :odd —— 选取索引是奇数的所有元素<br> :eq(index)  —— 选取索引是index的元素<br> :gt(index) —— 选取索引大于index的所有元素<br> :header —— 选取所有的标题元素，如h1,h2,h3等<br> :animated —— 选取当前正在进行动画的的所有元素</p>
<h3 id="子元素过滤器（父元素的第几个孩子，故在使用时都会以父元素作为上下文）">子元素过滤器（父元素的第几个孩子，故在使用时都会以父元素作为上下文）</h3><p> :nth-child —— 选取父元素的第几个孩子， 注意索引下标从1开始， 而:eq(index)是从0开始的<br> :nth-child(even) 选取父元素下索引值是偶数的子元素<br> :nth-child(odd) 选取父元素下索引值是奇数的子元素<br> :nth-child(index) 选取父元素下索引值为index的子元素<br> :nth-child(3n) 选取父元素下索引值是3的倍数的元素（n从0开始）<br> :nth-child(3n+1) 选取父元素下索引值是3n+1的元素 （n从0开始）<br> :first-child —— 父元素下的第一个孩子<br> :last-child —— 父元素下的最后一个孩子<br> :only-child —— 父元素下的唯一孩子（选中独生子）</p>
<h3 id="内容过滤选择器">内容过滤选择器</h3><p> :contains(text) —— 选取含有文本内容为”text”的元素<br> :empty —— 选取不包含子元素或文本的空元素<br> :has(selector) —— 选取含有选择器所匹配的元素的元素，如$(‘div:has(p)’)选取含有p元素的所有div元素<br> :parent —— 选取含有子元素或文本的元素，如$(‘div:parent’)选取拥有子元素或文本元素的所有div元素</p>
<h3 id="可见性过滤选择器">可见性过滤选择器</h3><p> :hidden ——  选取所有不可见元素，包括hidden， display:none，visibility:hidden元素，若只想选择input，则可用input:hidden<br> :visible —— 选取所有可见元素</p>
<h3 id="属性过滤选择器">属性过滤选择器</h3><p> [attribute] —— 选取拥有此属性的元素<br> [attribute=value] —— 选取属性值为value的元素<br> [attribute!=value] —— 选取属性值不等于value的元素<br> [attribute^=value] —— 选取属性值以value开头的元素<br> [attribute$=value] —— 选取属性值以vlue结尾的元素<br> [attribute*=value] —— 选取属性值包含value的元素<br> [selector1][selector2][selector3] —— 复合属性选择器，交集关系， 如$(“div[id][title$=’test’]”)选取拥有属性id，并且属性title以”test”结尾的div元素</p>
<h3 id="表单对象属性过滤器">表单对象属性过滤器</h3><p> :enabled —— 选取所有可用元素<br> :disabled —— 选取所有不可用元素<br> :checked —— 选取所有被选中的元素（单选和复选框）<br> :selected —— 选取所有被选中的select元素</p>
<h3 id="表单选择器">表单选择器</h3><p> :input —— 选取所有的input,textarea,select,button元素<br> :text —— 选取所有的单行文本<br> :password —— 选取所有的密码框<br> :radio —— 选取所有的单选按钮<br> :checkbox —— 选取所有的复选框<br> :submit —— 选取所有的提交按钮<br> :image —— 选取所有的图像按钮<br> :reset —— 选取所有的重置按钮<br> :button —— 选取所有的按钮<br> :file —— 选取所有的上传文件域<br> :hidden —— 选取所拥有不可见元素</p>
<h2 id="更多">更多</h2><p> 更多语法参阅API文档</p>
<p> <a href="http://jquery.cuishifeng.cn" target="_blank" rel="external">http://jquery.cuishifeng.cn</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记录一下</p>
<h2 id="选择器">选择器</h2><h3 id="基本选择器">基本选择器</h3><p> <code>#</code>id —— 根据指定的id匹配一个元素<br> element —— 根据“元素名”匹配元素<br> .class —— 根据指]]>
    </summary>
    
      <category term="jquery" scheme="http://liuxing.info/tags/jquery/"/>
    
      <category term="前端" scheme="http://liuxing.info/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>