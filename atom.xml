<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuxing&#39;s blog</title>
  
  <subtitle>青春须早为,岂能长少年！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liuxing.info/"/>
  <updated>2019-07-03T01:02:13.088Z</updated>
  <id>http://liuxing.info/</id>
  
  <author>
    <name>liuxing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HttpClient参数配置</title>
    <link href="http://liuxing.info/2018/04/10/HttpClient%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"/>
    <id>http://liuxing.info/2018/04/10/HttpClient参数配置</id>
    <published>2018-04-10T10:00:00.000Z</published>
    <updated>2019-07-03T01:02:13.088Z</updated>
    
    <content type="html"><![CDATA[<p>HttpClient参数配置、HttpClient最佳实践</p><hr><h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p>参数配置项</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> okhttp3.*;</span><br><span class="line"><span class="keyword">import</span> okhttp3.internal.Util;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLContext;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.TrustManager;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OkHttpUtil</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuxing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@summary</span> OkHttpUtil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017-11-10 17:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpUtil</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(OkHttpUtil.class);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient client;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        OkHttpClient.Builder build = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                <span class="comment">// 失败后重试，默认true</span></span><br><span class="line">                .retryOnConnectionFailure(<span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">// 读取超时 默认 10秒</span></span><br><span class="line">                .readTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">// 写入超时 默认 10秒</span></span><br><span class="line">                .writeTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">// 连接超时 默认 10秒</span></span><br><span class="line">                .connectTimeout(<span class="number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">// 连接池 默认是ConnectionPool的构造设置</span></span><br><span class="line">                .connectionPool(<span class="keyword">new</span> ConnectionPool(<span class="number">100</span>, <span class="number">30</span>, TimeUnit.SECONDS))</span><br><span class="line">                <span class="comment">// 心跳时间 默认0，不检测</span></span><br><span class="line">                .pingInterval(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"> </span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">50</span>, <span class="number">200</span>, <span class="number">30</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 异步调度线程池</span></span><br><span class="line">        Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher(executor);</span><br><span class="line">        dispatcher.setMaxRequests(<span class="number">1000</span>);</span><br><span class="line">        dispatcher.setMaxRequestsPerHost(<span class="number">1000</span>);</span><br><span class="line"> </span><br><span class="line">        build.dispatcher(dispatcher);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// ssl</span></span><br><span class="line">        build.sslSocketFactory(createSSLSocketFactory(), <span class="keyword">new</span> TrustAllManager());</span><br><span class="line">        build.hostnameVerifier(<span class="keyword">new</span> TrustAllHostnameVerifier());</span><br><span class="line"> </span><br><span class="line">        client = build.build();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认信任所有的证书</span></span><br><span class="line"><span class="comment">     * TODO 最好加上证书认证，主流App都有自己的证书</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SSLSocketFactory <span class="title">createSSLSocketFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        SSLSocketFactory sSLSocketFactory = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SSLContext sc = SSLContext.getInstance(<span class="string">"TLS"</span>);</span><br><span class="line">            sc.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[]&#123;<span class="keyword">new</span> TrustAllManager()&#125;, <span class="keyword">new</span> SecureRandom());</span><br><span class="line">            sSLSocketFactory = sc.getSocketFactory();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> sSLSocketFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>常用配置项</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.http.client.ClientProtocolException;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.config.RequestConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpPost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ssl.TrustStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.entity.ContentType;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.entity.InputStreamEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.ssl.SSLContexts;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLContext;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.TrustManager;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.X509TrustManager;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.CertificateException;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HttpClientUtil</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuxing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@summary</span> HttpClientUtil</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017-12-01 14:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientUtil</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(HttpClientUtil.class);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CloseableHttpClient httpClient;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        HttpClientBuilder builder = HttpClients.custom();</span><br><span class="line">        builder.setConnectionTimeToLive(<span class="number">30L</span>, TimeUnit.SECONDS);</span><br><span class="line">        builder.setMaxConnTotal(<span class="number">1000</span>);</span><br><span class="line">        builder.setMaxConnPerRoute(<span class="number">1000</span>);</span><br><span class="line"> </span><br><span class="line">        builder.setRetryHandler(<span class="keyword">new</span> DefaultHttpRequestRetryHandler(<span class="number">2</span>, <span class="keyword">true</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 保持长连接配置，需要在头添加Keep-Alive</span></span><br><span class="line">        <span class="comment">// 该策略依赖响应头的Keep-Alive参数：如 Keep-Alive: timeout=5, max=100 单位秒</span></span><br><span class="line">        <span class="comment">// 否则则依赖ConnectionTimeToLive的设置</span></span><br><span class="line">        builder.setKeepAliveStrategy(DefaultConnectionKeepAliveStrategy.INSTANCE);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SSLContext sslContext = SSLContexts.custom().loadTrustMaterial(<span class="keyword">null</span>, (TrustStrategy) (chain, authType) -&gt; <span class="keyword">true</span>).build();</span><br><span class="line">            builder.setSSLContext(sslContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SSLContext sc = SSLContext.getInstance(<span class="string">"TLS"</span>);</span><br><span class="line">            sc.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[]&#123;<span class="keyword">new</span> TrustAllManager()&#125;, <span class="keyword">new</span> SecureRandom());</span><br><span class="line">            builder.setSSLContext(sc);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        RequestConfig requestConfig = RequestConfig.custom()</span><br><span class="line">                <span class="comment">// 读写超时</span></span><br><span class="line">                .setSocketTimeout(<span class="number">10000</span>)</span><br><span class="line">                <span class="comment">// 请求超时</span></span><br><span class="line">                .setConnectTimeout(<span class="number">10000</span>)</span><br><span class="line">                <span class="comment">// 从连接池中获取连接的时间，非请求时间</span></span><br><span class="line">                .setConnectionRequestTimeout(<span class="number">200</span>)</span><br><span class="line">                <span class="comment">// 最大重定向次数</span></span><br><span class="line">                .setMaxRedirects(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">// 自动gzip</span></span><br><span class="line">                .setContentCompressionEnabled(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line"> </span><br><span class="line">        builder.setDefaultRequestConfig(requestConfig);</span><br><span class="line"> </span><br><span class="line">        httpClient = builder.build();</span><br><span class="line"> </span><br><span class="line">        LOGGER.info(<span class="string">"requestConfig: &#123;&#125;"</span>, requestConfig.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CloseableHttpClient <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> httpClient;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信任所有证书</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> liuxing</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@summary</span> 信任所有证书</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2017-11-30 23:36</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrustAllManager</span> <span class="keyword">implements</span> <span class="title">X509TrustManager</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> X509Certificate[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><p>RestTemplate本质只是一个模板，具体的请求需要根据初始化配置的RequestFactory</p><p>从Spring 4.3.x开始，可以选择OkHttp、HttpClient、Netty</p><p>默认是使用Java URLConnection（未池化连接，不推荐使用）。</p><p>HttpClient、OkHttp、RestTemplate都只需要配置一个全局单例即可。</p><p>常用的超时时间配置5-10秒即可，最大并发连接500-1000，都默认开启的Gzip压缩</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以HttpClient为例</p><p><strong>maven引入jar包</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpmime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>普通的get请求</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通的get请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDoGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HttpGet httpGet = <span class="keyword">new</span> HttpGet(<span class="string">"https://www.baidu.com"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (CloseableHttpResponse response = client.execute(httpGet)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(response.getStatusLine().getStatusCode(), HttpStatus.SC_OK)) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">"GET 请求成功:\n &#123;&#125;"</span>, EntityUtils.toString(response.getEntity()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"GET 请求失败:\n &#123;&#125;"</span>, EntityUtils.toString(response.getEntity()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        httpGet.releaseConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>普通的表单请求</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通的表单请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDoPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HttpPost httpPost = <span class="keyword">new</span> HttpPost(<span class="string">"http://localhost:3000/api"</span>);</span><br><span class="line">    HttpEntity entity = EntityBuilder.create()</span><br><span class="line">            .setParameters(</span><br><span class="line">                    <span class="keyword">new</span> BasicNameValuePair(<span class="string">"errFlag"</span>, <span class="string">"false"</span>),</span><br><span class="line">                    <span class="keyword">new</span> BasicNameValuePair(<span class="string">"name"</span>, <span class="string">"xxx"</span>),</span><br><span class="line">                    <span class="keyword">new</span> BasicNameValuePair(<span class="string">"code"</span>, <span class="string">"123456"</span>)</span><br><span class="line">            )</span><br><span class="line">            .setContentType(ContentType.create(<span class="string">"application/x-www-form-urlencoded"</span>, <span class="string">"utf-8"</span>))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    httpPost.setEntity(entity);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (CloseableHttpResponse response = client.execute(httpPost)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(response.getStatusLine().getStatusCode(), HttpStatus.SC_OK)) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">"POST 请求成功:\n &#123;&#125;"</span>, EntityUtils.toString(response.getEntity()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"POST 请求失败:\n &#123;&#125;"</span>, EntityUtils.toString(response.getEntity()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        httpPost.releaseConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Json数据post请求</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * json数据post请求</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * put、delete、patch同post</span></span><br><span class="line"><span class="comment"> * 使用不同的method实现 <span class="doctag">@see</span> &#123;<span class="doctag">@link</span> org.apache.http.client.methods.HttpEntityEnclosingRequestBase&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDoJsonPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    params.put(<span class="string">"name"</span>, <span class="string">"xxx"</span>);</span><br><span class="line">    params.put(<span class="string">"code"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    params.put(<span class="string">"errFlag"</span>, <span class="string">"false"</span>);</span><br><span class="line"></span><br><span class="line">    HttpPost httpPost = <span class="keyword">new</span> HttpPost(<span class="string">"http://localhost:3000/api"</span>);</span><br><span class="line">    HttpEntity entity = EntityBuilder.create()</span><br><span class="line">            .setText(JSON.toJSONString(params))</span><br><span class="line">            .setContentType(ContentType.create(<span class="string">"application/json"</span>, <span class="string">"utf-8"</span>))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    httpPost.setEntity(entity);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (CloseableHttpResponse response = client.execute(httpPost)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(response.getStatusLine().getStatusCode(), HttpStatus.SC_OK)) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">"POST JSON 请求成功:\n &#123;&#125;"</span>, EntityUtils.toString(response.getEntity()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"POST JSON 请求失败:\n &#123;&#125;"</span>, EntityUtils.toString(response.getEntity()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        httpPost.releaseConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HttpClient参数配置、HttpClient最佳实践&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;OkHttp&quot;&gt;&lt;a href=&quot;#OkHttp&quot; class=&quot;headerlink&quot; title=&quot;OkHttp&quot;&gt;&lt;/a&gt;OkHttp&lt;/h2&gt;&lt;p&gt;参数配置项&lt;/p&gt;
&lt;f
      
    
    </summary>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
    
      <category term="RestTemplate" scheme="http://liuxing.info/tags/RestTemplate/"/>
    
      <category term="httpClient" scheme="http://liuxing.info/tags/httpClient/"/>
    
      <category term="Spring" scheme="http://liuxing.info/tags/Spring/"/>
    
      <category term="OkHttp" scheme="http://liuxing.info/tags/OkHttp/"/>
    
      <category term="参数配置" scheme="http://liuxing.info/tags/%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/"/>
    
      <category term="最佳实践" scheme="http://liuxing.info/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Spring AMQP中文文档</title>
    <link href="http://liuxing.info/2017/06/30/Spring%20AMQP%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3"/>
    <id>http://liuxing.info/2017/06/30/Spring AMQP中文文档</id>
    <published>2017-06-29T18:59:00.000Z</published>
    <updated>2019-07-02T01:06:43.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>Spring AMQP项目是用于开发AMQP的解决方案。 我们提供一个“模板”作为发送和接收消息的抽象。我们还为普通POJO进行提供消息处理支持。这些库促进AMQP资源的管理，同时支持使用依赖注入和声明式配置。 在所有情况下，您将看到与Spring Framework中的JMS支持的相似之处。有关其他项目相关信息，请访问Spring AMQP<a href="http://projects.spring.io/spring-amqp/" target="_blank" rel="noopener">项目主页</a>。</p><h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h2><p>该帮助文档的第一部分是Spring AMQP以及基本概念和一些代码段的概述，可以尽快帮助您快速使用。</p><h3 id="2-1-快速入门"><a href="#2-1-快速入门" class="headerlink" title="2.1 快速入门"></a>2.1 快速入门</h3><h4 id="2-1-1-介绍"><a href="#2-1-1-介绍" class="headerlink" title="2.1.1 介绍"></a>2.1.1 介绍</h4><p>五分钟快速使用Spring AMQP.</p><p>先决条件：安装并运行<a href="http://www.rabbitmq.com/download.html" target="_blank" rel="noopener">RabbitMQ</a>。然后在您的项目中加入如下MAVEN依赖:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h5><p>虽然默认的<code>Spring Framework</code>版本依赖关系为4.3.x，但<code>Spring AMQP</code>通常与早期版本的<code>Spring Framework</code>兼容。<br>基于注解的监听器和<code>RabbitMessagingTemplate</code>需要<code>Spring Framework 4.1</code>或更高版本。</p><p>最低的<code>amqp-client</code>的java客户端库版本是4.0.0。</p><p>注意这是指java客户端库;<br>一般来说，它将适用于较旧的代理版本。</p><h5 id="非常非常快"><a href="#非常非常快" class="headerlink" title="非常非常快"></a>非常非常快</h5><p>使用简单同步的Java发送和接收消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">AmqpAdmin admin = <span class="keyword">new</span> RabbitAdmin(connectionFactory);</span><br><span class="line">admin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">"myqueue"</span>));</span><br><span class="line">AmqpTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">template.convertAndSend(<span class="string">"myqueue"</span>, <span class="string">"foo"</span>);</span><br><span class="line">String foo = (String) template.receiveAndConvert(<span class="string">"myqueue"</span>);</span><br></pre></td></tr></table></figure><p>请注意，Java Rabbit客户端中也有一个<code>ConnectionFactory</code>。<br>我们在上面的代码中使用了Spring抽象的<code>ConnectionFactory</code>。<br>我们使用Rabbit的默认<code>exchange</code>(因为发送中没有指定)，并且所有队列默认绑定到默认<code>exchange</code>(因此我们可以在发送中使用队列名称作为<code>routing key</code>)。<br>这些行为在AMQP规范中定义。</p><h5 id="使用XML配置"><a href="#使用XML配置" class="headerlink" title="使用XML配置"></a>使用XML配置</h5><p>上述例子在XML中的配置形式如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">"http://www.springframework.org/schema/rabbit"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/rabbit/spring-rabbit.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"amqpTemplate"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"myqueue"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context =</span><br><span class="line">    <span class="keyword">new</span> GenericXmlApplicationContext(<span class="string">"classpath:/rabbit-context.xml"</span>);</span><br><span class="line">AmqpTemplate template = context.getBean(AmqpTemplate.class);</span><br><span class="line">template.convertAndSend(<span class="string">"myqueue"</span>, <span class="string">"foo"</span>);</span><br><span class="line">String foo = (String) template.receiveAndConvert(<span class="string">"myqueue"</span>);</span><br></pre></td></tr></table></figure><p>默认情况下，<code>&lt;rabbit:admin /&gt;</code>声明会自动查找类型为<code>Queue</code>，<code>Exchange</code>和<code>Binding</code>的bean，并将他们绑定，因此不需要在简单的Java程序中明确使用该bean。在XML模式中配置组件的属性有很多选项 - 您可以使用XML编辑器的自动完成功能来浏览它们并查看其文档。</p><h5 id="使用java配置"><a href="#使用java配置" class="headerlink" title="使用java配置"></a>使用java配置</h5><p>相同的代码在java代码中的另一种配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context =</span><br><span class="line">    <span class="keyword">new</span> AnnotationConfigApplicationContext(RabbitConfiguration.class);</span><br><span class="line">AmqpTemplate template = context.getBean(AmqpTemplate.class);</span><br><span class="line">template.convertAndSend(<span class="string">"myqueue"</span>, <span class="string">"foo"</span>);</span><br><span class="line">String foo = (String) template.receiveAndConvert(<span class="string">"myqueue"</span>);</span><br><span class="line"></span><br><span class="line">........</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CachingConnectionFactory(<span class="string">"localhost"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AmqpAdmin <span class="title">amqpAdmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RabbitAdmin(connectionFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">myQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"myqueue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-新特性"><a href="#2-2-新特性" class="headerlink" title="2.2 新特性"></a>2.2 新特性</h3><p>参考<a href="http://docs.spring.io/spring-amqp/reference/htmlsingle/#whats-new" target="_blank" rel="noopener">http://docs.spring.io/spring-amqp/reference/htmlsingle/#whats-new</a></p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3.参考"></a>3.参考</h2><p>帮助文档的一部分详细介绍了Spring AMQP的各种组件。<br>主要章节介绍开发AMQP应用程序的核心教程。<br>本部分还包括有关示例应用程序。</p><h3 id="3-1-使用Spring-AMQP"><a href="#3-1-使用Spring-AMQP" class="headerlink" title="3.1 使用Spring AMQP"></a>3.1 使用Spring AMQP</h3><p>在本章中，我们将探讨使用Spring AMQP开发应用程序的基本组件的接口和类。</p><h4 id="3-1-1-AMQP抽象"><a href="#3-1-1-AMQP抽象" class="headerlink" title="3.1.1 AMQP抽象"></a>3.1.1 AMQP抽象</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>Spring AMQP由几个模块组成，每个模块由发布中的JAR表示。这些模块有：spring-amqp和spring-rabbit。 spring-amqp模块包含<code>org.springframework.amqp.core</code>心 AMQP”model”的类。我们的目的是提供不依赖于任何特定AMQP代理实现或客户端库的泛型抽象。最终用户代码在供应商实现中将更加便携，因为它只能针对抽象层进行开发。这些抽象然后由代理特定的模块实现，例如spring-rabbit。目前只有一个RabbitMQ实现;但是除了RabbitMQ之外，使用Apache Qpid的.NET中的抽象已被验证。由于AMQP原则上在协议级别运行，所以RabbitMQ客户端可以与支持相同协议版本的任何代理一起使用，但目前我们还没有测试任何其他代理。</p><p>这里的概述假设您已经熟悉AMQP规范的基础知识。如果没有，请查看第5章“其他资源”中列出的资源。</p><h5 id="Message-消息体"><a href="#Message-消息体" class="headerlink" title="Message(消息体)"></a>Message(消息体)</h5><p>0-8和0-9-1 AMQP规范不定义Message类或接口。<br>相反，当执行诸如basicPublish()的操作时，内容作为字节数组参数传递，并且附加属性作为单独的参数传入。<br>Spring AMQP将Message类定义为更普通的AMQP域模型。<br>Message类的目的是简单地将主体和属性封装在单个实例中，以便API可以更简单。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageProperties messageProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">byte</span>[] body, MessageProperties messageProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.body = body;</span><br><span class="line">        <span class="keyword">this</span>.messageProperties = messageProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBody() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageProperties <span class="title">getMessageProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.messageProperties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageProperties接口定义了几个常见的属性，如messageId，timestamp，contentType等等。<br>这些属性也可以通过调用setHeader(String key，Object value)方法来扩展用户定义的头属性。</p><h5 id="exchange-交换机"><a href="#exchange-交换机" class="headerlink" title="exchange(交换机)"></a>exchange(交换机)</h5><p>Exchange接口表示AMQP Exchange，这是消息生产者发送到的。<br>代理的虚拟主机中的每个Exchange将具有唯一的名称以及一些其他属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Exchange</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getExchangeType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDurable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoDelete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getArguments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，Exchange还具有由ExchangeTypes中定义的常量表示的类型。<br>基本类型有：Direct, Topic, Fanout, 和 Headers。<br>在核心包中，您将找到每种类型的Exchange接口的实现。<br>这些Exchange类型的行为在如何处理与队列绑定方面有所不同。<br>例如，Direct exchange允许队列被固定的routing key(通常是队列的名称)绑定。<br>Topic exchange支持绑定与路由模式，可能包括<code>*</code>和<code>#</code>通配符</p><blockquote><p>AMQP规范还要求任何代理提供没有名称的“默认”Exchange。<br>所有被声明的队列将被绑定到该默认的Exchange名称作为routing key。<br>您将在3.1.4节“AmqpTemplate”中了解Spring AMQP中默认Exchange的使用情况。</p></blockquote><h5 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue(队列)"></a>Queue(队列)</h5><p>Queue类表示消息使用者接收消息的组件。<br>像各种Exchange类一样，我们的实现意图是这个核心AMQP类型的抽象表示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> durable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exclusive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> autoDelete;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; arguments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列是持久的，非排他的和非自动删除的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 队列名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters omitted for brevity</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，构造函数采用队列名称。根据实现，管理模板可以提供用于生成唯一命名的队列的方法。这样的队列可以用作<code>reply-to</code>地址或其他临时情况。因此，自动生成的队列的exclusive和autoDelete属性都将设置为true。</p><blockquote><p>有关使用命名空间支持(包括队列参数)声明队列的信息，请参见第3.1.10节“配置代理”中的队列部分。</p></blockquote><h5 id="Binding-绑定"><a href="#Binding-绑定" class="headerlink" title="Binding(绑定)"></a>Binding(绑定)</h5><p>鉴于生产者发送到Exchange并且消费者从队列接收到消息，将队列连接到exchange的绑定对于通过消息传递连接这些生产者和消费者至关重要。<br>在Spring AMQP中，我们定义一个Binding类来表示这些连接。<br>我们来看看将队列绑定到交换机的基本选项。</p><p>您可以使用固定的routing key将队列绑定到DirectExchange。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Binding(someQueue, someDirectExchange, <span class="string">"foo.bar"</span>)</span><br></pre></td></tr></table></figure><p>您可以使用路由模式将队列绑定到TopicExchange。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Binding(someQueue, someTopicExchange, <span class="string">"foo.*"</span>)</span><br></pre></td></tr></table></figure><p>您可以使用无routing key将Queue绑定到FanoutExchange。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Binding(someQueue, someFanoutExchange)</span><br></pre></td></tr></table></figure><p>我们还提供了一个BindingBuilder进行链式风格的构建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Binding b = BindingBuilder.bind(someQueue).to(someTopicExchange).with(<span class="string">"foo.*"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>为了清楚起见，上面显示了BindingBuilder类，但是对于bind()方法使用静态导入时，此样式很好。</p></blockquote><p>Binding类的一个实例本身就是持有关于连接的数据。<br>换句话说，它不是一个“活跃”组件。<br>但是，正如您将在3.1.10节“配置代理”中看到的，AmqpAdmin类可以使用Binding实例来实际触发代理上的绑定操作。<br>另外，正如你将在同一部分中看到的，Binding实例可以使用@Configuration类中的Spring的@ Bean风格进行定义。<br>还有一个方便的基类，它进一步简化了生成AMQP相关bean定义的方法，并识别队列，交换和绑定，以便在应用程序启动时将它们全部声明在AMQP代理上。</p><p>AmqpTemplate也在核心包中定义。作为实际AMQP消息传递中涉及的主要组件之一，将在其自己的部分中详细讨论(参见第3.1.4节“AmqpTemplate”)。</p><h4 id="3-1-2连接和资源管理"><a href="#3-1-2连接和资源管理" class="headerlink" title="3.1.2连接和资源管理"></a>3.1.2连接和资源管理</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>我们上一节描述的AMQP模型是通用的，适用于所有实现，当我们进入资源管理时，特定的场景需要特殊实现。因此，在本节中，我们将专注于仅存在于我们的“spring-rabbit”模块中的代码，因为在这一点上，RabbitMQ是唯一支持的实现。</p><p>用于管理与RabbitMQ代理的连接的中心组件是<code>ConnectionFactory</code>接口。 <code>ConnectionFactory</code>实现的责任是提供一个<code>org.springframework.amqp.rabbit.connection.Connection</code>的实例，它是<code>com.rabbitmq.client.Connection</code>的包装器。我们提供的唯一具体实现是<code>CachingConnectionFactory</code>，默认情况下，它建立可以由应用程序共享的单个连接代理。连接是共享的，因为与AMQP通信的“工作单位”实际上是一个“通道”(在某些方面，这与JMS中的连接和会话之间的关系类似)。您可以想像，连接实例提供了一个<code>createChannel</code>方法。 <code>CachingConnectionFactory</code>实现支持对这些通道的缓存，并且基于它们是否是事务来维护单独的通道高速缓存。创建<code>CachingConnectionFactory</code>实例时，可以通过构造函数提供主机名。还应提供用户名和密码属性。如果要配置通道缓存的大小(默认值为25)，您也可以在此处调用<code>setChannelCacheSize()</code>方法。</p><p>从1.3版开始，<code>CachingConnectionFactory</code>可以配置为缓存连接以及仅通道。<br>在这种情况下，每次调用<code>createConnection()</code>都会创建一个新的连接(或从缓存中检索一个空闲的连接)。<br>关闭连接将返回到缓存(如果尚未达到高速缓存大小)。<br>在这种连接上创建的通道也被缓存。<br>使用单独的连接在某些环境中可能是有用的，例如从HA群集中消耗负载均衡器连接到不同的群集成员。<br>将<code>cacheMode</code>设置为<code>CacheMode.CONNECTION</code>。</p><blockquote><p>这不限制连接数，它指定允许多少空闲打开连接。</p></blockquote><p>从版本1.5.5开始，提供了一个新的属性<code>connectionLimit</code>。当设置此项时，它限制允许的连接总数。设置后，如果达到限制，则使用<code>channelCheckoutTimeLimit</code>等待连接变为空闲状态。如果超过时间，则抛出<code>AmqpTimeoutException</code>。</p><blockquote><p>重要提示<br>    当缓存模式为CONNECTION时，不支持自动声明队列等(请参阅“自动声明交换，队列和绑定”一节)。<br>    此外，在编写本文时，rabbitmq-client库默认为每个连接创建一个固定的线程池(5个线程)。当使用大量连接时，应考虑在CachingConnectionFactory上设置自定义执行程序。然后，所有连接将使用相同的执行程序，并且可以共享它的线程。执行者的线程池应该是无限制的，或者针对预期的利用率进行适当设置(通常每个连接至少有一个线程)。如果在每个连接上创建多个通道，则池大小将影响并发性，因此变量(或简单的缓存)线程池执行器将是最合适的。</p></blockquote><p>重要的是要明白，缓存大小(默认情况下)不是限制，只是可以缓存的通道数。具有例如10的高速缓存大小，实际上可以使用任何数量的频道。如果正在使用10个以上的通道，并将它们全部返回到缓存，则10将进入高速缓存;其余部分将被物理关闭。</p><p>从版本1.6开始，默认通道缓存大小从1增加到25。在高容量，多线程环境中，小缓存意味着以高速率创建和关闭通道。增加默认缓存大小将避免这种开销。您应该通过RabbitMQ管理界面监视正在使用的频道，并考虑在创建和关闭许多通道时进一步增加高速缓存大小。缓存只会按需增长(以适应应用程序的并发需求)，因此此更改不会影响现有的低容量应用程序。</p><p>从版本1.4.2开始，<code>CachingConnectionFactory</code>具有一个属性<code>channelCheckoutTimeout</code>。当此属性大于零时，<code>channelCacheSiz</code>e将成为可在连接上创建的通道数量的限制。如果达到限制，调用线程将阻塞，直到通道可用或达到此超时，在这种情况下抛出一个<code>AmqpTimeoutException</code>。</p><blockquote><p>框架内使用的通道(例如RabbitTemplate)将可靠地返回到缓存。如果您在框架之外创建渠道(例如通过直接访问连接并调用createChannel())，则必须可靠地将其返回(通过关闭)，也许在finally块中，以避免使用通道。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory(<span class="string">"somehost"</span>);</span><br><span class="line">connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line"></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br></pre></td></tr></table></figure><p>使用XML时，配置可能如下所示：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.amqp.rabbit.connection.CachingConnectionFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"somehost"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"guest"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"guest"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>还有一个<code>SingleConnectionFactory</code>实现，仅在框架的单元测试代码中可用。它比<code>CachingConnectionFactory</code>简单，因为它不缓存通道，但是由于其缺乏性能和弹性，它不适用于简单测试之外的实际使用。如果您因为某些原因需要实现自己的<code>ConnectionFactory</code>，那么<code>AbstractConnectionFactory</code>基类可能会提供一个很好的起点。</p></blockquote><p>可以使用rabbit命名空间快速方便地创建ConnectionFactory：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在大多数情况下，这将是优先的，因为框架可以为您选择最佳默认值。创建的实例将是一个<code>CachingConnectionFactory</code>。请注意，通道的默认缓存大小为25.如果要更多通道被缓存，则通过channelCacheSize属性设置较大的值。在XML中，它将如下所示：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.amqp.rabbit.connection.CachingConnectionFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"somehost"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"guest"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"guest"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"channelCacheSize"</span> <span class="attr">value</span>=<span class="string">"50"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用命名空间，您只需添加channel-cache-size属性即可：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">channel-cache-size</span>=<span class="string">"50"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>默认缓存模式是CHANNEL，但您可以将其配置为缓存连接;在这种情况下，我们使用connection-cache-size：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">cache-mode</span>=<span class="string">"CONNECTION"</span> <span class="attr">connection-cache-size</span>=<span class="string">"25"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>可以使用命名空间设置主机和端口属性</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">host</span>=<span class="string">"somehost"</span> <span class="attr">port</span>=<span class="string">"5672"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或者，如果在群集环境中运行，请使用addresses属性。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">addresses</span>=<span class="string">"host1:5672,host2:5672"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这里有一个自定义线程工厂的例子，它使用rabbitmq-前缀线程名。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"multiHost"</span> <span class="attr">virtual-host</span>=<span class="string">"/bar"</span> <span class="attr">addresses</span>=<span class="string">"host1:1234,host2,host3:4567"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">thread-factory</span>=<span class="string">"tf"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">channel-cache-size</span>=<span class="string">"10"</span> <span class="attr">username</span>=<span class="string">"user"</span> <span class="attr">password</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tf"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.concurrent.CustomizableThreadFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"rabbitmq-"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从1.7版开始，提供了一个<code>ConnectionNameStrategy</code>，用于注入到<code>AbstractionConnectionFactory</code>中。生成的名称用于目标RabbitMQ连接的应用程序特定标识。如果RabbitMQ服务器支持，连接名称将显示在管理界面中。该值不必是唯一的，不能用作连接标识符，例如在HTTP API请求中。该值应该是人类可读的，并且是<code>connection_name</code>键下的<code>ClientProperties</code>的一部分。可以用作简单的Lambda：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connectionFactory.setConnectionNameStrategy(connectionFactory -&gt; <span class="string">"MY_CONNECTION"</span>);</span><br></pre></td></tr></table></figure><p><code>ConnectionFactory</code>参数可以用来区分目标连接名称一些逻辑。默认情况下，使用<code>AbstractConnectionFactory</code>的<code>beanName</code>和内部计数器来生成<code>connection_name</code>。<code>&lt;rabbit:connection-factory&gt;</code>命名空间组件也提供了<code>connection-name-strategy</code>属性。</p><h5 id="配置底层客户端连接工厂"><a href="#配置底层客户端连接工厂" class="headerlink" title="配置底层客户端连接工厂"></a>配置底层客户端连接工厂</h5><p><code>CachingConnectionFactory</code>使用Rabbit客户端<code>ConnectionFactory</code>的实例;当设置<code>CachingConnectionFactory</code>上的等效属性时，会传递一些配置属性(例如，<code>host</code>，<code>port</code>，<code>userName</code>，<code>password</code>，<code>requestedHeartBeat</code>，<code>connectionTimeout</code>)。要设置其他属性(例如<code>clientProperties</code>)，请定义 rabbit factory的实例，并使用适当的<code>CachingConnectionFactory</code>构造函数提供对它的引用。当使用如上所述的命名空间时，在<code>connection-factory</code>属性中提供对配置工厂的引用。为方便起见，提供了一个工厂bean，以帮助在Spring应用程序环境中配置连接工厂，如下一节所述。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">connection-factory</span>=<span class="string">"rabbitConnectionFactory"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>4.0.x客户端默认启用自动恢复;与此功能兼容，Spring AMQP具有自己的恢复机制，并且通常不需要客户端恢复功能。建议禁用<code>amqp-client</code>自动恢复，以避免在代理可用时使<code>AutoRecoverConnectionNotCurrentlyOpenException</code>异常，但连接尚未恢复。您可能会注意到这种异常，例如，当<code>RabbitTemplate</code>中配置<code>RetryTemplate</code>时，即使在群集中的其他代理进行故障转移时也是如此。由于自动恢复连接在定时器上恢复，因此使用Spring AMQP的恢复机制可以更快地恢复连接。从版本1.7.1开始，除非您明确创建自己的RabbitMQ连接工厂并将其提供给<code>CachingConnectionFactory</code>，否则Spring AMQP将禁用它。由<code>RabbitConnectionFactoryBean</code>创建的<code>RabbitMQ ConnectionFactory</code>实例也将默认禁用该选项。</p></blockquote><h5 id="RabbitConnectionFactoryBean和配置SSL"><a href="#RabbitConnectionFactoryBean和配置SSL" class="headerlink" title="RabbitConnectionFactoryBean和配置SSL"></a>RabbitConnectionFactoryBean和配置SSL</h5><p>从版本1.4开始，提供了一个方便的<code>RabbitConnectionFactoryBean</code>，以便使用依赖注入在底层客户端连接工厂上方便地配置SSL属性。其他设置者只需委托给底层工厂。以前，您必须以编程方式配置SSL选项。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"rabbitConnectionFactory"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">connection-factory</span>=<span class="string">"clientConnectionFactory"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">host</span>=<span class="string">"$&#123;host&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">port</span>=<span class="string">"$&#123;port&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">virtual-host</span>=<span class="string">"$&#123;vhost&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">username</span>=<span class="string">"$&#123;username&#125;"</span> <span class="attr">password</span>=<span class="string">"$&#123;password&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientConnectionFactory"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.xd.dirt.integration.rabbit.RabbitConnectionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useSSL"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sslPropertiesLocation"</span> <span class="attr">value</span>=<span class="string">"file:/secrets/rabbitSSL.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有关配置SSL的信息，请参阅RabbitMQ文档。省略keyStore和trustStore配置以通过SSL连接，而无需证书验证。密钥和信任存储配置可以提供如下：</p><p><code>sslPropertiesLocation</code>属性是指向包含以下键的属性文件的Spring <code>Resource</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keyStore=file:/secret/keycert.p12</span><br><span class="line">trustStore=file:/secret/trustStore</span><br><span class="line">keyStore.passPhrase=secret</span><br><span class="line">trustStore.passPhrase=secret</span><br></pre></td></tr></table></figure><p><code>keyStore</code>和<code>truststore</code>是指向磁盘的Spring资源文件。通常，此属性文件将由操作系统保护，应用程序具有读访问权限。</p><p>从Spring AMQP版本1.5开始，这些属性可以直接在工厂bean上设置。如果提供了离散属性和<code>sslPropertiesLocation</code>，后者中的属性将覆盖离散值。</p><h5 id="路由连接工厂"><a href="#路由连接工厂" class="headerlink" title="路由连接工厂"></a>路由连接工厂</h5><p>从1.3版开始，引入了<code>AbstractRoutingConnectionFactory</code>。这提供了一种机制来为几个<code>ConnectionFactories</code>配置映射，并在运行时由某些<code>lookupKey</code>确定目标<code>ConnectionFactory</code>。通常，实现检查线程绑定的上下文。为了方便起见，Spring AMQP提供了<code>SimpleRoutingConnectionFactory</code>，它从<code>SimpleResourceHolder</code>获取当前线程绑定的<code>lookupKey</code>：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.amqp.rabbit.connection.SimpleRoutingConnectionFactory"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactories"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"#&#123;connectionFactory1.virtualHost&#125;"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"#&#123;connectionFactory2.virtualHost&#125;"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"template"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(String vHost, String payload)</span> </span>&#123;</span><br><span class="line">        SimpleResourceHolder.bind(rabbitTemplate.getConnectionFactory(), vHost);</span><br><span class="line">        rabbitTemplate.convertAndSend(payload);</span><br><span class="line">        SimpleResourceHolder.unbind(rabbitTemplate.getConnectionFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的是在使用后取消绑定资源。有关更多信息，请参阅<code>AbstractRoutingConnectionFactory</code>的JavaDocs。</p><p>从版本1.4开始，RabbitTemplate支持SpEL sendConnectionFactorySelectorExpression和receiveConnectionFactorySelectorExpression属性，它们在每个AMQP协议交互操作(send，sendAndReceive，receive或receiveAndReply)上进行评估，解析为所提供的AbstractRoutingConnectionFactory的lookupKey值。<br>Bean的引用,比如“@vHostResolver.getVHost(#root)”可以在表达式中使用。对于发送操作，要发送的消息是root评估对象;对于接收操作，queueName是root评估对象。</p><p>路由算法是：如果选择器表达式为空，或者被评估为null，或者所提供的ConnectionFactory不是AbstractRoutingConnectionFactory的一个实例，则一切都将如前所述，依赖于提供的ConnectionFactory实现。如果评估结果不为空，但是没有用于该lookupKey的目标ConnectionFactory，并且使用lenientFallback = true配置AbstractRoutingConnectionFactory，则会发生相同的情况。当然，在一个AbstractRoutingConnectionFactory的情况下，它会基于determinCurrentLookupKey()来回溯到其路由实现。但是，如果lenientFallback = false，则会抛出IllegalStateException异常。</p><p>命名空间支持还在<code>&lt;rabbit:template&gt;</code>组件上提供<code>send-connection-factory-selector-expression</code>和<code>receive-connection-factory-selector-expression</code>属性。</p><p>从1.4版开始，您可以在监听器容器中配置路由连接工厂。在这种情况下，队列名称列表用作查找键。例如，如果使用setQueueNames(“foo”，“bar”)配置容器，则查找键将为“[foo，bar]”(无空格)。</p><p>从版本1.6.9开始，您可以在监听器容器上使用setLookupKeyQualifier添加限定符到查找键。例如，这可以使用相同名称监听队列，但是不可以在不同的虚拟主机中(每个队列中都有一个连接工厂)。</p><p>例如，使用查找键限定符foo和容器监听队列栏，您将注册目标连接工厂的查找键将为foo [bar]。</p><h5 id="Queue-Affinity和LocalizedQueueConnectionFactory"><a href="#Queue-Affinity和LocalizedQueueConnectionFactory" class="headerlink" title="Queue Affinity和LocalizedQueueConnectionFactory"></a>Queue Affinity和LocalizedQueueConnectionFactory</h5><p>在群集中使用HA队列时，为获得最佳性能，可能希望连接到主队列所在的物理代理。而CachingConnectionFactory可以配置多个代理地址;这是故障切换，客户端将尝试按顺序连接。 LocalizedQueueConnectionFactory使用由管理插件提供的REST API来确定哪个节点已被掌握。然后，它将创建(或从缓存中检索)将连接到该节点的CachingConnectionFactory。如果连接失败，则确定新的主节点，并且消费者连接到它。 LocalizedQueueConnectionFactory配置了默认连接工厂，以防无法确定队列的物理位置，在这种情况下，它将正常连接到集群。</p><p>LocalizedQueueConnectionFactory是一个RoutingConnectionFactory，SimpleMessageListenerContainer使用队列名称作为查询键，如上面的“路由连接工厂”部分所述。</p><blockquote><p>由于这个原因(使用查询的队列名称)，只有当容器配置为监听单个队列时，才能使用LocalizedQueueConnectionFactory。</p></blockquote><blockquote><p>必须在每个节点上启用RabbitMQ管理插件。</p></blockquote><blockquote><p>警告<br>    此连接工厂用于长期连接，例如SimpleMessageListenerContainer使用的连接。它不用于短连接使用，例如使用RabbitTemplate，因为在进行连接之前调用REST API的开销。此外，对于发布操作，队列是未知的，并且消息也被发布到所有集群成员，所以查找节点的逻辑没有什么价值。</p></blockquote><p>以下是一个示例配置，使用Spring Boot的RabbitProperties配置工厂：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitProperties props;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] adminUris = &#123; <span class="string">"http://host1:15672"</span>, <span class="string">"http://host2:15672"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] nodes = &#123; <span class="string">"rabbit@host1"</span>, <span class="string">"rabbit@host2"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">defaultConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CachingConnectionFactory cf = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">    cf.setAddresses(<span class="keyword">this</span>.props.getAddresses());</span><br><span class="line">    cf.setUsername(<span class="keyword">this</span>.props.getUsername());</span><br><span class="line">    cf.setPassword(<span class="keyword">this</span>.props.getPassword());</span><br><span class="line">    cf.setVirtualHost(<span class="keyword">this</span>.props.getVirtualHost());</span><br><span class="line">    <span class="keyword">return</span> cf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">queueAffinityCF</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Qualifier(<span class="string">"defaultConnectionFactory"</span>)</span> ConnectionFactory defaultCF) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LocalizedQueueConnectionFactory(defaultCF,</span><br><span class="line">            StringUtils.commaDelimitedListToStringArray(<span class="keyword">this</span>.props.getAddresses()),</span><br><span class="line">            <span class="keyword">this</span>.adminUris, <span class="keyword">this</span>.nodes,</span><br><span class="line">            <span class="keyword">this</span>.props.getVirtualHost(), <span class="keyword">this</span>.props.getUsername(), <span class="keyword">this</span>.props.getPassword(),</span><br><span class="line">            <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，前三个参数是addresses，adminUris和nodes。这些是位置性的，因为当容器尝试连接到队列时，它确定队列被掌握在哪个节点上并连接到同一阵列位置的地址。</p><h5 id="Publisher-Confirms-and-Returns"><a href="#Publisher-Confirms-and-Returns" class="headerlink" title="Publisher Confirms and Returns"></a>Publisher Confirms and Returns</h5><p>通过将CachingConnectionFactory的publisherConfirms和publisherReturns属性分别设置为“true”，支持确认和返回的消息。</p><p>设置这些选项时，工厂创建的通道将被包装在PublisherCallbackChannel中，该通道用于方便回调。当获得这样的频道时，客户端可以使用频道注册一个PublisherCallbackChannel.Listener。 PublisherCallbackChannel实现包含将 确认或返回 路由到适当的监听器的逻辑。以下部分将进一步说明这些功能。</p><blockquote><p>有关更多背景信息，请参阅RabbitMQ小组题为“引入发布者确认”的博客文章。</p></blockquote><h5 id="记录通道关闭事件"><a href="#记录通道关闭事件" class="headerlink" title="记录通道关闭事件"></a>记录通道关闭事件</h5><p>版本1.5中引入了一种使用户能够控制日志记录级别的机制。</p><p>CachingConnectionFactory使用默认策略来记录通道关闭，如下所示：</p><ul><li>正常通道关闭(200 OK)不记录。</li><li>如果通道由于被动队列声明失败而关闭，则会在调试级别进行记录。</li><li>如果由于消费者条件验证不通过，则通道关闭，则会在INFO级别记录。</li><li>所有其他情况都记录在ERROR级别。</li></ul><p>要修改此行为，请在其closeExceptionLogger属性中的CachingConnectionFactory中注入自定义ConditionalExceptionLogger。</p><p>另请参阅“消费者失败事件”一节。</p><h5 id="运行缓存属性"><a href="#运行缓存属性" class="headerlink" title="运行缓存属性"></a>运行缓存属性</h5><p>Table 3.1 CacheMode.CHANNEL的缓存属性</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>connectionName</td><td>ConnectionNameStrategy生成的连接的名称。</td></tr><tr><td>channelCacheSize</td><td>当前配置的允许空闲的最大通道。</td></tr><tr><td>localPort</td><td>连接的本地端口(如果可用)。这可以用于与RabbitMQ管理界面上的连接/通道相关联。</td></tr><tr><td>idleChannelsTx</td><td>当前空闲(缓存)的事务通道的数量。</td></tr><tr><td>idleChannelsNotTx</td><td>当前空闲(高速缓存)的非事务性通道的数量。</td></tr><tr><td>idleChannelsTxHighWater</td><td>同时空闲(缓存)的事务通道的最大数量。</td></tr><tr><td>idleChannelsNotTxHighWater</td><td>非事务性通道的最大数量同时处于空闲状态(缓存)。</td></tr></tbody></table><p>Table 3.2 CacheMode.CONNECTION的缓存属性</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>connectionName:localPort</td><td>ConnectionNameStrategy生成的连接的名称。</td></tr><tr><td>openConnections</td><td>表示与经纪人连接的连接对象数。</td></tr><tr><td>channelCacheSize</td><td>当前配置的允许空闲的最大通道。</td></tr><tr><td>connectionCacheSize</td><td>当前配置的允许空闲的最大连接。</td></tr><tr><td>idleConnections</td><td>当前空闲的连接数。</td></tr><tr><td>idleConnectionsHighWater</td><td>同时空闲的最大连接数。</td></tr><tr><td>idleChannelsTx:localPort</td><td>当前为此连接空闲(高速缓存)的事务通道的数量。属性名称的localPort部分可用于与RabbitMQ Admin UI上的连接/通道相关联。</td></tr><tr><td>idleChannelsNotTx:localPort</td><td>当前为此连接空闲(高速缓存)的非事务性通道的数量。属性名称的localPort部分可用于与RabbitMQ Admin UI上的连接/通道相关联。</td></tr><tr><td>idleChannelsTxHighWater:localPort</td><td>同时空闲(缓存)的事务通道的最大数量。属性名称的localPort部分可用于与RabbitMQ Admin UI上的连接/通道相关联。</td></tr><tr><td>idleChannelsNotTxHighWater:localPort</td><td>非事务性通道的最大数量同时处于空闲状态(缓存)。属性名称的localPort部分可用于与RabbitMQ Admin UI上的连接/通道相关联。</td></tr></tbody></table><p><code>cacheMode</code>属性(还包括<code>CHANNEL</code>或<code>CONNECTION</code>)。</p><p><img src="http://docs.spring.io/spring-amqp/reference/htmlsingle/images/cacheStats.png.pagespeed.ce.IDb__HrgKf.png" alt="此处输入图片的描述"></p><h5 id="RabbitMQ自动连接-拓扑恢复"><a href="#RabbitMQ自动连接-拓扑恢复" class="headerlink" title="RabbitMQ自动连接/拓扑恢复"></a>RabbitMQ自动连接/拓扑恢复</h5><p>从Spring AMQP的第一个版本开始，框架在发生代理失败时提供了自己的连接和通道恢复。另外，如第3.1.10节“配置代理”所述，当重新建立连接时，RabbitAdmin将重新声明任何基础架构bean(队列等)。因此，它不依赖于由amqp-client库提供的自动恢复。 Spring AMQP现在使用4.0.x版本的amqp-client，默认情况下启用自动恢复。 Spring AMQP仍然可以使用自己的恢复机制，如果您希望，在客户端禁用它(通过将底层RabbitMQ connectionFactory上的automaticRecoveryEnabled属性设置为false)。但是，该框架与启用自动恢复完全兼容。这意味着您在代码中创建的任何消费者(可能通过RabbitTemplate.execute())都可以自动恢复。</p><h4 id="3-1-3-添加自定义客户端连接属性"><a href="#3-1-3-添加自定义客户端连接属性" class="headerlink" title="3.1.3 添加自定义客户端连接属性"></a>3.1.3 添加自定义客户端连接属性</h4><p>CachingConnectionFactory现在允许您访问底层连接工厂，例如设置自定义客户端属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connectionFactory.getRabbitConnectionFactory().getClientProperties().put(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure><p>查看连接时，这些属性将显示在RabbitMQ管理界面中。</p><h4 id="3-1-4-AmqpTemplate"><a href="#3-1-4-AmqpTemplate" class="headerlink" title="3.1.4 AmqpTemplate"></a>3.1.4 AmqpTemplate</h4><h5 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h5><p>与Spring框架和相关项目提供的许多其他高级抽象一样，Spring AMQP提供了一个起着核心作用的“模板”。定义主要操作的界面称为AmqpTemplate。这些操作涵盖发送和接收消息的一般行为。换句话说，它们不是任何实现的唯一，因此名称中的“AMQP”。另一方面，该接口的实现与AMQP协议的实现相关。不同于JMS，它是本身是一个接口级API，AMQP是一个线级协议。该协议的实现提供自己的客户端库，因此模板接口的每个实现将取决于特定的客户端库。目前，只有一个实现：RabbitTemplate。在下面的示例中，您将经常看到“AmqpTemplate”的使用，但是当您查看配置示例或调用模板实例化和/或设置的任何代码摘录时，您将看到实现类型(例如“RabbitTemplate”)。</p><p>如上所述，AmqpTemplate接口定义了发送和接收消息的所有基本操作。我们将在下面的两个部分分别探讨消息发送和接收。</p><p>另请参见“AsyncRabbitTemplate”一节。</p><h5 id="添加重试功能"><a href="#添加重试功能" class="headerlink" title="添加重试功能"></a>添加重试功能</h5><p>从版本1.3开始，您现在可以将RabbitTemplate配置为使用RetryTemplate来帮助处理代理连接问题。有关完整信息，请参阅spring-retry项目。以下只是使用指数退出策略和默认SimpleRetryPolicy的一个示例，它将在向调用者抛出异常之前进行三次尝试。</p><p>使用XML命名空间：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"template"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> <span class="attr">retry-template</span>=<span class="string">"retryTemplate"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"retryTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.retry.support.RetryTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"backOffPolicy"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.retry.backoff.ExponentialBackOffPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialInterval"</span> <span class="attr">value</span>=<span class="string">"500"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"multiplier"</span> <span class="attr">value</span>=<span class="string">"10.0"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInterval"</span> <span class="attr">value</span>=<span class="string">"10000"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用@Configuration:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AmqpTemplate <span class="title">rabbitTemplate</span><span class="params">()</span></span>;</span><br><span class="line">    RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">    RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">    ExponentialBackOffPolicy backOffPolicy = <span class="keyword">new</span> ExponentialBackOffPolicy();</span><br><span class="line">    backOffPolicy.setInitialInterval(<span class="number">500</span>);</span><br><span class="line">    backOffPolicy.setMultiplier(<span class="number">10.0</span>);</span><br><span class="line">    backOffPolicy.setMaxInterval(<span class="number">10000</span>);</span><br><span class="line">    retryTemplate.setBackOffPolicy(backOffPolicy);</span><br><span class="line">    template.setRetryTemplate(retryTemplate);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从版本1.4开始，除了retryTemplate属性之外，RabbitTemplate还支持recoveryCallback选项。它被用作<code>RetryTemplate.execute(RetryCallback&lt;T，E&gt; retryCallback，RecoveryCallback&lt;T&gt; recoveryCallback)</code>的第二个参数。</p><blockquote><p>RecoveryCallback有些限制，因为重试上下文仅包含lastThrowable字段。对于更复杂的用例，您应该使用外部RetryTemplate，以便您可以通过上下文的属性向RecoveryCallback传递附加信息：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">retryTemplate.execute(</span><br><span class="line">    <span class="keyword">new</span> RetryCallback&lt;Object, Exception&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doWithRetry</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            context.setAttribute(<span class="string">"message"</span>, message);</span><br><span class="line">            <span class="keyword">return</span> rabbitTemplate.convertAndSend(exchange, routingKey, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">new</span> RecoveryCallback&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">recover</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Object message = context.getAttribute(<span class="string">"message"</span>);</span><br><span class="line">            Throwable t = context.getLastThrowable();</span><br><span class="line">            <span class="comment">// Do something with message</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，您不会将RetryTemplate注入RabbitTemplate。</p><h5 id="Publisher-Confirms-and-Returns-1"><a href="#Publisher-Confirms-and-Returns-1" class="headerlink" title="Publisher Confirms and Returns"></a>Publisher Confirms and Returns</h5><p>AmqpTemplate的RabbitTemplate实现Publisher Confirms and Returns。</p><p>对于返回的消息，模板的必需属性必须设置为true，否则强制表达式必须对特定消息进行求值。此功能需要一个CachedConnectionFactory，其publisherReturns属性设置为true(参见“发布者确认和返回”一节)。通过调用setReturnCallback(ReturnCallback callback)注册一个RabbitTemplate.ReturnCallback，返回给客户端。回调必须实现这个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText,</span></span></span><br><span class="line"><span class="function"><span class="params">          String exchange, String routingKey)</span></span>;</span><br></pre></td></tr></table></figure><p>每个RabbitTemplate只支持一个ReturnCallback。另见“Reply Timeout”一节。</p><p>对于发布者确认(aka Publisher Acknowledgements)，该模板需要一个CachedConnectionFactory，其publisherConfirms属性设置为true。通过调用setConfirmCallback(ConfirmCallback callback)注册RabbitTemplate.ConfirmCallback，确认发送给客户端。回调必须实现这个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span></span>;</span><br></pre></td></tr></table></figure><p>CorrelationData是发送原始消息时由客户端提供的对象。 ack是真实的，对于一个nack是假的。对于nack，原因可能包含一个原因，如果在生成nack时可用。一个例子是向不存在的交换发送消息时。在这种情况下，经纪人关闭渠道;原因包括在内的原因。原因在版本1.4中被添加。</p><p>RabbitTemplate只支持一个ConfirmCallback。</p><blockquote><p>RabbitTemplate发送操作完成后，通道关闭;这将阻止在连接工厂缓存已满时(当缓存中有空间，通道没有物理关闭并且返回/确认将正常进行时)的接收确认或返回。当缓存已满时，框架会将关闭延迟最多5秒，以便允许接收确认/返回的时间。当使用确认时，当接收到最后一次确认时，通道将被关闭。当仅使用退货时，通道将保持打开5秒钟。通常建议将连接工厂的channelCacheSize设置为足够大的值，以便将发布消息的通道返回到缓存，而不是关闭。您可以使用RabbitMQ管理插件监视频道使用情况;如果您看到频道正在快速打开/关闭，您应该考虑增加缓存大小以减少服务器上的开销。</p></blockquote><h5 id="消息集成"><a href="#消息集成" class="headerlink" title="消息集成"></a>消息集成</h5><p>从版本1.4开始，构建在<code>RabbitTemplate</code>之上的<code>RabbitMessagingTemplate</code>提供了与Spring Framework消息抽象(即<code>org.springframework.messaging.Message</code>)的集成。这允许您使用<code>spring-messaging</code> <code>Message&lt;?&gt;</code>抽象发送和接收消息。这种抽象是由Spring Integration和Spring的STOMP支持的其他Spring项目使用的。有两个消息转换器涉及;一个用于在Spring消息传递<code>Message&lt;?&gt;</code>和Spring AMQP的<code>Message</code>抽象之间进行转换，另一个用于在Spring AMQP的Message抽象与底层RabbitMQ客户端库所需的格式之间进行转换。默认情况下，消息有效载荷由提供的<code>RabbitTemplate</code>的消息转换器转换。或者，您可以使用其他有效载荷转换器注入自定义<code>MessagingMessageConverter</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessagingMessageConverter amqpMessageConverter = <span class="keyword">new</span> MessagingMessageConverter();</span><br><span class="line">amqpMessageConverter.setPayloadConverter(myPayloadConverter);</span><br><span class="line">rabbitMessagingTempalte.setAmqpMessageConverter(amqpMessageConverter);</span><br></pre></td></tr></table></figure><h5 id="Validated-User-Id"><a href="#Validated-User-Id" class="headerlink" title="Validated User Id"></a>Validated User Id</h5><p>从版本1.6开始，该模板现在支持用户id表达式(使用Java配置时的userIdExpression)。如果发送消息，则在评估此表达式后，设置用户id属性(如果尚未设置)。用于评估的根对象是要发送的消息。</p><p>例子：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">...</span> <span class="attr">user-id-expression</span>=<span class="string">"'guest'"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">...</span> <span class="attr">user-id-expression</span>=<span class="string">"@myConnectionFactory.username"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>第一个例子是一个文字表达;第二个从应用程序上下文中的连接工厂bean获取用户名属性。</p><h4 id="3-1-5-发送消息"><a href="#3-1-5-发送消息" class="headerlink" title="3.1.5 发送消息"></a>3.1.5 发送消息</h4><h5 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h5><p>发送消息时，可以使用以下任一方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String exchange, String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure><p>我们可以用上面列出的最后一个方法开始讨论，因为它实际上是最明确的。它允许在运行时提供AMQP Exchange名称以及路由密钥。最后一个参数是负责实例创建Message实例的回调。使用此方法发送消息的示例可能是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">amqpTemplate.send(<span class="string">"marketData.topic"</span>, <span class="string">"quotes.nasdaq.FOO"</span>,</span><br><span class="line">    <span class="keyword">new</span> Message(<span class="string">"12.34"</span>.getBytes(), someProperties));</span><br></pre></td></tr></table></figure><p>如果您打算在大部分或全部时间使用该模板实例发送到同一个交换机，则可以在模板本身上设置“交换”属性。在这种情况下，可以使用上面列出的第二种方法。以下示例在功能上等同于上一个示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">amqpTemplate.setExchange(<span class="string">"marketData.topic"</span>);</span><br><span class="line">amqpTemplate.send(<span class="string">"quotes.nasdaq.FOO"</span>, <span class="keyword">new</span> Message(<span class="string">"12.34"</span>.getBytes(), someProperties));</span><br></pre></td></tr></table></figure><p>如果在模板上设置了“交换”和“路由密钥”属性，则可以使用仅接受消息的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">amqpTemplate.setExchange(<span class="string">"marketData.topic"</span>);</span><br><span class="line">amqpTemplate.setRoutingKey(<span class="string">"quotes.nasdaq.FOO"</span>);</span><br><span class="line">amqpTemplate.send(<span class="keyword">new</span> Message(<span class="string">"12.34"</span>.getBytes(), someProperties));</span><br></pre></td></tr></table></figure><p>更好的思考交换和路由关键属性的方法是显式方法参数将始终覆盖模板的默认值。实际上，即使你没有在模板上显式设置这些属性，总是存在默认值。在这两种情况下，默认是一个空字符串，但这实际上是一个明智的默认值。就路由密钥而言，首先并不总是必需的(例如扇出交换机)。此外，队列可能与一个空字符串绑定到一个Exchange。这些都是依赖模板的路由密钥属性的默认空字符串值的合法场景。就Exchange名称而言，空字符串是常用的，因为AMQP规范将“默认Exchange”定义为没有名称。由于所有队列都使用其名称作为绑定值自动绑定到该默认Exchange(即直接Exchange)，所以上述第二种方法可用于通过默认Exchange进行的任何队列的简单点对点消息传递。只需提供队列名称作为“routingKey” - 或者通过在运行时提供方法参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(); <span class="comment">// using default no-name Exchange</span></span><br><span class="line">template.send(<span class="string">"queue.helloWorld"</span>, <span class="keyword">new</span> Message(<span class="string">"Hello World"</span>.getBytes(), someProperties));</span><br></pre></td></tr></table></figure><p>或者，如果您希望创建一个将主要或专门用于单个队列发布的模板，以下是完全合理的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(); <span class="comment">// using default no-name Exchange</span></span><br><span class="line">template.setRoutingKey(<span class="string">"queue.helloWorld"</span>); <span class="comment">// but we'll always send to this Queue</span></span><br><span class="line">template.send(<span class="keyword">new</span> Message(<span class="string">"Hello World"</span>.getBytes(), someProperties));</span><br></pre></td></tr></table></figure><h5 id="Message-Builder-API"><a href="#Message-Builder-API" class="headerlink" title="Message Builder API"></a>Message Builder API</h5><p>从版本1.3开始，消息构建器API由MessageBuilder和MessagePropertiesBuilder提供;它们提供了一种方便的“流利”手段创建消息或消息属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message message = MessageBuilder.withBody(<span class="string">"foo"</span>.getBytes())</span><br><span class="line">    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">    .setMessageId(<span class="string">"123"</span>)</span><br><span class="line">    .setHeader(<span class="string">"bar"</span>, <span class="string">"baz"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageProperties props = MessagePropertiesBuilder.newInstance()</span><br><span class="line">    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">    .setMessageId(<span class="string">"123"</span>)</span><br><span class="line">    .setHeader(<span class="string">"bar"</span>, <span class="string">"baz"</span>)</span><br><span class="line">    .build();</span><br><span class="line">Message message = MessageBuilder.withBody(<span class="string">"foo"</span>.getBytes())</span><br><span class="line">    .andProperties(props)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>可以设置MessageProperties上定义的每个属性。其他方法包括setHeader(String key，String value)，removeHeader(String key)，removeHeaders()和copyProperties(MessageProperties属性)。每个属性设置方法都有一个set<em>IfAbsent()变体。在存在默认初始值的情况下，该方法命名为set</em>IfAbsentOrDefault()。</p><p>提供了五种静态方法来创建初始消息构建器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MessageBuilder <span class="title">withBody</span><span class="params">(<span class="keyword">byte</span>[] body)</span> 1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MessageBuilder <span class="title">withClonedBody</span><span class="params">(<span class="keyword">byte</span>[] body)</span> 2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MessageBuilder <span class="title">withBody</span><span class="params">(<span class="keyword">byte</span>[] body, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> 3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MessageBuilder <span class="title">fromMessage</span><span class="params">(Message message)</span> 4</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MessageBuilder <span class="title">fromClonedMessage</span><span class="params">(Message message)</span> 5</span></span><br></pre></td></tr></table></figure><p>1.由构建器创建的消息将具有直接引用参数的主体。<br>2.由构建器创建的消息将具有一个包含参数中字节副本的新数组的主体。<br>3.由构建器创建的消息将具有一个新的数组，其中包含参数中的字节范围。有关更多详细信息，请参阅Arrays.copyOfRange();<br>4.他由建设者创建的消息将具有一个直接引用参数体的主体。参数的属性被复制到一个新的MessageProperties对象。<br>5.由构建器创建的消息将具有一个包含参数的正文副本的新数组的主体。参数的属性被复制到一个新的MessageProperties对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MessagePropertiesBuilder <span class="title">newInstance</span><span class="params">()</span> 1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MessagePropertiesBuilder <span class="title">fromProperties</span><span class="params">(MessageProperties properties)</span> 2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MessagePropertiesBuilder <span class="title">fromClonedProperties</span><span class="params">(MessageProperties properties)</span> 3</span></span><br></pre></td></tr></table></figure><p>1.新的消息属性对象使用默认值初始化。<br>2.构建器初始化，并且build()将返回所提供的属性对象。<br>3.参数的属性被复制到一个新的MessageProperties对象。</p><p>使用AmqpTemplate的RabbitTemplate实现，每个send()方法都有一个重载的版本，它接受一个附加的CorrelationData对象。当发布者确认被启用时，该对象将在第3.1.4节“AmqpTemplate”中描述的回调中返回。这允许发送者将确认(ack或nack)与发送的消息相关联。</p><p>从1.6.7版开始，引入了CorrelationAwareMessagePostProcessor接口，允许在消息转换后修改相关数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">postProcessMessage</span><span class="params">(Message message, Correlation correlation)</span></span>;</span><br></pre></td></tr></table></figure><p>同样从版本1.6.7开始，提供了一个新的回调接口CorrelationDataPostProcessor;所有MessagePostProcessor(在send()方法中提供)以及在setBeforePublishPostProcessors()中提供的那些)之后调用。实现可以更新或替换send()方法中提供的相关数据(如果有的话)。消息和原始CorrelationData(如果有)作为参数提供。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CorrelationData <span class="title">postProcess</span><span class="params">(Message message, CorrelationData correlationData)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="Publisher-Returns"><a href="#Publisher-Returns" class="headerlink" title="Publisher Returns"></a>Publisher Returns</h5><p>当模板的强制属性为true时，返回的消息由第3.1.4节“AmqpTemplate”中描述的回调提供。</p><p>从版本1.4开始，RabbitTemplate支持根据每个请求消息评估的Spel mandatoryExpression属性作为根评估对象，解析为布尔值。<br>Bean的引用,比如“@myBean.isMandatory(#root)”可以在表达式中使用。</p><p>发送者返回也可以在RabbitTemplate内部用于发送和接收操作。有关详细信息，请参阅“回复超时”一节。</p><h5 id="Batching"><a href="#Batching" class="headerlink" title="Batching"></a>Batching</h5><p>从版本1.4.2开始，已经介绍了BatchingRabbitTemplate。这是RabbitTemplate的一个子类，具有重写的发送方法，根据BatchingStrategy对消息进行批处理;只有批量完成时才将消息发送给RabbitMQ。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BatchingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">MessageBatch <span class="title">addToBatch</span><span class="params">(String exchange, String routingKey, Message message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">nextRelease</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Collection&lt;MessageBatch&gt; <span class="title">releaseBatches</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>警告<br>    批量数据保存在内存中;在发生系统故障的情况下，未发送的消息可能会丢失。</p></blockquote><p>提供了SimpleBatchingStrategy。它支持将消息发送到单个交换/路由密钥。它有属性：</p><ul><li>batchSize 发送批次之前的消息数</li><li>bufferLimit 批量消息的最大大小;这将超过batchSize，并且导致部分批处理被发送</li><li>timeout 当没有新活动向批量添加消息时，将发送部分批次的时间</li></ul><p>SimpleBatchingStrategy通过使用4字节二进制长度的每个嵌入式消息进行格式化。通过将springBatchFormat消息属性设置为lengthHeader4，将其传送到接收系统。</p><blockquote><p>注意<br>批量消息由监听器容器(使用springBatchFormat消息头)自动分段。拒绝批次中的任何消息将导致整个批次被拒绝。</p></blockquote><h4 id="3-1-6-Receiving-messages"><a href="#3-1-6-Receiving-messages" class="headerlink" title="3.1.6 Receiving messages"></a>3.1.6 Receiving messages</h4><h5 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h5><p>消息接收总是比发送更复杂一些。有两种方式可以接收消息。更简单的选择是一次轮询方法调用来轮询单个消息。更复杂但更常见的方法是注册将按需异步接收消息的监听器。我们将在接下来的两个小节中看一下每种方法的一个例子。</p><h5 id="Polling-Consumer-轮询消费者"><a href="#Polling-Consumer-轮询消费者" class="headerlink" title="Polling Consumer(轮询消费者)"></a>Polling Consumer(轮询消费者)</h5><p>AmqpTemplate本身可用于轮询的消息接收。默认情况下，如果没有消息可用，则立即返回null;没有阻塞。从版本1.5开始，您现在可以设置receiveTimeout(以毫秒为单位)，并且接收方法将阻塞长达数秒，等待消息。小于零的值意味着无限期地阻止(或至少直到与代理的连接丢失)。版本1.6引入了接收方法的变体，允许每次调用传递超时。</p><blockquote><p>警告<br>由于接收操作为每个消息创建一个新的QueueingConsumer，因此该技术并不适用于大容量环境;考虑使用异步消费者，或者对于这些用例使用receiveTimeout为零。</p></blockquote><p>有四种简单的接收方法可用。与发送方的Exchange一样，有一种方法需要直接在模板本身设置默认队列属性，并且有一种在运行时接受队列参数的方法。版本1.6引入了接受timeoutMillis的变体来根据每个请求重写receiveTimeout。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(String queueName)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure><p>就像在发送消息的情况下，AmqpTemplate有一些方便的接收POJO而不是Message实例的方法，并且实现将提供一种自定义用于创建返回的对象的MessageConverter的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(String queueName)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Message <span class="title">receiveAndConvert</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Message <span class="title">receiveAndConvert</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure><p>类似于sendAndReceive方法，从版本1.3开始，AmqpTemplate具有几个方便的receiveAndReply方法来同步接收，处理和回复消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R, S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">receiveAndReply</span><span class="params">(ReceiveAndReplyCallback&lt;R, S&gt; callback)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line">&lt;R, S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">receiveAndReply</span><span class="params">(String queueName, ReceiveAndReplyCallback&lt;R, S&gt; callback)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line">&lt;R, S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">receiveAndReply</span><span class="params">(ReceiveAndReplyCallback&lt;R, S&gt; callback,</span></span></span><br><span class="line"><span class="function"><span class="params">String replyExchange, String replyRoutingKey)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line">&lt;R, S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">receiveAndReply</span><span class="params">(String queueName, ReceiveAndReplyCallback&lt;R, S&gt; callback,</span></span></span><br><span class="line"><span class="function"><span class="params">String replyExchange, String replyRoutingKey)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line">&lt;R, S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">receiveAndReply</span><span class="params">(ReceiveAndReplyCallback&lt;R, S&gt; callback,</span></span></span><br><span class="line"><span class="function"><span class="params"> ReplyToAddressCallback&lt;S&gt; replyToAddressCallback)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line">&lt;R, S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">receiveAndReply</span><span class="params">(String queueName, ReceiveAndReplyCallback&lt;R, S&gt; callback,</span></span></span><br><span class="line"><span class="function"><span class="params">ReplyToAddressCallback&lt;S&gt; replyToAddressCallback)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure><p>AmqpTemplate实现负责接收和回复阶段。在大多数情况下，您应该只提供一个ReceiveAndReplyCallback的实现来为接收到的消息执行一些业务逻辑，如果需要，可以构建回复对象或消息。注意，ReceiveAndReplyCallback可能返回null。在这种情况下，没有发送回复，receiveAndReply类似于receive方法。这允许将相同的队列用于消息的混合，其中一些可能不需要回复。</p><p>仅当提供的回调不是ReceiveAndReplyMessageCallback的实例(提供原始消息交换合同)时，才应用自动消息(请求和回复)转换。</p><p>ReplyToAddressCallback对于需要自定义逻辑在运行时根据接收到的消息和ReceiveAndReplyCallback的回复来确定replyTo地址的情况很有用。默认情况下，请求消息中的replyTo信息用于路由回复。</p><p>以下是基于POJO的接收和回复的示例…</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> received =</span><br><span class="line">        <span class="keyword">this</span>.template.receiveAndReply(ROUTE, <span class="keyword">new</span> ReceiveAndReplyCallback&lt;Order, Invoice&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Invoice <span class="title">handle</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> processOrder(order);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="keyword">if</span> (received) &#123;</span><br><span class="line">        log.info(<span class="string">"We received an order!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Asynchronous-Consumer-异步消费者"><a href="#Asynchronous-Consumer-异步消费者" class="headerlink" title="Asynchronous Consumer(异步消费者)"></a>Asynchronous Consumer(异步消费者)</h5><blockquote><p>注意<br>Spring AMQP还通过使用@RabbitListener注解来支持带注解的监听端点，并提供了一种开放的基础设施，以编程方式注册端点。这是设置异步消费者的最方便的方法，有关详细信息，请参阅“注解驱动的监听器端点”一节。</p></blockquote><p><strong>Message Listener</strong></p><p>对于异步消息接收，涉及专用组件(而不是AmqpTemplate)。该组件是消息回收消息的容器。我们将在短时间内查看容器及其属性，但首先我们应该看一下回调，因为这样你的应用程序代码将与邮件系统集成在一起。从MessageListener接口的实现开始，有几个回调选项：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您的回调逻辑由于任何原因取决于AMQP Channel实例，您可以改为使用ChannelAwareMessageListener。它看起来相似，但有一个额外的参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MessageListenerAdapter</strong><br>如果您希望在应用程序逻辑和消息传递API之间保持更严格的分隔，则可以依靠框架提供的适配器实现。这通常被称为“消息驱动的POJO”支持。使用适配器时，只需要提供适配器本身应该调用的实例的引用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageListenerAdapter listener = <span class="keyword">new</span> MessageListenerAdapter(somePojo);</span><br><span class="line">    listener.setDefaultListenerMethod(<span class="string">"myMethod"</span>);</span><br></pre></td></tr></table></figure><p>您可以将适配器子类化并提供getListenerMethodName()的实现，以根据消息动态选择不同的方法。这个方法有两个参数，即原始的消息和extractMessage，后者是任何转换的结果。默认情况下，配置SimpleMessageConverter;有关可用的其他转换器的更多信息和信息，请参阅“SimpleMessageConverter”一节。</p><p>从版本1.4.2开始，原始消息具有consumerQueue和consumerTag属性，可用于确定从哪个队列接收消息。</p><p>从版本1.5开始，您可以将消费者队列/标记的映射配置为方法名称，以动态选择要调用的方法。如果map中没有条目，我们将回到默认监听器方法。</p><p><strong>Container</strong><br>现在您已经看到了Message-listening回调的各种选项，我们可以将注意力转向容器。基本上，容器处理“主动”的责任，使得监听器回调可以保持被动。容器是“生命周期”组件的示例。它提供了启动和停止的方法。配置容器时，您基本上弥合了AMQP队列和MessageListener实例之间的差距。您必须提供对ConnectionFactory以及该监听器应从其消费消息的队列名称或队列实例的引用。这是使用默认实现的最基本的例子SimpleMessageListenerContainer：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">container.setConnectionFactory(rabbitConnectionFactory);</span><br><span class="line">container.setQueueNames(<span class="string">"some.queue"</span>);</span><br><span class="line">container.setMessageListener(<span class="keyword">new</span> MessageListenerAdapter(somePojo));</span><br></pre></td></tr></table></figure><p>作为“活动”组件，最常见的是使用bean定义创建监听器容器，以便它可以在后台运行。这可以通过XML来完成：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"rabbitConnectionFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">queues</span>=<span class="string">"some.queue"</span> <span class="attr">ref</span>=<span class="string">"somePojo"</span> <span class="attr">method</span>=<span class="string">"handle"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者，您可能更喜欢使用与上述实际代码片段非常相似的@Configuration样式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleAmqpConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">        container.setQueueName(<span class="string">"some.queue"</span>);</span><br><span class="line">        container.setMessageListener(exampleListener());</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">rabbitConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory =</span><br><span class="line">            <span class="keyword">new</span> CachingConnectionFactory(<span class="string">"localhost"</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageListener <span class="title">exampleListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"received: "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从RabbitMQ版本3.2开始，代理现在支持消费者优先级(请参阅使用RICSMQ使用消费者优先级)。这通过在消费者上设置x-priority参数来启用。 SimpleMessageListenerContainer现在支持设置消费者参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">container.setConsumerArguments(Collections.</span><br><span class="line">&lt;String, Object&gt; singletonMap(<span class="string">"x-priority"</span>, Integer.valueOf(<span class="number">10</span>)));</span><br></pre></td></tr></table></figure><p>为方便起见，命名空间提供了listener元素的priority属性：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"rabbitConnectionFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">queues</span>=<span class="string">"some.queue"</span> <span class="attr">ref</span>=<span class="string">"somePojo"</span> <span class="attr">method</span>=<span class="string">"handle"</span> <span class="attr">priority</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从版本1.3开始，容器正在监听的队列可以在运行时修改;Section 3.1.18, “Listener Container Queues”.</p><p><strong>auto-delete Queues</strong><br>当容器配置为监听自动删除队列时，或者队列具有x-expires选项，或者Broker上配置了“即时生存”策略，则当容器为停止(最后消费者被取消)。在版本1.3之前，由于队列丢失，容器无法重新启动;当连接被关闭/打开时，RabbitAdmin只会自动重新发送队列等，当容器停止/启动时，不会发生这种情况。</p><p>从版本1.3开始，容器现在将在启动期间使用RabbitAdmin重新声明任何丢失的队列。</p><p>您还可以使用条件声明(称为“条件声明”一节)以及auto-startup =“false”管理员延迟队列声明，直到容器启动。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">"otherAnon"</span> <span class="attr">declared-by</span>=<span class="string">"containerAdmin"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">name</span>=<span class="string">"otherExchange"</span> <span class="attr">auto-delete</span>=<span class="string">"true"</span> <span class="attr">declared-by</span>=<span class="string">"containerAdmin"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">"otherAnon"</span> <span class="attr">key</span>=<span class="string">"otherAnon"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">id</span>=<span class="string">"container2"</span> <span class="attr">auto-startup</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">id</span>=<span class="string">"listener2"</span> <span class="attr">ref</span>=<span class="string">"foo"</span> <span class="attr">queues</span>=<span class="string">"otherAnon"</span> <span class="attr">admin</span>=<span class="string">"containerAdmin"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">"containerAdmin"</span> <span class="attr">connection-factory</span>=<span class="string">"rabbitConnectionFactory"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">auto-startup</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在这种情况下，队列和交换由containerAdmin声明，它具有auto-startup =“false”，因此在上下文初始化期间不会声明元素。同样，由于同样的原因，容器也没有启动。当容器稍后启动时，它使用它来引用containerAdmin来声明元素。</p><h5 id="Batched-Messages-批量消息"><a href="#Batched-Messages-批量消息" class="headerlink" title="Batched Messages(批量消息)"></a>Batched Messages(批量消息)</h5><p>批量消息由监听器容器(使用springBatchFormat消息头)自动分段。拒绝批次中的任何消息将导致整个批次被拒绝。有关批处理的更多信息，请参阅“批处理”一节。</p><h5 id="Consumer-Failure-Events-消费失败事件"><a href="#Consumer-Failure-Events-消费失败事件" class="headerlink" title="Consumer Failure Events(消费失败事件)"></a>Consumer Failure Events(消费失败事件)</h5><p>从1.5版开始，SimpleMessageListenerContainer每当监听器(消费者)遇到某种故障时，都会发布应用程序事件。事件ListenerContainerConsumerFailedEvent具有以下属性：</p><ul><li>container - 消费者遇到问题的监听器容器。</li><li>reason - 失败的一个文本原因。</li><li>fatal - 一个布尔值表示失败是否是致命的;与非致命的例外，容器将尝试重新启动消费者，根据retryInterval。</li><li>throwable - the Throwable that was caught.</li></ul><p>这些事件可以通过实现<code>ApplicationListener&lt;ListenerContainerConsumerFailedEvent&gt;</code>来消耗。</p><blockquote><p>当并发消费者大于1时，系统范围的事件(如连接失败)将由所有消费者发布。</p></blockquote><p>如果一个消费者失败，因为一个如果它的队列被专门使用，默认情况下，以及发布事件，将发出一个WARN日志。要更改此日志记录行为，请在SimpleMessageListenerContainer的exclusiveConsumerExceptionLogger属性中提供自定义ConditionalExceptionLogger。另见“记录通道关闭事件”一节。</p><p>致命错误始终记录在ERROR级别;这不可修改。</p><h5 id="Consumer-Tags-消费者标签"><a href="#Consumer-Tags-消费者标签" class="headerlink" title="Consumer Tags(消费者标签)"></a>Consumer Tags(消费者标签)</h5><p>从版本1.4.5开始，您现在可以提供生成消费者标签的策略。默认情况下，消费者标签将由代理生成。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerTagStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">createConsumerTag</span><span class="params">(String queue)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列可用，因此可以(可选地)在标签中使用。<br>See Section 3.1.15, “Message Listener Container Configuration”.</p><h5 id="Annotation-driven-Listener-Endpoints-注解驱动的监听器端点"><a href="#Annotation-driven-Listener-Endpoints-注解驱动的监听器端点" class="headerlink" title="Annotation-driven Listener Endpoints(注解驱动的监听器端点)"></a>Annotation-driven Listener Endpoints(注解驱动的监听器端点)</h5><p><strong>介绍</strong><br>从版本1.4开始，异步接收消息的最简单的方法是使用带注解的监听端点基础结构。简而言之，它允许您将托管bean的方法公开为Rabbit监听器端点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"myQueue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例的想法是，每当org.springframework.amqp.core.Queue“myQueue”上都有可用的消息时，将相应地调用processOrder方法(在这种情况下，与消息的有效内容相关)。</p><p>注解架构使用RabbitListenerContainerFactory为每个注解方法在幕后创建一个消息监听器容器。</p><p>在上面的例子中，myQueue必须已经存在并被绑定到一些交换。从版本1.5.0开始，只要应用程序上下文中存在RabbitAdmin，队列可以自动声明和绑定。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        value = <span class="meta">@Queue</span>(value = <span class="string">"myQueue"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"auto.exch"</span>, ignoreDeclarationExceptions = <span class="string">"true"</span>),</span><br><span class="line">        key = <span class="string">"orderRoutingKey"</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        value = <span class="meta">@Queue</span>,</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"auto.exch"</span>),</span><br><span class="line">        key = <span class="string">"invoiceRoutingKey"</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processInvoice</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一个示例中，如果需要，队列myQueue将自动声明(持久)，并与交换机绑定到路由密钥。在第二个示例中，将声明并绑定匿名(独占，自动删除)队列。可以提供多个QueueBinding条目，允许监听器监听多个队列。</p><p>只有DIRECT，FANOUT，TOPIC和HEADERS，这种机制支持交换类型。当需要更多高级配置时，请使用正常的@Bean定义</p><p>在第一个例子中，请注意ignoreDeclarationExchangeions对交换。这允许例如绑定到可能具有不同设置(如内部)的现有交换机。默认情况下，现有交换机的属性必须匹配。</p><p>从版本1.6开始，现在可以在@QueueBinding注解中为队列，交换和绑定指定参数。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        value = <span class="meta">@Queue</span>(value = <span class="string">"auto.headers"</span>, autoDelete = <span class="string">"true"</span>,</span><br><span class="line">                        arguments = <span class="meta">@Argument</span>(name = <span class="string">"x-message-ttl"</span>, value = <span class="string">"10000"</span>,</span><br><span class="line">                                                type = <span class="string">"java.lang.Integer"</span>)),</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"auto.headers"</span>, type = ExchangeTypes.HEADERS, autoDelete = <span class="string">"true"</span>),</span><br><span class="line">        arguments = &#123;</span><br><span class="line">                <span class="meta">@Argument</span>(name = <span class="string">"x-match"</span>, value = <span class="string">"all"</span>),</span><br><span class="line">                <span class="meta">@Argument</span>(name = <span class="string">"foo"</span>, value = <span class="string">"bar"</span>),</span><br><span class="line">                <span class="meta">@Argument</span>(name = <span class="string">"baz"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleWithHeadersExchange</span><span class="params">(String foo)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，x-message-ttl参数为队列设置为10秒。由于参数类型不是String，我们必须指定其类型;在这种情况下整数。与所有这样的声明一样，如果队列已经存在，那么这些参数必须与队列上的一致。对于headers exchange，我们设置绑定参数以匹配头foo设置为bar的消息，并且头baz必须与任何值一起显示。 x匹配参数意味着必须满足这两个条件。</p><p>参数名称，值，和类型可以是财产的占位符($ {…})或该表达式(# {…})。名称必须解析为字符串；类型表达式必须解析为类或类的完全限定名。价值必须解决的东西，可以被defaultconversionservice的类型(如在上面的例子中x-message-ttl)。</p><p>如果名称解析为null或空字符串，则忽略该参数。</p><p><strong>Meta-Annotations(元注解)</strong><br>有时您可能希望为多个监听器使用相同的配置。为了减少样板设置，您可以使用元注解来创建自己的监听器注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        value = <span class="meta">@Queue</span>,</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"metaFanout"</span>, type = ExchangeTypes.FANOUT)))</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnonFanoutListener &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnonFanoutListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">(String foo)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnonFanoutListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">(String foo)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此示例中，由@MyAnonFanoutListener注解创建的每个监听器将将匿名自动删除队列绑定到扇出交换机的metaFanout。元注解机制很简单，因为用户定义的注解上的属性未被检查 - 因此您不能从元注解中覆盖设置。当需要更多高级配置时，请使用正常的@Bean定义。</p><p><strong>启用监听器端点注解</strong><br>要启用对@RabbitListener注解的支持，请将@EnableRabbit添加到您的一个@Configuration类中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRabbit</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory());</span><br><span class="line">        factory.setConcurrentConsumers(<span class="number">3</span>);</span><br><span class="line">        factory.setMaxConcurrentConsumers(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，基础组件将查找名为rabbitListenerContainerFactory的bean作为工厂用于创建消息监听器容器的源。在这种情况下，忽略RabbitMQ基础架构设置，可以使用3个线程的核心轮询大小和10个线程的最大池大小来调用processOrder方法。</p><p>可以自定义监听器容器工厂以使用每个注解，或者可以通过实现RabbitListenerConfigurer接口来配置显式默认值。仅当至少有一个端点没有特定的容器工厂注册时，才需要默认值。有关详细信息和示例，请参阅javadoc。</p><p>如果您喜欢XML配置，请使用<code>&lt;rabbit:annotation-driven&gt;</code>元素。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rabbitListenerContainerFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"concurrentConsumers"</span> <span class="attr">value</span>=<span class="string">"3"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxConcurrentConsumers"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Message Conversion for Annotated Methods</strong><br>在调用监听器之前，有两个转换步骤在管道中。第一个使用MessageConverter将传入的Spring AMQP消息转换为spring-message消息。当调用目标方法时，如有必要，将消息有效载荷转换为方法参数类型。</p><p>第一步的默认MessageConverter是一个Spring AMQP SimpleMessageConverter，用于处理转换为String和java.io.Serializable对象;所有其他的都保留为一个byte[]。在下面的讨论中，我们称之为消息转换器。</p><p>第二步的默认转换器是一个GenericMessageConverter，它委托给转换服务(DefaultFormattingConversionService的一个实例)。在下面的讨论中，我们称之为方法参数转换器。</p><p>要更改消息转换器，只需将其作为属性添加到容器工厂bean中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">    ...</span><br><span class="line">    factory.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这配置了一个Jackson2转换器，期望头信息存在，以引导转换。</p><p>您还可以考虑一个ContentTypeDelegatingMessageConverter，它可以处理不同内容类型的转换。</p><p>在大多数情况下，除非要使用自定义ConversionService，否则不需要自定义方法参数转换器。</p><p>在1.6之前的版本中，转换JSON的类型信息必须在消息头中提供，或需要自定义ClassMapper。从版本1.6开始，如果没有类型信息头，则可以从目标方法参数推断类型。</p><blockquote><p>此类型推断仅适用于方法级别的@RabbitListener。</p></blockquote><p>See the section called “Jackson2JsonMessageConverter” for more information.</p><p>如果你想自定义方法参数转换器，你可以这样做，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRabbit</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> <span class="keyword">implements</span> <span class="title">RabbitListenerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultMessageHandlerMethodFactory <span class="title">myHandlerMethodFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultMessageHandlerMethodFactory factory = <span class="keyword">new</span> DefaultMessageHandlerMethodFactory();</span><br><span class="line">        factory.setMessageConverter(<span class="keyword">new</span> GenericMessageConverter(myConversionService()));</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConversionService <span class="title">myConversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultConversionService conv = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">        conv.addConverter(mySpecialConverter());</span><br><span class="line">        <span class="keyword">return</span> conv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureRabbitListeners</span><span class="params">(RabbitListenerEndpointRegistrar registrar)</span> </span>&#123;</span><br><span class="line">        registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重点<br>对于多方法监听器(参见“Multi-Method Listeners”一节)，方法选择是基于消息转换后消息的有效载荷;方法参数转换器只有在方法被选择之后才被调用。</p></blockquote><p><strong>Programmatic Endpoint Registration</strong><br>RabbitListenerEndpoint提供了Rabbit端点的模型，并负责为该模型配置容器。基础设施允许您以编程方式配置端点，除了由RabbitListener注解检测到的端点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRabbit</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> <span class="keyword">implements</span> <span class="title">RabbitListenerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureRabbitListeners</span><span class="params">(RabbitListenerEndpointRegistrar registrar)</span> </span>&#123;</span><br><span class="line">        SimpleRabbitListenerEndpoint endpoint = <span class="keyword">new</span> SimpleRabbitListenerEndpoint();</span><br><span class="line">        endpoint.setQueueNames(<span class="string">"anotherQueue"</span>);</span><br><span class="line">        endpoint.setMessageListener(message -&gt; &#123;</span><br><span class="line">            <span class="comment">// processing</span></span><br><span class="line">        &#125;);</span><br><span class="line">        registrar.registerEndpoint(endpoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们使用了SimpleRabbitListenerEndpoint，它提供了实际的MessageListener来调用，但是你也可以构建自己的端点变体来描述自定义调用机制。</p><p>应该注意的是，您也可以跳过使用@RabbitListener，只通过RabbitListenerConfigurer以编程方式注册您的端点。</p><p><strong>Annotated Endpoint Method Signature</strong><br>到目前为止，我们已经在我们的端点注入了一个简单的String，但实际上它可以有一个非常灵活的方法签名。我们重写它以使用自定义标题注入Order：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"myQueue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">(Order order, @Header(<span class="string">"order_type"</span>)</span> String orderType) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些是您可以在监听器端点注入的主要元素：</p><ul><li>原始的org.springframework.amqp.core.Message。</li><li>接收消息的com.rabbitmq.client.Channel</li><li>表示传入AMQP消息的org.springframework.messaging.Message。请注意，此消息包含自定义标头和标准标题(由AmqpHeaders定义)。<blockquote><p>从版本1.6开始，入站deliveryMode标题现在在名称为AmqpHeaders.RECEIVED_DELIVERY_MODE的标题中可用，而不是AmqpHeaders.DELIVERY_MODE。</p></blockquote></li><li>@ Header-annotated方法参数来提取特定的头值，包括标准AMQP头。</li><li>@ Headers-annotated参数，必须也可以分配给java.util.Map以获取对所有头的访问。</li></ul><p>-</p><p>不被支持的类型(即消息和信道)的非注释元素被认为是有效载荷。您可以通过使用@Payload注释参数来使其显式。您还可以通过添加额外的@Valid来启用验证。</p><p>注入Spring Message消息抽象的能力特别适用于从传输特定消息中存储的所有信息中获益，而不依赖于特定于传输的API。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"myQueue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">(Message&lt;Order&gt; order)</span> </span>&#123; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法参数的处理由DefaultMessageHandlerMethodFactory提供，可以进一步自定义以支持其他方法参数。转换和验证支持也可以在这里定制。</p><p>例如，如果我们想在处理之前确保我们的订单有效，我们可以使用@Valid对有效负载进行注释，并配置必要的验证器，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRabbit</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> <span class="keyword">implements</span> <span class="title">RabbitListenerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureRabbitListeners</span><span class="params">(RabbitListenerEndpointRegistrar registrar)</span> </span>&#123;</span><br><span class="line">        registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultMessageHandlerMethodFactory <span class="title">myHandlerMethodFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultMessageHandlerMethodFactory factory = <span class="keyword">new</span> DefaultMessageHandlerMethodFactory();</span><br><span class="line">        factory.setValidator(myValidator());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Listening to Multiple Queues</strong><br>使用queues属性时，可以指定关联的容器可以监听多个队列。您可以使用@Header注释来创建POJO方法可接收消息的队列名称。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = &#123; <span class="string">"queue1"</span>, <span class="string">"queue2"</span> &#125; )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">(String data, @Header(AmqpHeaders.CONSUMER_QUEUE)</span> String queue) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从版本1.5开始，您可以使用属性占位符和SpEL来对队列名称进行外部化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"#&#123;'$&#123;property.with.comma.delimited.queue.names&#125;'.split(',')&#125;"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">(String data, @Header(AmqpHeaders.CONSUMER_QUEUE)</span> String queue) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在版本1.5之前，只能通过这种方式指定一个队列;每个队列需要一个单独的属性。</p><p><strong>Reply Management</strong><br>MessageListenerAdapter中的现有支持已经允许您的方法具有非空返回类型。在这种情况下，调用的结果被封装在以原始消息的ReplyToAddress头中指定的地址或在监听器上配置的默认地址中发送的消息中。现在可以使用消息传递抽象的@SendTo注释来设置该默认地址。</p><p>假设我们的processOrder方法现在应该返回一个OrderStatus，可以按如下方式写入自动发送回复：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(destination = <span class="string">"myQueue"</span>)</span><br><span class="line"><span class="meta">@SendTo</span>(<span class="string">"status"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderStatus <span class="title">processOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// order processing</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您需要以传输独立的方式设置其他标头，则可以返回一条消息，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(destination = <span class="string">"myQueue"</span>)</span><br><span class="line"><span class="meta">@SendTo</span>(<span class="string">"status"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Message&lt;OrderStatus&gt; <span class="title">processOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// order processing</span></span><br><span class="line">    <span class="keyword">return</span> MessageBuilder</span><br><span class="line">        .withPayload(status)</span><br><span class="line">        .setHeader(<span class="string">"code"</span>, <span class="number">1234</span>)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@SendTo</code>值被假定为<code>exchange/routingKey</code>之后的回复exchange和routingKey，其中可以省略其中一个部分。有效值为：</p><p>1.foo/bar - the replyTo exchange and routingKey.<br>2.foo/ - the replyTo exchange and default (empty) routingKey.<br>3.bar or /bar - the replyTo routingKey and default (empty) exchange.<br>4./ or empty - the replyTo default exchange and default routingKey.</p><p>还可以使用@SendTo而不使用value属性。这种情况等于一个空的sendTo模式。 @SendTo仅在入站邮件没有replyToAddress属性时使用。</p><p>从版本1.5开始，@SendTo值可以是一个bean初始化SpEL Expression，例如…</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"test.sendTo.spel"</span>)</span><br><span class="line"><span class="meta">@SendTo</span>(<span class="string">"#&#123;spelReplyTo&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">capitalizeWithSendToSpel</span><span class="params">(String foo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">spelReplyTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test.sendTo.reply.spel"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式必须求值为一个String，它可以是一个简单的队列名称(发送到默认exchange)，也可以是如上所述的exchange / routingKey形式。</p><blockquote><p><code>#{…}</code>表达式在初始化时执行一次</p></blockquote><p>对于动态回复路由，消息发送方应包含一个reply_to消息属性或使用下面描述的备用运行时Spel表达式。<br>从版本1.6开始，@SendTo可以是在运行时针对请求和回复进行评估的Spel表达式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"test.sendTo.spel"</span>)</span><br><span class="line"><span class="meta">@SendTo</span>(<span class="string">"!&#123;'some.reply.queue.with.' + result.queueName&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Bar <span class="title">capitalizeWithSendToSpel</span><span class="params">(Foo foo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> processTheFooAndReturnABar(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spel表达式的运行时性质由<code>!{...}</code>分隔符指示。表达式的评估上下文<code>#root</code>对象具有三个属性：</p><blockquote><ul><li>request - o.s.amqp.core.Message请求对象。</li><li>source - 转换后的o.s.messaging.Message&lt;？&gt;</li><li>result - 方法结果。</li></ul></blockquote><p>上下文具有映射属性访问器，标准类型转换器和bean解析器，允许引用上下文中的其他bean(例如<code>@someBeanName.determineReplyQ(request, result))</code>)。</p><p>总而言之，<code>#{...}</code>在初始化期间被评估一次，<code>#root</code>对象是应用程序上下文; bean被其名称引用。在运行时对每个消息的<code>!{...}</code>进行评估，其中根对象具有上述属性，并且bean以其名称引用，以@为前缀。</p><p><strong>Multi-Method Listeners</strong><br>从版本1.5.0开始，现在可以在类级别上指定@RabbitListener注释。与新的@RabbitHandler注释一起，这允许单个监听器基于传入消息的有效载荷类型来调用不同的方法。这最好用一个例子来描述：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(id=<span class="string">"multi"</span>, queues = <span class="string">"someQueue"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiListenerBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="meta">@SendTo</span>(<span class="string">"my.reply.queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bar</span><span class="params">(Bar bar)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">baz</span><span class="params">(Baz baz)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">qux</span><span class="params">(@Header(<span class="string">"amqp_receivedRoutingKey"</span>)</span> String rk, @Payload Qux qux) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，如果转换的有效载荷是Bar，Baz或Qux，则会调用单独的@RabbitHandler方法。重要的是要了解系统必须能够基于有效载荷类型识别唯一的方法。检查类型是否具有不具有注释的单个参数的可分配性，或者使用@Payload注释进行注释。请注意，相同的方法签名适用于上述方法级@RabbitListener中讨论的方法。</p><p>请注意，必须在每个方法(如果需要)上指定@SendTo;它在类级别不支持。</p><p><strong>@Repeatable @RabbitListener</strong><br>从版本1.6开始，@RabbitListener注释被标记为@Repeatable。这意味着注释可以多次出现在相同的注释元素(方法或类)上。在这种情况下，为每个注释创建一个单独的监听器容器，每个注释都调用相同的监听器@Bean。可重复注释可与Java 8或更高版本一起使用;当使用Java 7或更早版本时，通过使用@RabbitListeners“容器”注释可以获得与@RabbitListener注释数组相同的效果。</p><p><strong>Proxy @RabbitListener and Generics</strong><br>如果您的服务旨在被代理(例如，在@Transactional的情况下)，当接口具有通用参数时，有一些注意事项。具有通用界面和特定实现，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TxService</span>&lt;<span class="title">P</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">String <span class="title">handle</span><span class="params">(P payload, String header)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TxServiceImpl</span> <span class="keyword">implements</span> <span class="title">TxService</span>&lt;<span class="title">Foo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(...)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(Foo foo, String rk)</span> </span>&#123;</span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您必须切换到CGLIB目标类代理，因为实际实现的接口句柄方法是一种桥接方法。在事务管理的情况下，使用注释选项 -  @EnableTransactionManagement(proxyTargetClass = true)来配置CGLIB的使用。在这种情况下，所有注释必须在实现中的目标方法上声明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TxServiceImpl</span> <span class="keyword">implements</span> <span class="title">TxService</span>&lt;<span class="title">Foo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(...)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(@Payload Foo foo, @Header(<span class="string">"amqp_receivedRoutingKey"</span>)</span> String rk) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Container Management</strong><br>为注释创建的容器未在应用程序上下文中注册。您可以通过调用<code>RabbitListenerEndpointRegistry</code> bean上的<code>getListenerContainers()</code>来获取所有容器的集合。然后，您可以遍历此集合，例如，停止/启动所有容器或调用注册表本身的Lifecycle方法，这将调用每个容器上的操作。</p><p>您还可以使用其id来获取对单个容器的引用，使用<code>getListenerContainer(String id)</code>;例如上面的代码段创建的容器的<code>registry.getListenerContainer(“multi”)</code>。</p><p>从1.5.2版开始，您可以使用<code>getListenerContainerIds()</code>获取注册容器的id。</p><p>从1.5版开始，您现在可以将组分配给RabbitListener端点上的容器。这提供了一种获取对容器子集的引用的机制;添加一个组属性会使一个类型为<code>Collection&lt;MessageListenerContainer&gt;</code>的bean注册到具有组名称的上下文中。</p><h5 id="Threading-and-Asynchronous-Consumers-线程和异步消费者"><a href="#Threading-and-Asynchronous-Consumers-线程和异步消费者" class="headerlink" title="Threading and Asynchronous Consumers(线程和异步消费者)"></a>Threading and Asynchronous Consumers(线程和异步消费者)</h5><p>异步消费者涉及到多线程。</p><p>在SimpleMessageListener中配置的TaskExecutor的线程用于在RabbitMQ Client发送新消息时调用MessageListener。如果未配置，则使用SimpleAsyncTaskExecutor。如果使用了线程池，请确保池大小足以处理配置的并发。</p><blockquote><p>当使用默认的SimpleAsyncTaskExecutor时，对于调用监听器的线程，监听器容器beanName用作threadNamePrefix。这对日志分析很有用;通常建议在日志追踪器配置中始终包含线程名称。当TaskExecutor通过SimpleMessageListenerContainer上的taskExecutor属性特别提供时，它将按原样使用，无需修改。建议您使用类似的技术来命名由自定义TaskExecutor bean定义创建的线程，以帮助日志消息中的线程标识。</p></blockquote><p>在CachingConnectionFactory中配置的执行程序在创建连接时被传递到RabbitMQ客户端，其线程用于将新消息传递给监听器容器。在撰写本文时，如果未配置，客户端将使用池大小为5的内部线程池执行程序。</p><p>RabbitMQ客户端使用ThreadFactory创建用于低级I / O(套接字)操作的线程。要修改此工厂，您需要配置底层RabbitMQ ConnectionFactory，如“Configuring the Underlying Client Connection Factory(配置底层客户端连接工厂)”一节中所述。</p><h5 id="Detecting-Idle-Asynchronous-Consumers-检测空闲异步消费者"><a href="#Detecting-Idle-Asynchronous-Consumers-检测空闲异步消费者" class="headerlink" title="Detecting Idle Asynchronous Consumers(检测空闲异步消费者)"></a>Detecting Idle Asynchronous Consumers(检测空闲异步消费者)</h5><p>虽然效率高， 但是异步消费者的一个问题是检测他们什么时候空闲 - 如果没有消息到达一段时间，用户可能需要采取一些行动。</p><p>从版本1.6开始，现在可以将监听器容器配置为发布ListenerContainerIdleEvent，当有一段时间没有消息传递。当容器空闲时，每个idleEventInterval毫秒将发布一个事件。</p><p>要配置此功能，请在容器上设置idleEventInterval：<br>xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">idle-event-interval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">id</span>=<span class="string">"container1"</span> <span class="attr">queue-names</span>=<span class="string">"foo"</span> <span class="attr">ref</span>=<span class="string">"myListener"</span> <span class="attr">method</span>=<span class="string">"handle"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleMessageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer(connectionFactory);</span><br><span class="line">    ...</span><br><span class="line">    container.setIdleEventInterval(<span class="number">60000L</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RabbitListener</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">    factory.setIdleEventInterval(<span class="number">60000L</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每种情况下，容器空闲时，每分钟会发布一次事件。</p><p><strong>Event Consumption</strong><br>您可以通过实现ApplicationListener来捕获这些事件，无论是通用监听器还是收件人，只能收到此特定事件。您还可以使用Spring Framework 4.2中引用的@EventListener。</p><p>以下示例将@RabbitListener和@EventListener组合到一个类中。了解应用程序监听器将获取所有容器的事件非常重要，因此如果要根据哪个容器空闲来执行特定操作，则可能需要检查监听器ID。您也可以为此使用@EventListener条件。</p><p>事件有4个属性：</p><blockquote><ul><li>source 监听器容器实例</li><li>id 监听器id(或容器bean名称)</li><li>idleTime 当事件发布时，容器空闲的时间</li><li>queueNames 容器监听到的队列的名称</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(id=<span class="string">"foo"</span>, queues=<span class="string">"#&#123;queue.name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">listen</span><span class="params">(String foo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> foo.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span>(condition = <span class="string">"event.listenerId == 'foo'"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ListenerContainerIdleEvent event)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意<br>事件听众将看到所有容器的事件;因此，在上面的示例中，我们缩小了基于监听器ID接收的事件。<br>警告<br>如果要使用空闲事件来停止lister容器，则不应在调用监听器的线程上调用container.stop()，这将导致延迟和不必要的日志消息。相反，您应该将事件切换到另一个线程，然后可以停止容器。</p></blockquote><h4 id="3-1-7-Message-Converters-消息转换器"><a href="#3-1-7-Message-Converters-消息转换器" class="headerlink" title="3.1.7 Message Converters(消息转换器)"></a>3.1.7 Message Converters(消息转换器)</h4><h5 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h5><p>AmqpTemplate还定义了几种用于发送和接收将委托给MessageConverter的消息的方法。 MessageConverter本身很简单。它为每个方向提供单一方法：一种用于转换为消息，另一种用于从消息转换。请注意，转换为消息时，除了对象之外，还可以提供属性。 “object”参数通常对应于消息体。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Message <span class="title">toMessage</span><span class="params">(Object object, MessageProperties messageProperties)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> MessageConversionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">fromMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> MessageConversionException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下列出了AmqpTemplate中的相关消息发送方法。它们比以前讨论的方法简单，因为它们不需要Message实例。相反，MessageConverter负责通过将提供的对象转换为消息体的字节数组，然后添加任何提供的MessageProperties来“创建”每个消息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String routingKey, Object message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String exchange, String routingKey, Object message)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message, MessagePostProcessor messagePostProcessor)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String routingKey, Object message,</span></span></span><br><span class="line"><span class="function"><span class="params">    MessagePostProcessor messagePostProcessor)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String exchange, String routingKey, Object message,</span></span></span><br><span class="line"><span class="function"><span class="params">    MessagePostProcessor messagePostProcessor)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure><p>在接收端，只有两种方法：一种接受队列名称，一种依赖于模板的“队列”属性已被设置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(String queueName)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure><blockquote><p>“异步消费者”一节中提到的MessageListenerAdapter也使用MessageConverter。</p></blockquote><h5 id="SimpleMessageConverter"><a href="#SimpleMessageConverter" class="headerlink" title="SimpleMessageConverter"></a>SimpleMessageConverter</h5><p>MessageConverter策略的默认实现称为SimpleMessageConverter。如果您没有显式配置替代方案，这将是RabbitTemplate实例使用的转换器。它处理基于文本的内容，序列化的Java对象和简单的字节数组。</p><p><strong>Converting From a Message</strong><br>如果输入消息的内容类型以“text”(例如“text / plain”)开头，它还将检查content-encoding属性，以确定将Message body字节数组转换为Java String时要使用的字符集。如果在输入消息中未设置content-encoding属性，则默认情况下将使用“UTF-8”字符集。如果需要覆盖该默认设置，可以配置SimpleMessageConverter的实例，设置其“defaultCharset”属性，然后将其注入到RabbitTemplate实例中。</p><p>如果输入Message的content-type属性值被设置为“application / x-java-serialized-object”，那么SimpleMessageConverter将尝试将字节数组反序列化(再水化)为Java对象。虽然这对于简单的原型设计可能是有用的，但一般不建议依赖Java序列化，因为它会导致生产者和消费者之间的紧密耦合。当然，它也排除了非Java系统在任何一方的使用。使用AMQP作为线程协议，不幸的是，通过这样的限制可以损失大部分优势。在接下来的两节中，我们将探讨一些传递丰富域对象内容的方法，而不依赖于Java序列化。</p><p>对于所有其他内容类型，SimpleMessageConverter将直接将消息体内容作为字节数组返回。</p><p>有关重要信息，请参阅“Java Deserialization”一节。</p><p><strong>Converting To a Message</strong><br>当从任意Java对象转换为消息时，SimpleMessageConverter同样处理字节数组，字符串和可序列化实例。它会将每个字节转换为字节(在字节数组的情况下，没有任何转换)，并且将相应地设置content-type属性。如果要转换的对象与这些类型不匹配，则消息体将为空。</p><h5 id="SerializerMessageConverter"><a href="#SerializerMessageConverter" class="headerlink" title="SerializerMessageConverter"></a>SerializerMessageConverter</h5><p>该转换器类似于SimpleMessageConverter，除了可以使用其他Spring Framework Serializer和Deserializer实现进行配置，以实现应用程序/ x-java-serialized-object转换。</p><h5 id="Jackson2JsonMessageConverter"><a href="#Jackson2JsonMessageConverter" class="headerlink" title="Jackson2JsonMessageConverter"></a>Jackson2JsonMessageConverter</h5><p><strong>Converting to a Message</strong><br>如上一节所述，通常不推荐依靠Java序列化。一种比较常见的替代方法是在不同语言和平台上更加灵活和便携，是JSON(JavaScript Object Notation)。可以在任何RabbitTemplate实例上配置转换器，以覆盖其SimpleMessageConverter默认值的使用。 Jackson2JsonMessageConverter使用com.fasterxml.jackson 2.x库。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.amqp.rabbit.core.RabbitTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"rabbitConnectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.amqp.support.converter.Jackson2JsonMessageConverter"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- if necessary, override the DefaultClassMapper --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"classMapper"</span> <span class="attr">ref</span>=<span class="string">"customClassMapper"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上所示，Jackson2JsonMessageConverter默认使用DefaultClassMapper。类型信息被添加到MessageProperties(并从中检索)。如果入站邮件在MessageProperties中不包含类型信息，但您知道预期的类型，则可以使用defaultType属性配置静态类型</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jsonConverterWithDefaultType"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"o.s.amqp.support.converter.Jackson2JsonMessageConverter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"classMapper"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.amqp.support.converter.DefaultClassMapper"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultType"</span> <span class="attr">value</span>=<span class="string">"foo.PurchaseOrder"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Converting from a Message</strong><br>根据发送系统添加到标题的类型信息，将入站消息转换为对象。</p><p>在1.6之前的版本中，如果类型信息不存在，转换将失败。从版本1.6开始，如果类型信息丢失，转换器将使用Jackson默认值(通常为map)转换JSON。</p><p>此外，从版本1.6开始，当使用@RabbitListener注释(在方法上)时，推断的类型信息将添加到MessageProperties中;这允许转换器转换为目标方法的参数类型。这仅适用于没有注释的一个参数或@Payload注释的单个参数。分析期间忽略消息类型的参数。</p><p>注意：</p><blockquote><p>默认情况下，推断的类型信息将覆盖由发送系统创建的入站<code>__TypeId__</code>和相关头。这允许接收系统自动转换成不同的域对象。这仅适用于参数类型为具体(不是抽象或接口)或来自java.util包的情况。在所有其他情况下，将使用<code>__TypeId__</code>和相关的标题。在某些情况下，您可能希望覆盖默认行为，并始终使用<code>__TypeId__</code>信息。例如，假设你有一个<code>@RabbitListener</code>，它接受一个Foo参数，但该消息包含一个Bar，它是Foo的一个子类(这是具体的)。推断的类型将不正确。为了处理这种情况，将<code>Jackson2JsonMessageConverter</code>上的<code>TypePrecedence</code>属性设置为<code>TYPE_ID</code>，而不是默认的<code>INFERRED</code>。该属性实际上是在转换器的<code>DefaultJackson2JavaTypeMapper</code>上，但为了方便起见，转换器上提供了一个setter。如果您注入自定义类型的映射器，则应该在映射器上设置属性。</p></blockquote><blockquote><p>从消息转换时，传入的<code>MessageProperties.getContentType()</code>必须符合JSON(使用逻辑<code>contentType.contains(“json”)</code>)。否则，<code>WARN</code>日志消息无法转换带有<code>content-type[...]</code>的传入消息，并且发送<code>message.getBody()</code> - 作为<code>byte[]</code>返回。因此，为了满足消费者方面的<code>Jackson2JsonMessageConverter</code>要求，生产者必须添加<code>contentType</code>消息属性，例如作为<code>application/json</code>，<code>text/x-json</code>或者只是使用<code>Jackson2JsonMessageConverter</code>，它将自动设置标题。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Foo foo)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(@Payload Foo foo, @Header(<span class="string">"amqp_consumerQueue"</span>)</span> String queue) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Foo foo, o.s.amqp.core.Message message)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Foo foo, o.s.messaging.Message&lt;Foo&gt; message)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Foo foo, String bar)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Foo foo, o.s.messaging.Message&lt;?&gt; message)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>在前四个情况下，转换器将尝试转换为Foo类型。第五个例子是无效的，因为我们无法确定哪个参数应该接收消息有效载荷。在第六个例子中，由于通用类型是通配符，Jackson的默认值将会被应用。</p><p>但是，您可以创建一个自定义转换器，并使用targetMethod消息属性来决定将JSON转换为哪种类型。</p><p>注意</p><blockquote><p>只有在方法级别声明@RabbitListener注释时，才能实现此类型推断。使用类级别的@RabbitListener，转换后的类型用于选择要调用哪个@RabbitHandler方法。因此，基础架构提供了可以由自定义转换器用于确定类型的targetObject消息属性。</p></blockquote><h5 id="MarshallingMessageConverter"><a href="#MarshallingMessageConverter" class="headerlink" title="MarshallingMessageConverter"></a>MarshallingMessageConverter</h5><p>另一个选择是MarshallingMessageConverter。它委托Spring OXM库的Marshaller和Unmarshaller策略接口的实现。在配置方面，最常见的是提供构造函数参数，因为Marshaller的大多数实现也将实现Unmarshaller。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.amqp.rabbit.core.RabbitTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"rabbitConnectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.amqp.support.converter.MarshallingMessageConverter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"someImplemenationOfMarshallerAndUnmarshaller"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="ContentTypeDelegatingMessageConverter"><a href="#ContentTypeDelegatingMessageConverter" class="headerlink" title="ContentTypeDelegatingMessageConverter"></a>ContentTypeDelegatingMessageConverter</h5><p>该类在1.4.2版本中引入，并允许根据MessageProperties中的内容类型属性委派给特定的MessageConverter。默认情况下，如果没有contentType属性，或者与没有配置的转换器匹配的值，它将委托给SimpleMessageConverter。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"contentTypeConverter"</span> <span class="attr">class</span>=<span class="string">"ContentTypeDelegatingMessageConverter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"delegates"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"application/json"</span> <span class="attr">value-ref</span>=<span class="string">"jsonMessageConverter"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"application/xml"</span> <span class="attr">value-ref</span>=<span class="string">"xmlMessageConverter"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="Java-Deserialization"><a href="#Java-Deserialization" class="headerlink" title="Java Deserialization"></a>Java Deserialization</h5><p>注意</p><blockquote><p>从不受信任的源反序列化java对象时，可能存在一个漏洞。如果您使用<code>content-type</code> <code>application/x-java-serialized-object</code>接受来自不受信任来源的邮件，则应考虑配置哪些包/类被允许反序列化。这适用于<code>SimpleMessageConverter</code>和<code>SerializerMessageConverter</code>，当它被配置为使用<code>DefaultDeserializer</code>  - 隐式或通过配置。默认情况下，白名单为空，表示所有类将被反序列化。您可以设置模式列表，如<code>foo.*</code>，<code>foo.bar.Baz</code>或<code>*.MySafeClass</code>。将按顺序检查模式，直到找到匹配项。如果没有匹配，则抛出<code>SecurityException</code>。使用这些转换器上的<code>whiteListPatterns</code>属性设置模式。</p></blockquote><h5 id="Message-Properties-Converters"><a href="#Message-Properties-Converters" class="headerlink" title="Message Properties Converters"></a>Message Properties Converters</h5><p>MessagePropertiesConverter策略接口用于在Rabbit Client BasicProperties和Spring AMQP MessageProperties之间进行转换。默认实现(DefaultMessagePropertiesConverter)通常足以满足大多数用途，但如果需要，您可以实现自己的。当大小不大于1024字节时，默认属性转换器将将LongString类型的BasicProperties元素转换为String。较大的LongString不会转换(见下文)。可以使用构造函数参数覆盖此限制。</p><p>从版本1.6开始，长度超过长字符串限制的标题(默认1024)现在默认由DefaultMessagePropertiesConverter保留为LongString。您可以通过<code>getBytes[]</code>，<code>toString()</code>或<code>getStream()</code>方法访问内容。</p><p>以前，DefaultMessagePropertiesConverter将这样的头部转换为DataInputStream(实际上它只是引用了LongString的DataInputStream)。在输出时，该标头未被转换(除了一个字符串，例如，通过调用流上的toString()，java.io.DataInputStream@1d057a39)。</p><p>大量传入的LongString headers现在在输出上也被正确地“转换”(默认情况下)。</p><p>提供了一个新的构造函数，允许您将转换器配置为如前所述：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct an instance where LongStrings will be returned</span></span><br><span class="line"><span class="comment"> * unconverted or as a java.io.DataInputStream when longer than this limit.</span></span><br><span class="line"><span class="comment"> * Use this constructor with 'true' to restore pre-1.6 behavior.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> longStringLimit the limit.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> convertLongLongStrings LongString when false,</span></span><br><span class="line"><span class="comment"> * DataInputStream when true.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMessagePropertiesConverter</span><span class="params">(<span class="keyword">int</span> longStringLimit, <span class="keyword">boolean</span> convertLongLongStrings)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>从1.6版开始，一个新的属性correlationIdString已经添加到MessageProperties中。以前，当转换为RabbitMQ客户端使用的BasicProperties时，会执行不必要的<code>byte[]&lt;-&gt;String</code>转换，因为MessageProperties.correlationId是一个byte[]，但是BasicProperties使用一个String。 (最终，RabbitMQ客户端使用UTF-8将String转换为字节以输入协议消息)。</p><p>为了提供最大的向后兼容性，将新的属性correlationIdPolicy添加到DefaultMessagePropertiesConverter中。这需要一个DefaultMessagePropertiesConverter.CorrelationIdPolicy枚举参数。默认情况下，它被设置为BYTES，它复制以前的行为。</p><p>入站消息：</p><blockquote><ul><li>STRING - 只有correlationIdString属性被映射</li><li>BYTES - 只有correlationId属性被映射</li><li>BOTH - 两个属性都被映射</li></ul></blockquote><p>出站消息：</p><blockquote><ul><li>STRING - 只有correlationIdString属性被映射</li><li>BYTES - 只有correlationId属性被映射</li><li>BOTH - 两个属性将被考虑，String属性优先</li></ul></blockquote><p>从版本1.6开始，入站deliveryMode属性不再映射到MessageProperties.deliveryMode，而是映射到MessageProperties.receivedDeliveryMode。此外，入站userId属性不再映射到MessageProperties.userId，而是映射到MessageProperties.receivedUserId。如果将相同的MessageProperties对象用于出站消息，则这些更改是为了避免这些属性的意外传播。</p><h4 id="3-1-8-Modifying-Messages-Compression-and-More-修改消息、压缩"><a href="#3-1-8-Modifying-Messages-Compression-and-More-修改消息、压缩" class="headerlink" title="3.1.8 Modifying Messages - Compression and More(修改消息、压缩)"></a>3.1.8 Modifying Messages - Compression and More(修改消息、压缩)</h4><p>可以在注解配置的消息接收之前或消息发送之后对消息内容进行修改</p><p>从第3.1.7节“消息转换器”可以看出，在<code>AmqpTemplate</code> <code>convertAndReceive</code>操作中，您可以提供一个<code>MessagePostProcessor</code>。<br>例如，在您的POJO被转换之后，<code>MessagePostProcessor</code>使您能够在消息中设置自定义headers或properties。</p><p>从版本1.4.2开始，其他扩展点已添加到<code>RabbitTemplate</code> - <code>setBeforePublishPostProcessors()</code>和<code>setAfterReceivePostProcessors()</code>中。第一个是后台处理器在发送到RabbitMQ之前立即运行。当使用批处理(参见“批处理”一节)时，会在批量组装之后并在发送批处理之前调用该批处理。第二个是在收到消息后立即调用。</p><p>这些扩展点用于压缩等功能，为此，提供了几个MessagePostProcessor：</p><p>用于消息发送之前处理的</p><blockquote><ul><li>GZipPostProcessor</li><li>ZipPostProcessor</li></ul></blockquote><p>用于消息接收之前处理的</p><blockquote><ul><li>GUnzipPostProcessor</li><li>UnzipPostProcessor</li></ul></blockquote><p><code>SimpleMessageListenerContainer</code>也有一个<code>setAfterReceivePostProcessors()</code>方法，允许在容器接收到消息之后执行解压缩。</p><h4 id="3-1-9-Request-Reply-Messaging-请求-回复消息"><a href="#3-1-9-Request-Reply-Messaging-请求-回复消息" class="headerlink" title="3.1.9 Request/Reply Messaging(请求/回复消息)"></a>3.1.9 Request/Reply Messaging(请求/回复消息)</h4><h5 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h5><p><code>AmqpTemplate</code>还提供了各种<code>sendAndReceive</code>方法，它们接受与单向发送操作(exchange，routingKey和Message)相同的参数选项。这些方法对于请求/回复方案非常有用，因为它们在发送之前处理必要的“回复”属性的配置，并且可以在为此目的在内部创建的排他队列上监听回复消息。</p><p>类似的请求/应答MessageConverter的方法也可以应用于请求和回复。<br>这些方法是convertSendAndReceive命名。有关更多详细信息，请参阅AmqpTemplate的Javadoc。</p><h5 id="Reply-Timeout-回复超时"><a href="#Reply-Timeout-回复超时" class="headerlink" title="Reply Timeout(回复超时)"></a>Reply Timeout(回复超时)</h5><p>默认情况下，发送和接收方法将在5秒后超时，并返回null。这可以通过设置<br><code>replyTimeout</code>属性来修改。从版本1.5开始，如果将<code>mandatory</code>属性设置为true(或<code>mandatory-expression</code>对特定消息计算为true)，则如果消息无法传递到队列，则将抛出<code>AmqpMessageReturnedException</code>。这个异常已经返回了<code>Message</code>，<code>replyCode</code>，<code>replyText</code>属性，以及用于发送的<code>exchange</code>和<code>routingKey</code>。</p><blockquote><p>此功能使用发布者返回，并通过在CachingConnectionFactory上将publisherReturns设置为true来启用(请参阅“Publisher Confirms and Returns”一节)。此外，您不能在RabbitTemplate中注册自己的ReturnCallback</p></blockquote><h5 id="RabbitMQ-Direct-reply-to-RabbitMQ直接回复"><a href="#RabbitMQ-Direct-reply-to-RabbitMQ直接回复" class="headerlink" title="RabbitMQ Direct reply-to(RabbitMQ直接回复)"></a>RabbitMQ Direct reply-to(RabbitMQ直接回复)</h5><blockquote><p>从版本3.4.0开始，RabbitMQ服务器现在支持直接回复;这是取消固定应答队列的主要原因(以避免为每个请求创建一个临时队列)。从Spring AMQP版本1.4.1开始，默认情况下将使用直接回复(如果服务器支持)，而不是创建临时回复队列。当没有提供replyQueue(或者使用名称amq.rabbitmq.reply-to设置)时，RabbitTemplate将自动检测是否支持Direct reply-to，并使用它或回退到使用临时回复队列。当使用直接回复时，不需要回复监听器，不需要配置。</p></blockquote><p>命名队列(不同于amq.rabbitmq.reply-to)支持回复监听器，允许控制回复并发等。</p><p>从1.6版开始，如果由于某些原因希望为每个回复使用临时的、排他性的自动删除队列时，请将useTemporaryReplyQueues属性设置为true。如果您设置了replyAddress，则此属性将被忽略。</p><p>可以通过对RabbitTemplate进行子类化并覆盖useDirectReplyTo()来更改是否使用直接回复。该方法只被调用一次;在发送第一个请求时。</p><h5 id="Message-Correlation-With-A-Reply-Queue-与回复队列的消息相关"><a href="#Message-Correlation-With-A-Reply-Queue-与回复队列的消息相关" class="headerlink" title="Message Correlation With A Reply Queue(与回复队列的消息相关)"></a>Message Correlation With A Reply Queue(与回复队列的消息相关)</h5><p>当使用固定的应答队列(不同于amq.rabbitmq.reply-to)时，需要提供相关数据，以便可以将请求与请求相关联。请参阅RabbitMQ远程过程调用(RPC)。默认情况下，标准correlationId属性将用于保存相关数据。但是，如果要使用自定义属性来保存关联数据，可以在<rabbit-template>上设置correlation-key属性。将属性显式设置为correlationId与默认属性相同。当然，客户端和服务器必须使用相同的头相关数据。</rabbit-template></p><blockquote><p>Spring AMQP版本1.1对此数据使用了一个自定义属性spring_reply_correlation。如果您希望使用当前版本恢复此行为，或许要使用1.1保持与其他应用程序的兼容性，则必须将属性设置为spring_reply_correlation。</p></blockquote><h5 id="Reply-Listener-Container-回复监听容器"><a href="#Reply-Listener-Container-回复监听容器" class="headerlink" title="Reply Listener Container(回复监听容器)"></a>Reply Listener Container(回复监听容器)</h5><p>在3.4.0之前使用RabbitMQ版本时，每个回复都使用一个新的临时队列。但是，可以在模板上配置单个应答队列，这样可以更有效，并且还可以在该队列中设置参数。但是，在这种情况下，您还必须提供一个<code>&lt;reply-listener /&gt;</code>子元素。此元素为回复队列提供监听器容器，模板为监听器。除了连接工厂和消息转换器之外，元素上允许使用<code>&lt;listener-container /&gt;</code>上允许的所有3.1.15节“Message Listener容器配置”属性，该属性从模板的配置继承。</p><blockquote><p>如果您运行多个应用程序实例或使用多个RabbitTemplate，则必须为每个RabbitTemplate使用唯一的应答队列，否则RabbitMQ无法从队列中选择消息，因此，如果它们都使用相同的队列，则每个实例将竞争回复而不一定收到自己的。</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"amqpTemplate"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">reply-queue</span>=<span class="string">"replies"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">reply-address</span>=<span class="string">"replyEx/routeReply"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:reply-listener</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然容器和模板共享连接工厂，但它们不共享通道，因此请求和回复不会在同一事务中执行(如果是事务性的)。</p><blockquote><p>在版本1.5.0之前，<code>reply-address</code>属性不可用，回复始终使用默认exchage和reply-queue名称作为routing key。这仍然是默认值，但您现在可以指定新的reply-address属性。reply-address可以包含一个形式为<code>&lt;exchange&gt;</code> / <code>&lt;routingKey&gt;</code>的地址，并且回复将被路由到指定的交换机并路由到与routing key绑定的队列。reply-address优先于reply-queue。必须将<code>&lt;reply-listener&gt;</code>配置为单独的<code>&lt;listener-container&gt;</code>组件，当只有reply-address正在使用时，无论如何，reply-address和reply-queue(或<code>&lt;listener-container&gt;</code>上的队列属性)必须引用在逻辑上相同的队列。</p></blockquote><p>在这个配置中,我们使用SimpleListenerContainer收到回复;当使用<code>&lt;rabbit：template /&gt;</code>定义模板时，如上所示，解析器将模板中的 container和wires定义为监听器。</p><blockquote><p>当模板不使用固定的replyQueue(或正在使用Direct reply-to  - 请参阅“RabbitMQ Direct reply-to”一节)时，不需要监听器容器。直接回复是使用RabbitMQ 3.4.0或更高版本的首选机制。</p></blockquote><p>如果您将RabbitTemplate定义为<code>&lt;bean /&gt;</code>，或者使用<code>@Configuration</code>类将其定义为<code>@Bean</code>，或者以编程方式创建模板，则需要自己定义并连接回复监听器容器。如果您无法执行此操作，模板将永远不会收到回复，并将最终超时并返回null作为对<code>sendAndReceive</code>方法的调用的回复。</p><p>从1.5版开始，RabbitTemplate将检测它是否被配置为MessageListener以接收回复。如果没有，尝试发送和接收具有回复地址的消息将失败，并显示IllegalStateException(因为不会收到回复)。</p><p>此外，如果使用一个简单的replyAddress(队列名称)，那么回复监听器容器将验证它正在监听具有相同名称的队列。如果回复地址是exchange和routing key，并且调试日志消息将被写入，则无法执行此检查。</p><blockquote><p>当您自己接收回复监听器和模板时，确保模板的replyQueue和容器的队列(或queueNames)属性引用相同的队列是非常重要的。模板将回复队列插入到出站消息replyTo属性中。</p></blockquote><p>以下是如何手动连接bean的示例。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"amqpTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.amqp.rabbit.core.RabbitTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"exchange"</span> <span class="attr">value</span>=<span class="string">"foo.exchange"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"routingKey"</span> <span class="attr">value</span>=<span class="string">"foo"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"replyQueue"</span> <span class="attr">ref</span>=<span class="string">"replyQ"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"replyTimeout"</span> <span class="attr">value</span>=<span class="string">"600000"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"queues"</span> <span class="attr">ref</span>=<span class="string">"replyQ"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"amqpTemplate"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">"replyQ"</span> <span class="attr">name</span>=<span class="string">"my.reply.queue"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">amqpTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">    rabbitTemplate.setMessageConverter(msgConv());</span><br><span class="line">    rabbitTemplate.setReplyQueue(replyQueue());</span><br><span class="line">    rabbitTemplate.setReplyTimeout(<span class="number">60000</span>);</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">replyListenerContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory());</span><br><span class="line">    container.setQueues(replyQueue());</span><br><span class="line">    container.setMessageListener(amqpTemplate());</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">replyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"my.reply.queue"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该<a href="https://github.com/spring-projects/spring-amqp/tree/master/spring-rabbit/src/test/java/org/springframework/amqp/rabbit/listener/JavaConfigFixedReplyQueueTests.java" target="_blank" rel="noopener">测试用例</a>显示了一个连接了固定应答队列的RabbitTemplate的完整示例，以及处理请求并返回答复的“远程”监听器容器。</p><blockquote><p>当回复超时(replyTimeout)时，sendAndReceive()方法返回null。</p></blockquote><p>在版本1.3.6之前，只是记录了超时消息的迟到回复。现在，如果收到迟到的回复，它将被拒绝(模板抛出一个<code>AmqpRejectAndDontRequeueException</code>)。如果回复队列被配置为将拒绝的消息发送到dead letter exchange，则可以检索回复以供稍后分析。只需使用等于回复queue名称的routing key将队列绑定到配置的dead letter exchange中。</p><p>有关配置dead lettering的更多信息，请参阅<a href="https://www.rabbitmq.com/dlx.html" target="_blank" rel="noopener"> RabbitMQ Dead Letter Documentation</a>。您还可以查看一个示例的<code>FixedReplyQueueDeadLetterTests</code>测试用例。</p><h5 id="AsyncRabbitTemplate"><a href="#AsyncRabbitTemplate" class="headerlink" title="AsyncRabbitTemplate"></a>AsyncRabbitTemplate</h5><p>版本1.6引入了<code>AsyncRabbitTemplate</code>。这与<code>AmqpTemplate</code>中的<code>sendAndReceive</code>(和<code>convertSendAndReceive</code>)类似，但是它们返回一个<code>ListenableFuture</code>。</p><p>您可以稍后通过调用<code>get()</code>来同步检索结果，也可以注册一个将结果异步调用的回调。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AsyncRabbitTemplate template;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWorkAndGetResultLater</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ListenableFuture&lt;String&gt; future = <span class="keyword">this</span>.template.convertSendAndReceive(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do some more work</span></span><br><span class="line"></span><br><span class="line">    String reply = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reply = future.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWorkAndGetResultAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    RabbitConverterFuture&lt;String&gt; future = <span class="keyword">this</span>.template.convertSendAndReceive(<span class="string">"foo"</span>);</span><br><span class="line">    future.addCallback(<span class="keyword">new</span> ListenableFutureCallback&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置了<code>mandatory</code>，并且消息无法传递，则将来会抛出一个执行错误的<code>ExecutionException</code>，其原因是<code>AmqpMessageReturnedException</code>封装返回的消息和有关返回的信息。</p><p>如果已设置enableConfirms，未来将具有一个属性确认，它本身是一个<code>ListenableFuture &lt;Boolean&gt;</code>，表示成功发布。如果确认的未来是false，RabbitFuture将有另一个属性nackCause(失败的原因(如果有的话))。</p><blockquote><p>如果在回复后收到发件人确认，则会被丢弃 - 因为回复意味着成功发布。</p></blockquote><p>设置模板上的receiveTimeout属性以配置超时回复(默认为30000  -  30秒)。如果发生超时，将来将使用AmqpReplyTimeoutException完成。</p><p>该模板实现SmartLifecycle;在有待处理的回复的情况下停止模板将导致未处理的Future被取消。</p><h5 id="Spring-Remoting-with-AMQP"><a href="#Spring-Remoting-with-AMQP" class="headerlink" title="Spring Remoting with AMQP"></a>Spring Remoting with AMQP</h5><p>Spring框架具有一般的远程处理能力，允许使用各种传输的远程过程调用(RPC)。 Spring-AMQP支持与客户端上的AmqpProxyFactoryBean和服务器上的AmqpInvokerServiceExporter类似的机制。这提供了RPC over AMQP。在客户端，如上所述使用RabbitTemplate;在服务器端，调用者(配置为MessageListener)接收消息，调用配置的服务，并使用入站消息的replyTo信息返回回复。</p><p>客户端工厂bean可以注入任何bean(使用其serviceInterface);然后，客户端可以在代理上调用方法，导致通过AMQP进行远程执行。</p><blockquote><p>使用默认MessageConverter，方法参数和返回值必须是Serializable的实例。</p></blockquote><p>在服务器端，AmqpInvokerServiceExporter具有AmqpTemplate和MessageConverter属性。目前，模板的MessageConverter没有被使用。如果您需要提供自定义消息转换器，那么您应该使用messageConverter属性提供它。在客户端，可以将自定义消息转换器添加到使用其amqpTemplate属性提供给AmqpProxyFactoryBean的AmqpTemplate中。</p><p>客户端和服务器配置示例如下所示。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"client"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.amqp.remoting.client.AmqpProxyFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"amqpTemplate"</span> <span class="attr">ref</span>=<span class="string">"template"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span> <span class="attr">value</span>=<span class="string">"foo.ServiceInterface"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"template"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> <span class="attr">reply-timeout</span>=<span class="string">"2000"</span></span></span><br><span class="line"><span class="tag"><span class="attr">routing-key</span>=<span class="string">"remoting.binding"</span> <span class="attr">exchange</span>=<span class="string">"remoting.exchange"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"remoting.queue"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">name</span>=<span class="string">"remoting.exchange"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">"remoting.queue"</span> <span class="attr">key</span>=<span class="string">"remoting.binding"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"listener"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.amqp.remoting.service.AmqpInvokerServiceExporter"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span> <span class="attr">value</span>=<span class="string">"foo.ServiceInterface"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"service"</span> <span class="attr">ref</span>=<span class="string">"service"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"amqpTemplate"</span> <span class="attr">ref</span>=<span class="string">"template"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"service"</span> <span class="attr">class</span>=<span class="string">"foo.ServiceImpl"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"template"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"remoting.queue"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">"listener"</span> <span class="attr">queue-names</span>=<span class="string">"remoting.queue"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>AmqpInvokerServiceExporter只能处理正确的消息，例如从AmqpProxyFactoryBean发送的消息。如果收到不能解释的消息，则将序列化的RuntimeException作为回复发送。如果该消息没有replyToAddress属性，且未配置Dead Letter Exchange，该消息将被拒绝并永久丢失。</p></blockquote><br>> 默认情况下，如果请求消息无法传递，则调用线程将最终超时，并将抛出RemoteProxyFailureException。超时时间默认为5秒，可以通过设置RabbitTemplate上的replyTimeout属性进行修改。从1.5版开始，将mandatory属性设置为true，并在连接工厂启用返回(请参阅“发布者确认和返回”一节)，调用线程将抛出一个AmqpMessageReturnedException。有关详细信息，请参阅“回复超时”一节。<h4 id="3-1-10-Configuring-the-broker"><a href="#3-1-10-Configuring-the-broker" class="headerlink" title="3.1.10 Configuring the broker"></a>3.1.10 Configuring the broker</h4><h5 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h5><p>AMQP规范描述了如何使用协议来配置代理上的队列，交换和绑定。这些可从0.8规范和更高版本移植的操作存在于org.springframework.amqp.core包中的AmqpAdmin界面中。该类的RabbitMQ实现是位于org.springframework.amqp.rabbit.core包中的RabbitAdmin。</p><p>AmqpAdmin接口基于使用Spring AMQP域抽象，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AmqpAdmin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exchange Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">declareExchange</span><span class="params">(Exchange exchange)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteExchange</span><span class="params">(String exchangeName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Queue <span class="title">declareQueue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">declareQueue</span><span class="params">(Queue queue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteQueue</span><span class="params">(String queueName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteQueue</span><span class="params">(String queueName, <span class="keyword">boolean</span> unused, <span class="keyword">boolean</span> empty)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">purgeQueue</span><span class="params">(String queueName, <span class="keyword">boolean</span> noWait)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binding Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">declareBinding</span><span class="params">(Binding binding)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeBinding</span><span class="params">(Binding binding)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Properties <span class="title">getQueueProperties</span><span class="params">(String queueName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getQueueProperties()方法返回有关队列的一些有限信息(消息计数和消费者计数)。返回的属性的键可用作RabbitTemplate(QUEUE_NAME，QUEUE_MESSAGE_COUNT，QUEUE_CONSUMER_COUNT)中的常量。 RabbitMQ REST API在QueueInfo对象中提供了更多的信息。</p><p>no-arg declareQueue()方法定义了一个自动生成名称的代理上的队列。此自动生成队列的附加属性为exclusive = true，autoDelete = true和durable = false。</p><p>declareQueue(Queue queue)方法接受Queue对象并返回声明队列的名称。如果提供的Queue的name属性是空字符串，则代理使用生成的名称声明队列，并将该名称返回给调用者。队列对象本身没有改变。此功能只能通过直接调用RabbitAdmin以编程方式使用。管理员自动声明不支持在应用程序上下文中声明性地定义队列。</p><p>这与AnonymousQueue形成对照，其中框架生成一个唯一的(UUID)名称，并将持久性设置为false和exclusive，autoDelete为true。具有空或缺少的name属性的<code>&lt;rabbit：queue /&gt;</code>将始终创建AnonymousQueue。</p><p>请参阅“AnonymousQueue”部分了解为什么AnonymousQueue优先于代理生成的队列名称，以及如何控制名称的格式。声明队列必须具有固定名称，因为它们可能在上下文中的其他位置被引用，例如在监听器中：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">"listener"</span> <span class="attr">queue-names</span>=<span class="string">"#&#123;someQueue.name&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请参考“Automatic Declaration of Exchanges, Queues and Bindings”这一节.</p><p>该接口的RabbitMQ实现是RabbitAdmin，当使用Spring XML进行配置时，它将如下所示：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">"amqpAdmin"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当CachingConnectionFactory缓存模式是CHANNEL(默认值)时，RabbitAdmin实现会在同一个ApplicationContext中声明的Queue，Exchanges和Bindings自动延迟声明。这些组件将被声明为s0on，因为连接已打开到代理。有一些命名空间功能使得这非常方便，例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">"tradeQueue"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">"marketDataQueue"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fanout-exchange</span> <span class="attr">name</span>=<span class="string">"broadcast.responses"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/rabbit"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bindings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">binding</span> <span class="attr">queue</span>=<span class="string">"tradeQueue"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fanout-exchange</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">topic-exchange</span> <span class="attr">name</span>=<span class="string">"app.stock.marketdata"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/rabbit"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bindings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">binding</span> <span class="attr">queue</span>=<span class="string">"marketDataQueue"</span> <span class="attr">pattern</span>=<span class="string">"$&#123;stocks.quote.pattern&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">topic-exchange</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，我们使用匿名队列(实际上内部只是具有由框架生成的名称的队列，而不是broker)，并通过ID引用它们。我们还可以使用显式名称声明队列，这也可以作为上下文中bean定义的标识符。例如。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"stocks.trade.queue"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>您可以同时提供id和name属性。这允许您通过独立于队列名称的id来引用队列(例如在绑定中)。它还允许标准的Spring功能，如属性占位符和队列名称的SpEL表达式;当使用名称作为bean标识符时，这些功能不可用。</p></blockquote><p>可以使用其他参数配置队列，例如x-message-ttl或x-ha-policy。使用命名空间支持，使用<code>&lt;rabbit：queue-arguments&gt;</code>元素以参数名称/参数值对映射的形式提供它们。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"withArguments"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"x-ha-policy"</span> <span class="attr">value</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认情况下，这些参数被假定为字符串。对于其他类型的参数，需要提供类型。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"withArguments"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span> <span class="attr">value-type</span>=<span class="string">"java.lang.Long"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"x-message-ttl"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当提供混合类型的参数时，为每个条目元素提供类型：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"withArguments"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"x-message-ttl"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span> <span class="attr">type</span>=<span class="string">"java.lang.Long"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"x-ha-policy"</span> <span class="attr">value</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用Spring Framework 3.2及更高版本，可以更简洁地声明这一点：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"withArguments"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"x-message-ttl"</span> <span class="attr">value</span>=<span class="string">"100"</span> <span class="attr">value-type</span>=<span class="string">"java.lang.Long"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"x-ha-policy"</span> <span class="attr">value</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>RabbitMQ代理将不允许声明具有不匹配参数的队列。例如，如果<code>queue</code>已经存在，没有<code>time to live</code>参数，并且尝试使用<code>key =“x-message-ttl”value =“100”</code>进行声明，则会抛出异常。</p></blockquote><p>默认情况下，当发生任何异常时，RabbitAdmin将立即停止处理所有声明;这可能会导致下游问题，例如监听器容器无法初始化，因为未声明另一个队列(在错误之后定义)。</p><p>可以通过在RabbitAdmin上将ignore-declaration-exceptions属性设置为true来修改此行为。此选项指示RabbitAdmin记录异常，并继续声明其他元素。当使用java配置RabbitAdmin时，此属性为ignoreDeclarationExceptions。这是一个适用于所有元素，队列，交换和绑定的全局设置，具有仅适用于这些元素的类似属性。</p><p>在版本1.6之前，此属性仅在通道上发生IOException(例如当前和所需属性不匹配时)才会生效。现在，此属性对任何异常生效，包括TimeoutException等。</p><p>另外，任何声明异常将导致发布DeclarationExceptionEvent，它是可以由上下文中任何ApplicationListener使用的ApplicationEvent。该事件包含对管理员的引用，被声明的元素和Throwable。</p><p>从版本1.3开始，HeadersExchange可以配置为匹配多个标头;您还可以指定任何或所有标题必须匹配：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:headers-exchange</span> <span class="attr">name</span>=<span class="string">"headers-test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">"bucket"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding-arguments</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"bar"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"baz"</span> <span class="attr">value</span>=<span class="string">"qux"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"x-match"</span> <span class="attr">value</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">rabbit:binding-arguments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:headers-exchange</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从版本1.6开始 Exchanges可以使用internal标志(默认为false)进行配置，并且Exchange将通过RabbitAdmin(如果存在于应用程序上下文中)在代理上正确配置。如果交换机的内部标志为true，则RabbitMQ将不允许客户端使用交换机。这对于您不希望交易所直接由发布商使用的死信交换或交换到交换绑定非常有用。</p><p>要了解如何使用Java来配置AMQP基础设施，请查看Stock示例应用程序，其中有@Configuration类AbstractStockRabbitConfiguration，它们又具有RabbitClientConfiguration和RabbitServerConfiguration子类。 AbstractStockRabbitConfiguration的代码如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStockAppRabbitConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory =</span><br><span class="line">            <span class="keyword">new</span> CachingConnectionFactory(<span class="string">"localhost"</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">        template.setMessageConverter(jsonMessageConverter());</span><br><span class="line">        configureRabbitTemplate(template);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageConverter <span class="title">jsonMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">marketDataExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"app.stock.marketdata"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// additional code omitted for brevity</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在库存应用程序中，服务器使用以下@Configuration类进行配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitServerConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractStockAppRabbitConfiguration</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">stockRequestQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"app.stock.request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是@Configuration类的整个继承链的结尾。最终的结果是在应用程序启动时，TopicExchange和Queue将被声明给代理。在服务器配置中没有将TopicExchange绑定到队列，因为这在客户端应用程序中完成。然而，库存请求队列将自动绑定到AMQP默认交换 - 此行为由规范定义。</p><p>客户端@Configuration类有点有趣，如下所示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitClientConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractStockAppRabbitConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;stocks.quote.pattern&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String marketDataRoutingKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">marketDataQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amqpAdmin().declareQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Binds to the market data exchange.</span></span><br><span class="line"><span class="comment">     * Interested in any stock quotes</span></span><br><span class="line"><span class="comment">     * that match its routing key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">marketDataBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(</span><br><span class="line">                marketDataQueue()).to(marketDataExchange()).with(marketDataRoutingKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// additional code omitted for brevity</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端通过AmqpAdmin上的declareQueue()方法声明另一个队列，并通过在外部属性文件中的routing pattern 将该队列绑定到market data exchange。</p><h5 id="Builder-API-for-Queues-and-Exchanges-构建Queues和Exchanges的API"><a href="#Builder-API-for-Queues-and-Exchanges-构建Queues和Exchanges的API" class="headerlink" title="Builder API for Queues and Exchanges(构建Queues和Exchanges的API)"></a>Builder API for Queues and Exchanges(构建Queues和Exchanges的API)</h5><p>版本1.6引入了方便的API，用于在使用Java配置时配置queue和Exchange对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.nonDurable(<span class="string">"foo"</span>)</span><br><span class="line">        .autoDelete()</span><br><span class="line">        .exclusive()</span><br><span class="line">        .withArgument(<span class="string">"foo"</span>, <span class="string">"bar"</span>)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Exchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">"foo"</span>)</span><br><span class="line">      .autoDelete()</span><br><span class="line">      .internal()</span><br><span class="line">      .withArgument(<span class="string">"foo"</span>, <span class="string">"bar"</span>)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关更多信息，请参阅org.springframework.amqp.core.QueueBuilder和org.springframework.amqp.core.ExchangeBuilder的javadocs。</p><h5 id="Declaring-Collections-of-Exchanges-Queues-Bindings-声明交换、队列、绑定的集合"><a href="#Declaring-Collections-of-Exchanges-Queues-Bindings-声明交换、队列、绑定的集合" class="headerlink" title="Declaring Collections of Exchanges, Queues, Bindings(声明交换、队列、绑定的集合)"></a>Declaring Collections of Exchanges, Queues, Bindings(声明交换、队列、绑定的集合)</h5><p>从1.5版开始，现在可以通过重新生成一个集合来声明一个@Bean的多个实体。</p><p>只考虑第一个元素是可声明的集合，并且只处理来自这些集合的可声明元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">cf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CachingConnectionFactory(<span class="string">"localhost"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitAdmin <span class="title">admin</span><span class="params">(ConnectionFactory cf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RabbitAdmin(cf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">e1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"e1"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">q1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"q1"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">b1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(q1()).to(e1()).with(<span class="string">"k1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Exchange&gt; <span class="title">es</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.&lt;Exchange&gt;asList(</span><br><span class="line">    <span class="keyword">new</span> DirectExchange(<span class="string">"e2"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>),</span><br><span class="line">    <span class="keyword">new</span> DirectExchange(<span class="string">"e3"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)</span><br><span class="line">    );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Queue&gt; <span class="title">qs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> Queue(<span class="string">"q2"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>),</span><br><span class="line">    <span class="keyword">new</span> Queue(<span class="string">"q3"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)</span><br><span class="line">    );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Binding&gt; <span class="title">bs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> Binding(<span class="string">"q2"</span>, DestinationType.QUEUE, <span class="string">"e2"</span>, <span class="string">"k2"</span>, <span class="keyword">null</span>),</span><br><span class="line">    <span class="keyword">new</span> Binding(<span class="string">"q3"</span>, DestinationType.QUEUE, <span class="string">"e3"</span>, <span class="string">"k3"</span>, <span class="keyword">null</span>)</span><br><span class="line">    );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Declarable&gt; <span class="title">ds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.&lt;Declarable&gt;asList(</span><br><span class="line">    <span class="keyword">new</span> DirectExchange(<span class="string">"e4"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>),</span><br><span class="line">    <span class="keyword">new</span> Queue(<span class="string">"q4"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>),</span><br><span class="line">    <span class="keyword">new</span> Binding(<span class="string">"q4"</span>, DestinationType.QUEUE, <span class="string">"e4"</span>, <span class="string">"k4"</span>, <span class="keyword">null</span>)</span><br><span class="line">    );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Conditional-Declaration-条件声明"><a href="#Conditional-Declaration-条件声明" class="headerlink" title="Conditional Declaration(条件声明)"></a>Conditional Declaration(条件声明)</h5><p>默认情况下，所有队列，交换和绑定都由应用程序上下文中的所有RabbitAdmin实例(具有auto-startup =“true”)声明。</p><blockquote><p>从1.2版本开始，可以有条件地声明这些元素。当应用程序连接到多个代理程序并且需要指定哪个代理程序应该声明特定元素时，这是特别有用的。</p></blockquote><p>代表这些元素的类实现Declarable，它有两个方法：shouldDeclare()和getDeclaringAdmins()。 RabbitAdmin使用这些方法来确定特定实例是否应该实际处理其连接上的声明。</p><p>这些属性作为命名空间中的属性，如以下示例所示。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">"admin1"</span> <span class="attr">connection-factory</span>=<span class="string">"CF1"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">"admin2"</span> <span class="attr">connection-factory</span>=<span class="string">"CF2"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">"declaredByBothAdminsImplicitly"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">"declaredByBothAdmins"</span> <span class="attr">declared-by</span>=<span class="string">"admin1, admin2"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">"declaredByAdmin1Only"</span> <span class="attr">declared-by</span>=<span class="string">"admin1"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">"notDeclaredByAny"</span> <span class="attr">auto-declare</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">name</span>=<span class="string">"direct"</span> <span class="attr">declared-by</span>=<span class="string">"admin1, admin2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">key</span>=<span class="string">"foo"</span> <span class="attr">queue</span>=<span class="string">"bar"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，auto-declare属性为true，如果未提供声明(或为空)，则所有RabbitAdmin将声明该对象(只要admin的auto-startup属性为true;默认值为true)。</p></blockquote><p>同样，您也可以使用基于Java的@Configuration实现相同的效果。在这个例子中，这些组件将由admin1声明，而不是admin2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitAdmin <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RabbitAdmin rabbitAdmin = <span class="keyword">new</span> RabbitAdmin(cf1());</span><br><span class="line">    rabbitAdmin.afterPropertiesSet();</span><br><span class="line">    <span class="keyword">return</span> rabbitAdmin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitAdmin <span class="title">admin2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RabbitAdmin rabbitAdmin = <span class="keyword">new</span> RabbitAdmin(cf2());</span><br><span class="line">    rabbitAdmin.afterPropertiesSet();</span><br><span class="line">    <span class="keyword">return</span> rabbitAdmin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"foo"</span>);</span><br><span class="line">    queue.setAdminsThatShouldDeclare(admin());</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Exchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DirectExchange exchange = <span class="keyword">new</span> DirectExchange(<span class="string">"bar"</span>);</span><br><span class="line">    exchange.setAdminsThatShouldDeclare(admin());</span><br><span class="line">    <span class="keyword">return</span> exchange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Binding binding = <span class="keyword">new</span> Binding(<span class="string">"foo"</span>, DestinationType.QUEUE, exchange().getName(), <span class="string">"foo"</span>, <span class="keyword">null</span>);</span><br><span class="line">    binding.setAdminsThatShouldDeclare(admin());</span><br><span class="line">    <span class="keyword">return</span> binding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AnonymousQueue"><a href="#AnonymousQueue" class="headerlink" title="AnonymousQueue"></a>AnonymousQueue</h5><p>通常，当需要唯一命名的，排他性的自动删除队列时，建议使用AnonymousQueue而不是代理定义的队列名称(使用“”作为队列名称将导致broker生成队列名称) 。</p><p>原因如下：</p><ol><li>在建立到代理的连接时，队列实际上是被声明的；这是在bean被创建并连接在一起之后的很长时间；使用队列的bean需要知道它的名字。事实上，当应用程序启动时，代理甚至可能无法运行。</li><li>如果由于某种原因与代理的连接丢失，则管理员将重新声明具有相同名称的AnonymousQueue。如果我们使用代理声明的队列，队列名称将会更改。</li></ol><p>从1.5.3版开始，您可以控制AnonymousQueue使用的队列名称的格式。</p><p>默认情况下，队列名称是UUID的String表示形式;例如：07afcfe9-fe77-4983-8645-0061ec61a47a。</p><p>您现在可以在构造函数参数中提供AnonymousQueue.NamingStrategy实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">anon1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnonymousQueue(<span class="keyword">new</span> AnonymousQueue.Base64UrlNamingStrategy());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">anon2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnonymousQueue(<span class="keyword">new</span> AnonymousQueue.Base64UrlNamingStrategy(<span class="string">"foo-"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个将生成一个前缀为spring.gen-的后缀为UUID的base64表示形式的队列名称，例如：spring.gen-MRBv9sqISkuCiPfOYfpo4g。第二个将生成一个以foo为前缀的队列名称，后跟UUID的base64表示形式。</p><p>Base64的编码采用“URL和文件安全的字母“RFC 4648；尾部的填充字符(=)被移除。</p><p>您可以提供自己的命名策略，您可以将其他信息(例如应用程序，客户端主机)包含在队列名称中。</p><p>从版本1.6开始，可以在使用XML配置时指定命名策略;命名策略属性存在于实现AnonymousQueue.NamingStrategy的bean引用的<code>&lt;rabbit：queue&gt;</code>元素中。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">"uuidAnon"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">"springAnon"</span> <span class="attr">naming-strategy</span>=<span class="string">"springNamer"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">"customAnon"</span> <span class="attr">naming-strategy</span>=<span class="string">"customNamer"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"springNamer"</span> <span class="attr">class</span>=<span class="string">"org.springframework.amqp.core.AnonymousQueue.Base64UrlNamingStrategy"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customNamer"</span> <span class="attr">class</span>=<span class="string">"org.springframework.amqp.core.AnonymousQueue.Base64UrlNamingStrategy"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"custom.gen-"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第一个创建具有UUID的String表示形式的名称。第二个创建名称如spring.gen-MRBv9sqISkuCiPfOYfpo4g。第三个创建名称，如custom.gen-MRBv9sqISkuCiPfOYfpo4g</p><p>当然，您可以提供自己的命名策略bean。</p><h4 id="3-1-11-Delayed-Message-Exchange-延迟消息Exchange"><a href="#3-1-11-Delayed-Message-Exchange-延迟消息Exchange" class="headerlink" title="3.1.11 Delayed Message Exchange(延迟消息Exchange)"></a>3.1.11 Delayed Message Exchange(延迟消息Exchange)</h4><p>1.6版引入了对延迟消息exchange插件的支持</p><blockquote><p>该插件目前被标记为实验性，但已有一年以上(在撰写本文时)。如果插件的更改需要，我们将尽快添加对这些更改的支持。因此，Spring AMQP中的这种支持也应该被认为是实验性的。该功能使用RabbitMQ 3.6.0和版本0.0.1的插件进行了测试。</p></blockquote><p>要使用RabbitAdmin将延迟声明为exchange，只需将exchange bean上的delayed属性设置为true即可。 RabbitAdmin将使用交换类型(Direct，Fanout等)设置x-delayed-type参数，并使用x-delayed-message类型声明交换。</p><p>使用XML配置交换bean时，delayed(默认为false)也可用。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:topic-exchange</span> <span class="attr">name</span>=<span class="string">"topic"</span> <span class="attr">delayed</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>要发送延迟的消息，只需要通过MessageProperties设置x-delay：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageProperties properties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">properties.setDelay(<span class="number">15000</span>);</span><br><span class="line">template.send(exchange, routingKey,</span><br><span class="line">        MessageBuilder.withBody(<span class="string">"foo"</span>.getBytes()).andProperties(properties).build());</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(exchange, routingKey, <span class="string">"foo"</span>, <span class="keyword">new</span> MessagePostProcessor() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">        message.getMessageProperties().setDelay(<span class="number">15000</span>);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要检查消息是否延迟，请在MessageProperties上使用getReceivedDelay()方法。它是一个单独的属性，以避免意外传播到从输入消息生成的输出消息。</p><h4 id="3-1-12-RabbitMQ-REST-API"><a href="#3-1-12-RabbitMQ-REST-API" class="headerlink" title="3.1.12 RabbitMQ REST API"></a>3.1.12 RabbitMQ REST API</h4><p>启用管理插件后，RabbitMQ服务器公开一个REST API来监视和配置代理。现在提供了API的Java绑定。一般来说，您可以直接使用该API，但是提供了一个方便的包装器来使用熟悉的Spring AMQP队列、Exchange和Binding域对象与API。当直接使用com.rabbitmq.http.client.Client API(分别为QueueInfo，ExchangeInfo和BindingInfo)时，这些对象可以获得更多信息。以下操作在RabbitManagementTemplate上可用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AmqpManagementOperations</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addExchange</span><span class="params">(Exchange exchange)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addExchange</span><span class="params">(String vhost, Exchange exchange)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">purgeQueue</span><span class="params">(Queue queue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">purgeQueue</span><span class="params">(String vhost, Queue queue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteQueue</span><span class="params">(Queue queue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteQueue</span><span class="params">(String vhost, Queue queue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Queue <span class="title">getQueue</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Queue <span class="title">getQueue</span><span class="params">(String vhost, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Queue&gt; <span class="title">getQueues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Queue&gt; <span class="title">getQueues</span><span class="params">(String vhost)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(Queue queue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(String vhost, Queue queue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteExchange</span><span class="params">(Exchange exchange)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteExchange</span><span class="params">(String vhost, Exchange exchange)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Exchange <span class="title">getExchange</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Exchange <span class="title">getExchange</span><span class="params">(String vhost, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Exchange&gt; <span class="title">getExchanges</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Exchange&gt; <span class="title">getExchanges</span><span class="params">(String vhost)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Binding&gt; <span class="title">getBindings</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Binding&gt; <span class="title">getBindings</span><span class="params">(String vhost)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Binding&gt; <span class="title">getBindingsForExchange</span><span class="params">(String vhost, String exchange)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关详细信息，请参阅javadocs。</p><h4 id="3-1-13-Exception-Handling-异常处理器"><a href="#3-1-13-Exception-Handling-异常处理器" class="headerlink" title="3.1.13 Exception Handling(异常处理器)"></a>3.1.13 Exception Handling(异常处理器)</h4><p>使用RabbitMQ Java客户端的许多操作可以抛出已检查的异常。例如，可能会抛出IOExceptions的情况很多。 RabbitTemplate，SimpleMessageListenerContainer和其他Spring AMQP组件将捕获这些异常并将其转换为运行时层次结构中的一个异常。这些在org.springframework.amqp包中定义，AmqpException是层次结构的基础。</p><p>当一个监听器抛出一个异常时，它被包装在一个ListenerExecutionFailedException中，通常这个消息被代理拒绝和重新排序。将defaultRequeueRejected设置为false将导致消息被丢弃(或路由到dead letter exchange)。如在“消息监听器和异步事件”一节中所讨论的，监听器可以抛出一个AmqpRejectAndDontRequeueException来有条件地控制这种行为。</p><p>但是，有一类错误，监听器无法控制行为。当遇到无法转换的消息(例如无效的content_encoding标头)时，会在消息达到用户代码之前抛出一些异常。将defaultRequeueRejected设置为true(默认)，这些消息将被重新传递。在版本1.3.2之前，用户需要编写一个自定义的ErrorHandler，如3.1.13节“异常处理”所述，以避免这种情况。</p><p>从版本1.3.2开始，默认的ErrorHandler现在是一个ConditionalRejectingErrorHandler，它将拒绝(而不是重新排序)消息，并发生不可恢复的错误：</p><blockquote><ul><li>o.s.amqp…MessageConversionException</li><li>o.s.messaging…MessageConversionException</li><li>o.s.messaging…MethodArgumentNotValidException</li><li>o.s.messaging…MethodArgumentTypeMismatchException</li><li>java.lang.NoSuchMethodException</li><li>java.lang.ClassCastException</li></ul></blockquote><p>使用MessageConverter转换传入的消息有效负载时，可以抛出第一个。如果在映射到@RabbitListener方法时需要额外的转换，则转换服务可能会抛出第二个。如果在监听器中使用验证(例如@Valid)，并且验证失败，则可能会抛出第三个。如果入站邮件转换为目标方法不正确的类型，则可能会抛出第四个邮件。例如，该参数被声明<code>为Message&lt;Foo&gt;</code>，但接收到<code>Message&lt;Bar&gt;</code>。</p><p>版本1.6.3中添加了第五和第六。</p><p>可以使用FatalExceptionStrategy配置此错误处理程序的实例，以便用户可以提供自己的条件消息拒绝规则，例如。来自Spring Retry(称为“消息监听器和异步情况”的部分)的BinaryExceptionClassifier的委托实现。另外，ListenerExecutionFailedException现在有一个failMessage属性可以在决定中使用。如果FatalExceptionStrategy.isFatal()方法返回true，则错误处理程序将抛出一个AmqpRejectAndDontRequeueException异常。当异常确定为致命时，默认的FatalExceptionStrategy会记录一条警告消息。</p><p>自1.6.3版本以来，将用户异常添加到致命列表中的方便方法是将ConditionalRejectingErrorHandler.DefaultExceptionStrategy子类化，并覆盖方法isUserCauseFatal(Throwable cause)为致命异常返回true。</p><h4 id="3-1-14-Transactions-事务"><a href="#3-1-14-Transactions-事务" class="headerlink" title="3.1.14 Transactions(事务)"></a>3.1.14 Transactions(事务)</h4><h5 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h5><p>Spring Rabbit框架支持在同步和异步使用情况下进行自动事务管理，具有多种不同的语义，可以声明式选择，正如Spring事务的现有用户所熟悉的那样。这使得许多如果不是最常见的消息传递模式非常容易实现。</p><p>有两种方式将所需的事务语义信号发送到框架。在RabbitTemplate和SimpleMessageListenerContainer中都有一个标志channelTransacted，如果为true，则告知框架使用事务通道，并根据结果结束提交或回滚以结束所有操作(发送或接收)，并发出异常指示回滚。另一个信号是提供一个外部事务与Spring的PlatformTransactionManager实现之一作为正在进行的操作的上下文。如果在框架发送或接收消息时已经有一个事务正在进行，并且channelTransacted标志为真，那么消息传递事务的提交或回滚将被推迟到当前事务结束。如果channelTransacted标志为false，则没有事务语义适用于消息传递操作(它是自动检测的)。</p><p>channelTransacted标志是一个配置时间设置：当AMQP组件被创建时，它通常在应用程序启动时被声明和处理一次。外部事务原则上更动态，因为系统在运行时响应当前的Thread状态，但实际上当事务按声明方式分层到应用程序时通常也是一个配置设置。</p><p>对于使用RabbitTemplate的同步用例，外部事务由调用者提供，无论是声明性还是根据味道(通常的Spring事务模型)强制执行。声明性方法(通常是首选，因为它是非侵入性的)的示例，其中模板已配置为channelTransacted = true：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String incoming = rabbitTemplate.receiveAndConvert();</span><br><span class="line">    <span class="comment">// do some more database processing...</span></span><br><span class="line">    String outgoing = processInDatabaseAndExtractReply(incoming);</span><br><span class="line">    rabbitTemplate.convertAndSend(outgoing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个标记为@Transactional的方法内接收、转换和发送一个字符串作为一个消息体，因此如果数据库处理异常失败，传入的消息将返回给代理，而传出的消息将不会被发送。</p><p>对于使用SimpleMessageListenerContainer的异步使用情况，如果需要外部事务，则必须在容器设置监听器时请求它。为了表明需要外部事务，用户在配置时向容器提供了PlatformTransactionManager的实现。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleExternalTransactionAmqpConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">        container.setTransactionManager(transactionManager());</span><br><span class="line">        container.setChannelTransacted(<span class="keyword">true</span>);</span><br><span class="line">        container.setQueueName(<span class="string">"some.queue"</span>);</span><br><span class="line">        container.setMessageListener(exampleListener());</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，事务管理器被添加为从另一个bean定义(未显示)注入的依赖关系，并且channelTransacted标志也被设置为true。效果是，如果监听器失败并发生异常，则事务将被回滚，并且该消息也将返回给代理。重要的是，如果事务无法提交(例如数据库约束错误或连接性问题)，则AMQP事务也将被回滚，并且该消息将被返回给代理。这有时被称为最佳努力1阶段提交，并且是可靠消息传递的非常强大的模式。如果在上面的示例中将channelTransacted标志设置为false，这是默认值，则仍将为监听器提供外部事务，但所有消息传递操作都将自动检测，因此其效果是即使提交消息传递操作在业务运行的回滚。</p><h5 id="Conditional-Rollback"><a href="#Conditional-Rollback" class="headerlink" title="Conditional Rollback"></a>Conditional Rollback</h5><p>在版本1.6.6之前，当回收规则添加到容器的transactionAttribute中时，使用外部事务管理器(例如JDBC)不起作用;异常总是回滚事务。</p><p>此外，当在容器的建议链中使用<a href="http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/transaction.html#transaction-declarative" target="_blank" rel="noopener">事务建议</a>时，条件回滚并不是非常有用，因为所有监听器异常都被包装在ListenerExecutionFailedException中。</p><p>第一个问题已得到纠正，规则现在得到适当应用。此外，现在提供了ListenerFailedRuleBasedTransactionAttribute;它是RuleBasedTransactionAttribute的一个子类，唯一的区别是它知道ListenerExecutionFailedException，并且使用规则的这种异常的原因。此事务属性可以直接在容器中使用，也可以通过事务建议使用。</p><p>使用此规则的示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractMessageListenerContainer <span class="title">container</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    container.setTransactionManager(transactionManager);</span><br><span class="line">    RuleBasedTransactionAttribute transactionAttribute =</span><br><span class="line">        <span class="keyword">new</span> ListenerFailedRuleBasedTransactionAttribute();</span><br><span class="line">    transactionAttribute.setRollbackRules(Collections.singletonList(</span><br><span class="line">        <span class="keyword">new</span> NoRollbackRuleAttribute(DontRollBackException.class)));</span><br><span class="line">    container.setTransactionAttribute(transactionAttribute);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="A-note-on-Rollback-of-Received-Messages"><a href="#A-note-on-Rollback-of-Received-Messages" class="headerlink" title="A note on Rollback of Received Messages"></a>A note on Rollback of Received Messages</h5><p>AMQP事务只适用于发送到代理的消息和acks，所以当回滚Spring事务并且收到一条消息时，Spring AMQP必须做的不仅仅是回滚事务，而且手动拒绝消息(这是一个坏消息，但这不是规范所说的)。对消息拒绝采取的操作与事务无关，并且取决于defaultRequeueRejected属性(默认为true)。有关拒绝失败消息的更多信息，请参阅“消息监听器和异步事件”一节。</p><p>有关RabbitMQ事务的更多信息及其限制，请参阅RabbitMQ代理语法。</p><blockquote><p>在RabbitMQ 2.7.0之前，这样的消息(以及任何在通道关闭或中断时未被解除的消息)都会到达Rabbit代理队列的后面，因为2.7.0，拒绝的消息到队列的前面，以与JMS相似的方式回滚消息。</p></blockquote><blockquote><p>事务回滚中的消息重新排序在本地事务和提供TransactionManager时不一致。在前一种情况下，适用正常的重新排序逻辑(AmqpRejectAndDontRequeueException或defaultRequeueRejected = false)(参见“消息监听器和异步情况”一节);与一个事务管理器，该消息是无条件地回滚。从版本1.7.1开始，您可以通过将容器的alwaysRequeueWithTxManagerRollback属性设置为false来启用一致的行为;在默认情况下，它将为false。请参见第3.1.15节“消息监听器容器配置”。</p></blockquote><h5 id="Using-the-RabbitTransactionManager"><a href="#Using-the-RabbitTransactionManager" class="headerlink" title="Using the RabbitTransactionManager"></a>Using the RabbitTransactionManager</h5><p>RabbitTransactionManager是在外部事务中执行Rabbit操作并与外部事务同步的替代方法。此事务管理器是PlatformTransactionManager接口的实现，应与单个Rabbit ConnectionFactory一起使用。</p><blockquote><p>此策略不能提供XA事务，例如为了在消息传递和数据库访问之间共享事务。</p></blockquote><p>需要应用程序代码通过ConnectionFactoryUtils.getTransactionalResourceHolder(ConnectionFactory，boolean)来检索事务性Rabbit资源，而不是后续通道创建时的标准Connection.createChannel()调用。当使用Spring AMQP的RabbitTemplate时，它将自动检测线程绑定的通道并自动参与其事务。</p><p>使用Java配置，您可以使用以下方式设置新的RabbitTransactionManager：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTransactionManager <span class="title">rabbitTransactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RabbitTransactionManager(connectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您喜欢使用XML配置，请在XML应用程序上下文文件中声明以下bean：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rabbitTxManager"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.amqp.rabbit.transaction.RabbitTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-15-Message-Listener-Container-Configuration-Message-Listener容器配置"><a href="#3-1-15-Message-Listener-Container-Configuration-Message-Listener容器配置" class="headerlink" title="3.1.15 Message Listener Container Configuration(Message Listener容器配置)"></a>3.1.15 Message Listener Container Configuration(Message Listener容器配置)</h4><p>有很多的选项配置SimpleMessageListenerContainer相关事务和服务，其中一些可以相互作用。</p><p>下表显示了使用命名空间配置<code>&lt;rabbit：listener-container /&gt;</code>时的容器属性名称及其等效属性名称(括号中)。</p><p>PS：其他内容还在继续翻译当中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h2&gt;&lt;p&gt;Spring AMQP项目是用于开发AMQP的解决方案。 我们提供一个“模板”作为发送和接收消息的抽象。我们还为普通POJO
      
    
    </summary>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
    
      <category term="AMQP" scheme="http://liuxing.info/tags/AMQP/"/>
    
      <category term="rabbitmq" scheme="http://liuxing.info/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>JAVA8实用范例</title>
    <link href="http://liuxing.info/2016/06/19/JAVA8%E5%AE%9E%E7%94%A8%E8%8C%83%E4%BE%8B"/>
    <id>http://liuxing.info/2016/06/19/JAVA8实用范例</id>
    <published>2016-06-19T07:03:00.000Z</published>
    <updated>2019-07-02T01:06:43.323Z</updated>
    
    <content type="html"><![CDATA[<p>源码地址：<a href="https://github.com/liuxing87327/Java8Example" target="_blank" rel="noopener">https://github.com/liuxing87327/Java8Example</a></p><hr><p><em>抛砖引玉！写出更简洁优美的代码</em></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>自java5以来最大的版本变动</li><li>很大程度增强java类库</li><li>主要目标<ul><li>更高的开发效率</li><li>更高代码可用性</li><li>更好的利用多核和多处理器系统</li></ul></li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul><li>函数式接口:只包含一个方法的接口</li><li>语法：<code>(参数) -&gt; 表达式</code> 或者 <code>(参数) -&gt; { 语句; }</code></li><li>方法引用<ul><li>跟Lambda表达式一样，语法： <code>对象引用::方法名</code></li></ul></li></ul><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"我是Lambda创建的线程"</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p><strong>示例2</strong><br>接口的匿名实现类全部可以使用Lambda表达式声明（单个方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Radio</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java8以前的实现</span></span><br><span class="line">Radio radio = <span class="keyword">new</span> Radio() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"播放广播"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java8的实现</span></span><br><span class="line">Radio radio2 = () -&gt; System.out.println(<span class="string">"播放广播"</span>);</span><br></pre></td></tr></table></figure><p>在Stream API中会有大量使用</p><hr><h2 id="List、Map的新的迭代API"><a href="#List、Map的新的迭代API" class="headerlink" title="List、Map的新的迭代API"></a>List、Map的新的迭代API</h2><p>List</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟数据</span></span><br><span class="line">List&lt;Person&gt; persons = Lists.newArrayList(<span class="keyword">new</span> Person(<span class="string">"张三"</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以前的方式</span></span><br><span class="line"><span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">    System.out.println(person.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的方式</span></span><br><span class="line">persons.forEach(person -&gt; System.out.println(person.getName()));</span><br></pre></td></tr></table></figure><p>Map</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟数据</span></span><br><span class="line">Map&lt;String, Person&gt; persons = ImmutableMap.of(<span class="string">"张三"</span>, <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>), <span class="string">"李四"</span>, <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以前的方式</span></span><br><span class="line"><span class="keyword">for</span> (String key : persons.keySet()) &#123;</span><br><span class="line">    System.out.println(key + <span class="string">":"</span> + persons.get(key).getAge());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的方式</span></span><br><span class="line">persons.forEach((key, person) -&gt; System.out.println(key + <span class="string">":"</span> + person.getAge()));</span><br></pre></td></tr></table></figure><p>Set</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟数据</span></span><br><span class="line">Set&lt;Person&gt; persons = ImmutableSet.of(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以前的方式</span></span><br><span class="line"><span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">    System.out.println(person.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的方式</span></span><br><span class="line">persons.forEach(person -&gt; System.out.println(person.getName()));</span><br></pre></td></tr></table></figure><p>点开源码看下，以List为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层还是原先的迭代方式，但是语义上更好理解了。</p><p>感兴趣的可以打开源码，看看java.util.function包下面的这些函数接口，在很多地方都有使用。</p><hr><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>流（Stream）仅仅代表着数据流，并没有数据结构，所以他遍历完一次之后便再也无法遍历（这点在编程时候需要注意，不像Collection，遍历多少次里面都还有数据），它的来源可以是Collection、array、io等等。</p><h3 id="中间与终点方法"><a href="#中间与终点方法" class="headerlink" title="中间与终点方法"></a>中间与终点方法</h3><p>流作用是提供了一种操作大数据接口，让数据操作更容易和更快。它具有过滤、映射以及减少遍历数等方法，这些方法分两种：中间方法和终端方法，“流”抽象天生就该是持续的，中间方法永远返回的是Stream，因此如果我们要获取最终结果的话，必须使用终点操作才能收集流产生的最终结果。区分这两个方法是看他的返回值，如果是Stream则是中间方法，否则是终点方法。有点类似sql语句的语义，自行脑补，哈哈。</p><p>以下列举几个常用的方法，更多使用方法请自行查阅API文档</p><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>从集合总过滤数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Lists.newArrayList(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>), <span class="keyword">new</span> Person(<span class="string">"赵六"</span>, <span class="number">20</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>), <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出年龄大于18岁的数据，转换List</span></span><br><span class="line">List&lt;Person&gt; filteredPersons = persons.stream().filter(person -&gt; person.getAge() &gt; <span class="number">18</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(JSON.toJSONString(filteredPersons));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出年龄大于18岁的数据，转换Set</span></span><br><span class="line">Set&lt;Person&gt; filteredPersonSet = persons.stream().filter(person -&gt; person.getAge() &gt; <span class="number">18</span>).collect(Collectors.toSet());</span><br><span class="line">System.out.println(JSON.toJSONString(filteredPersonSet));</span><br></pre></td></tr></table></figure><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>用来转换对象，比如把集合里面的某些属性组合成一个集合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Lists.newArrayList(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>), <span class="keyword">new</span> Person(<span class="string">"赵六"</span>, <span class="number">20</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>), <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = persons.stream().map(Person::getName).collect(Collectors.toList());</span><br><span class="line">System.out.println(JSON.toJSONString(names));</span><br></pre></td></tr></table></figure><h4 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h4><p>count是一个流的终点方法，用来统计</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Lists.newArrayList(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>), <span class="keyword">new</span> Person(<span class="string">"赵六"</span>, <span class="number">20</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>), <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = persons.stream().map(Person::getName).count();</span><br></pre></td></tr></table></figure><h4 id="Collect"><a href="#Collect" class="headerlink" title="Collect"></a>Collect</h4><p>collect方法也是一个流的终点方法，可收集最终的结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Lists.newArrayList(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>), <span class="keyword">new</span> Person(<span class="string">"赵六"</span>, <span class="number">20</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>), <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出年龄大于18岁的数据，转换List</span></span><br><span class="line">List&lt;Person&gt; filteredPersons = persons.stream().filter(person -&gt; person.getAge() &gt; <span class="number">18</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(JSON.toJSONString(filteredPersons));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出年龄大于18岁的数据，转换Set</span></span><br><span class="line">Set&lt;Person&gt; filteredPersonSet = persons.stream().filter(person -&gt; person.getAge() &gt; <span class="number">18</span>).collect(Collectors.toSet());</span><br><span class="line">        System.out.println(JSON.toJSONString(filteredPersonSet));</span><br></pre></td></tr></table></figure><p>或者使用特定的实现类收集结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; filteredPersons = persons.stream().filter(person -&gt; person.getAge() &gt; <span class="number">18</span>).collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">System.out.println(JSON.toJSONString(filteredPersons));</span><br></pre></td></tr></table></figure><p>或者对结果分组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Lists.newArrayList(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>, <span class="string">"男"</span>), <span class="keyword">new</span> Person(<span class="string">"赵六"</span>, <span class="number">20</span>, <span class="string">"男"</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>, <span class="string">"男"</span>), <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">18</span>, <span class="string">"女"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照年龄分组</span></span><br><span class="line">Map&lt;Integer, List&lt;Person&gt;&gt; groupMap = persons.stream().collect(Collectors.groupingBy(Person::getAge));</span><br><span class="line">System.out.println(JSON.toJSONString(groupMap));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按年龄统计名字</span></span><br><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; groupName = persons.stream().collect(Collectors.groupingBy(Person::getAge, Collectors.mapping(Person::getName, Collectors.toList())));</span><br><span class="line">System.out.println(JSON.toJSONString(groupName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按性别求年龄总和</span></span><br><span class="line">Map&lt;String, Integer&gt; groupAgeCount = persons.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.reducing(<span class="number">0</span>, Person::getAge, Integer::sum)));</span><br><span class="line">System.out.println(JSON.toJSONString(groupAgeCount));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计各年龄的数量</span></span><br><span class="line">Map&lt;Integer, Integer&gt; groupCount = persons.stream().collect(Collectors.groupingBy(Person::getAge, Collectors.summingInt(p -&gt; <span class="number">1</span>)));</span><br><span class="line">System.out.println(JSON.toJSONString(groupCount));</span><br></pre></td></tr></table></figure><h4 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h4><p>find结合filter使用也是很常见的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Lists.newArrayList(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>), <span class="keyword">new</span> Person(<span class="string">"赵六"</span>, <span class="number">20</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>), <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找一个年龄大于18岁的</span></span><br><span class="line">Optional&lt;Person&gt; optional = persons.stream().filter(person -&gt; person.getAge() &gt; <span class="number">18</span>).findFirst();</span><br><span class="line"><span class="keyword">if</span> (optional.isPresent()) &#123;</span><br><span class="line">    System.out.println(JSON.toJSONString(optional.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，stream的操作都是管道特性，通过一个例子可以看出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Lists.newArrayList(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">20</span>, <span class="string">"男"</span>), <span class="keyword">new</span> Person(<span class="string">"赵六"</span>, <span class="number">20</span>, <span class="string">"男"</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">22</span>, <span class="string">"男"</span>), <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">18</span>, <span class="string">"女"</span>));</span><br><span class="line"></span><br><span class="line">persons.stream()</span><br><span class="line">        .filter(p -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"filter=&gt;"</span> + p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .map(p -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"map=&gt;"</span> + p.getName());</span><br><span class="line">            <span class="keyword">return</span> p.getName();</span><br><span class="line">        &#125;)</span><br><span class="line">        .forEach(p -&gt; System.out.println(<span class="string">"结果=&gt;"</span> + p));</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filter=&gt;example.model.Person@3a4afd8d</span><br><span class="line">map=&gt;张三</span><br><span class="line">结果=&gt;张三</span><br><span class="line">filter=&gt;example.model.Person@1996cd68</span><br><span class="line">map=&gt;赵六</span><br><span class="line">结果=&gt;赵六</span><br><span class="line">filter=&gt;example.model.Person@3339ad8e</span><br><span class="line">map=&gt;李四</span><br><span class="line">结果=&gt;李四</span><br><span class="line">filter=&gt;example.model.Person@555590</span><br><span class="line">map=&gt;王五</span><br><span class="line">结果=&gt;王五</span><br></pre></td></tr></table></figure><p>更多参考：<a href="http://colobu.com/2014/11/18/Java-8-Stream/" target="_blank" rel="noopener">http://colobu.com/2014/11/18/Java-8-Stream/</a></p><h3 id="顺序流与并行流"><a href="#顺序流与并行流" class="headerlink" title="顺序流与并行流"></a>顺序流与并行流</h3><p>每个Stream都有两种模式：顺序执行和并行执行。<br><strong>顺序流</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Lists.newArrayList(<span class="keyword">new</span> Person(<span class="string">"张三"</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>));</span><br><span class="line">persons.stream().forEach(System.out::print);</span><br></pre></td></tr></table></figure><p><strong>并行流</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Lists.newArrayList(<span class="keyword">new</span> Person(<span class="string">"张三"</span>), <span class="keyword">new</span> Person(<span class="string">"李四"</span>));</span><br><span class="line">persons.parallelStream().forEach(System.out::print);</span><br></pre></td></tr></table></figure><p>并行流的原理是将数据拆分成多个段，然后并行执行，然后将结果合并到一起返回。</p><p>以前我们需要自己实现并行，现在使用java8就是so easy了！</p><p><strong>注意点：</strong><br>小数据量时候没必要使用并行流，比如几条数据。<br>建议在数据库批量操作、HTTP批量请求API时候使用并行操作。</p><p><strong>案例：</strong><br>并行修改300w数据，把数据库拖到高负载了- -!<br>调用百度地图API，给一些带地址的数据查询坐标，节省70%的时间</p><p>更多场景请结合业务组合使用</p><p><strong>API操作流程如下</strong></p><p><img src="https://github.com/liuxing87327/Java8Example/raw/master/images/java8-stream.png" alt="Java8 Stream API 流程"></p><hr><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>Java一直缺少BASE64编码 API，以至于通常在项目开发中会选用第三方的API实现。但是，Java 8实现了BASE64编解码API，它包含到java.util包。</p><p>java.util.Base64工具类提供了一套静态方法获取下面三种BASE64编解码器</p><ul><li>Basic编码</li><li>URL编码</li><li>MIME编码</li></ul><p>Basic编码是标准的BASE64编码，用于处理常规的需求：输出的内容不添加换行符，而且输出的内容由字母加数字组成。</p><p>基本用法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编码</span></span><br><span class="line">Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="keyword">new</span> String(Base64.getDecoder().decode(text), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p>编码URL<br>默认的编码可能会出现“/”，这个在URL里面会有特殊语义，所以使用URL编码器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Base64.getUrlEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure><p>网上搞到的性能测试</p><p><img src="http://static.oschina.net/uploads/space/2014/0522/142224_Ho8k_1028150.png" alt="Base64性能测试"></p><p>参考：<a href="http://my.oschina.net/benhaile/blog/267738" target="_blank" rel="noopener">http://my.oschina.net/benhaile/blog/267738</a></p><hr><h2 id="JVM消除永久代"><a href="#JVM消除永久代" class="headerlink" title="JVM消除永久代"></a>JVM消除永久代</h2><p>Java8彻底删除了永久代，取而代之的是“元空间”</p><ul><li>它是本地堆内存中的一部分</li><li>它可以通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize来进行调整</li><li>当到达XX:MetaspaceSize所指定的阈值后会开始进行清理该区域</li><li>如果本地空间的内存用尽了会收到java.lang.OutOfMemoryError: Metadata space的错误信息。</li><li>和持久代相关的JVM参数-XX:PermSize及-XX:MaxPermSize将会被忽略掉。</li></ul><p>G1垃圾回收器优化</p><p><a href="http://ifeve.com/java-garbage-first/" target="_blank" rel="noopener">http://ifeve.com/java-garbage-first/</a></p><hr><h2 id="时间API改进"><a href="#时间API改进" class="headerlink" title="时间API改进"></a>时间API改进</h2><p>鉴于大家对joda-time使用的比较熟悉了，新的时间API自行查阅</p><p><a href="http://ifeve.com/20-examples-of-date-and-time-api-from-java8/" target="_blank" rel="noopener">http://ifeve.com/20-examples-of-date-and-time-api-from-java8/</a></p><h2 id="并发的增强"><a href="#并发的增强" class="headerlink" title="并发的增强"></a>并发的增强</h2><p><a href="http://ifeve.com/java-se-8-concurrent-tool-enhance/" target="_blank" rel="noopener">http://ifeve.com/java-se-8-concurrent-tool-enhance/</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Java8特性<br><a href="http://ifeve.com/java-8-features-tutorial/" target="_blank" rel="noopener">http://ifeve.com/java-8-features-tutorial/</a></p><p>Java 8学习资料汇总<br><a href="http://ifeve.com/java8-learning-resources/" target="_blank" rel="noopener">http://ifeve.com/java8-learning-resources/</a></p><p>Java8接口变化<br><a href="http://www.journaldev.com/2752/java-8-interface-changes-static-methods-default-methods-functional-interfaces" target="_blank" rel="noopener">http://www.journaldev.com/2752/java-8-interface-changes-static-methods-default-methods-functional-interfaces</a></p><p>Java 8 Lambda表达式和功能接口示例教程<br><a href="http://www.journaldev.com/2763/java-8-lambda-expressions-and-functional-interfaces-example-tutorial" target="_blank" rel="noopener">http://www.journaldev.com/2763/java-8-lambda-expressions-and-functional-interfaces-example-tutorial</a></p><p>Java Stream API示例教程<br><a href="http://www.journaldev.com/2774/java-8-stream-api-example-tutorial" target="_blank" rel="noopener">http://www.journaldev.com/2774/java-8-stream-api-example-tutorial</a></p><p><a href="http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/" target="_blank" rel="noopener">http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/</a></p><p>Stream语法详解<br><a href="http://ifeve.com/stream/" target="_blank" rel="noopener">http://ifeve.com/stream/</a></p><p>reduction<br><a href="http://docs.oracle.com/javase/tutorial/collections/streams/reduction.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/tutorial/collections/streams/reduction.html</a></p><h2 id="电子书分享"><a href="#电子书分享" class="headerlink" title="电子书分享"></a>电子书分享</h2><p>链接: <a href="http://pan.baidu.com/s/1qYowjTi" target="_blank" rel="noopener">http://pan.baidu.com/s/1qYowjTi</a> 密码: 41rb</p><div id="java8PDF"></div><script type="text/javascript" src="/js/pdfobject.js"></script><script type="text/javascript" async>    var options = {        height: "700px",        pdfOpenParams: { view: "FitV", page: "1" }    };    PDFObject.embed("/attachment/Java 8函数式编程.pdf", "#java8PDF", options);</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/liuxing87327/Java8Example&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/liuxing87327/Java8Example&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
    
      <category term="Java8" scheme="http://liuxing.info/tags/Java8/"/>
    
      <category term="Lambda" scheme="http://liuxing.info/tags/Lambda/"/>
    
      <category term="Stream" scheme="http://liuxing.info/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>使用SDKMAN管理开发环境</title>
    <link href="http://liuxing.info/2016/06/18/%E4%BD%BF%E7%94%A8SDKMAN%E7%AE%A1%E7%90%86%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"/>
    <id>http://liuxing.info/2016/06/18/使用SDKMAN管理开发环境</id>
    <published>2016-06-17T20:03:00.000Z</published>
    <updated>2019-07-02T01:06:43.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SDKMAN 是用来在类Unix 系统中管理多个版本的开发环境的工具。提供命令行接口来安装、切换、删除、列出候选版本。</p><footer><strong>github</strong><cite><a href="https://github.com/sdkman/sdkman-cli" target="_blank" rel="noopener">Sdkman/sdkman-Cli</a></cite></footer></blockquote><h2 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h2><h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><p>写这篇博文的原因是因为最近在使用GVM(SDKMAN的前身)管理版本的时候，一直提示我一个异常“gvm offline disable”，<br>在网上找了一通都没解决，后来才发现是GVM已经弃用了，连原先的服务域名<code>http://api.gvmtool.net</code>都无法访问了。<br>所以导致一直无法下载新的东西，只能使用已经安装好的SDK，无奈我本地的groovy版本太老了…</p><p>本文不介绍GVM和SDKMAN是啥玩意，请自行谷歌！！！</p><h3 id="卸载GVM"><a href="#卸载GVM" class="headerlink" title="卸载GVM"></a>卸载GVM</h3><p>需要编辑者三个文件</p><ul><li>.bashrc</li><li>.bash_profile</li><li>.profile</li></ul><p>然后删除下面类似的代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#THIS MUST BE AT THE END OF THE FILE FOR GVM TO WORK!!!</span></span><br><span class="line">[[ -s <span class="string">"/Users/liuxing/.gvm/bin/gvm-init.sh"</span> ]] &amp;&amp; <span class="built_in">source</span> <span class="string">"/Users/liuxing/.gvm/bin/gvm-init.sh"</span></span><br></pre></td></tr></table></figure><p>最后，删除[<del>/.gvm]或[</del>/.sdkman]文件夹</p><h2 id="安装SDKMAN"><a href="#安装SDKMAN" class="headerlink" title="安装SDKMAN"></a>安装SDKMAN</h2><p>打开终端运行</p><blockquote><p>curl -s “<a href="https://get.sdkman.io&quot;" target="_blank" rel="noopener">https://get.sdkman.io&quot;</a> | bash</p></blockquote><p>然而，你也有可能会出现，一直卡着不动了…</p><p>有两种方案<br>1.把https改为http，然后重试<br>2.从浏览器访问 <a href="https://get.sdkman.io" target="_blank" rel="noopener">https://get.sdkman.io</a> ，然后把打开的内容另存为脚本，然后执行它</p><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;SDKMAN 是用来在类Unix 系统中管理多个版本的开发环境的工具。提供命令行接口来安装、切换、删除、列出候选版本。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;github&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://github.
      
    
    </summary>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="sdkman" scheme="http://liuxing.info/tags/sdkman/"/>
    
      <category term="gvm" scheme="http://liuxing.info/tags/gvm/"/>
    
      <category term="开发环境" scheme="http://liuxing.info/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder的区别</title>
    <link href="http://liuxing.info/2016/03/15/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"/>
    <id>http://liuxing.info/2016/03/15/String、StringBuffer、StringBuilder的区别</id>
    <published>2016-03-14T19:14:00.000Z</published>
    <updated>2019-07-02T01:06:43.326Z</updated>
    
    <content type="html"><![CDATA[<p>使用java有很长一段时间了，一直都是用的一些框架。<br>还从未深入思考过一些java基础的东西<br>写代码时大家常说，字符串拼接不要用String，要用StringBuffer、StringBuilder，<br>今天写篇文字总结一下String、StringBuffer、StringBuilder的区别。<br>本文不深入探讨jvm的机制（本人这块比较渣），有建议欢迎指点讨论学习，十分感谢！</p><h2 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h2><ul><li>被final修饰的类是不能被继承的，没有子类</li><li>被final修饰的对象，其引用不能改变，但是对象中的属性值可以修改(String不行哦，编译都不通过)</li><li>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞</li><li>基本类型的变量和引用变量都是在函数的栈内存中分配，堆中存放对象和数组</li></ul><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组的被final修饰，所以数据引用变量的值不能变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = value.length;</span><br><span class="line">            <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (val[i] == oldChar) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    buf[j] = val[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                    <span class="keyword">char</span> c = val[i];</span><br><span class="line">                    buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// replaceAll采用正则匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceAll(replacement);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String的底层是使用字符数组来实现的，<br>value是一个被final修饰的数组对象，所以只能说他不能再引用到其他对象而不能说明他所引用的对象的内容不能改变。<br>但继续看源码就会发现String类没有给这两个成员变量提供任何的方法所以我们也没办法修改所引用对象的内容，<br>所以String对象一旦被创建，这个变量被初始化后就不能再修改了，所以说String对象是不可变对象。</p><p>String的replace方法也并没有修改本身，而是重复创建了新的对象。</p><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>Java中字符串对象创建有两种形式，一种为字面量形式</p><blockquote><p>String str = “lianjia”;</p></blockquote><p>另一种就是使用new这种标准的构造对象的方法，</p><blockquote><p>String str = new String(“lianjia”);</p></blockquote><p>这两种方式我们在代码时都经常使用，尤其是字面量的方式。<br>然而这两种实现其实存在着一些性能和内存占用的差别。<br>这一切都是源于JVM为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被成为字符串常量池或者字符串字面量池。</p><p><strong>工作原理</strong></p><p>当代码中出现字面量形式创建字符串对象时，JVM首先会对这个字面量进行检查，<br>如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，<br>否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。</p><p>字面量形式</p><blockquote><p>String str1 = “lianjia”;</p></blockquote><p>JVM检测这个字面量，这里我们认为没有内容为lianjia的对象存在。<br>JVM通过字符串常量池查找不到内容为lianjia的字符串对象存在，那么会创建这个字符串对象，<br>然后将刚创建的对象的引用放入到字符串常量池中,并且将引用返回给变量str1。</p><blockquote><p>String str2 = “lianjia”;</p></blockquote><p>同样JVM还是要检测这个字面量，JVM通过查找字符串常量池，<br>发现内容为”lianjia”字符串对象存在，于是将已经存在的字符串对象的引用返回给变量str2。<br>注意这里不会重新创建新的字符串对象。</p><p>验证是否为str1和str2是否指向同一对象，可以通过这段代码</p><blockquote><p>System.out.println(str1 == str2); // true</p></blockquote><p>使用new创建</p><blockquote><p>String str3 = new String(“lianjia”);</p></blockquote><p>当我们使用了new来构造字符串对象的时候，不管字符串常量池中有没有相同内容的对象的引用，新的字符串对象都会创建。</p><blockquote><p>System.out.println(str1 == str3); // false，两个变量指向的为不同的对象</p></blockquote><p>关于常量池的更多信息，请谷歌”Java class 文件结构 常量池“等关键字。</p><p><img src="/images/uml/Snip20160315_2.png" alt="内存分配"></p><h3 id="StringBuffer、StringBuilder"><a href="#StringBuffer、StringBuilder" class="headerlink" title="StringBuffer、StringBuilder"></a>StringBuffer、StringBuilder</h3><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p><img src="/images/uml/AbstractStringBuilder.png" alt="String、StringBuffer、StringBuilder类图对比"></p><p><code>查看类图方法：选中包或类 - 右键 - Diagrams</code> 神马，你是eclipse，滚粗…</p><p>可以通过“Show Categories - Methods”查看具体的方法，因图片太大，就不展示了 <a href="/images/uml/AbstractStringBuilder-Methods.png">点我下载</a> </p><p>从类结构可以看出，StringBuffer和StringBuilder是典型的模板模式。<br>所有的通用方法都在AbstractStringBuilder的模板类中，子类只是进行了差异化处理。</p><p>代码片段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有被final修饰，所以引用变量的值可以改变</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符的个数</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">       <span class="comment">// 构造函数，创建数组对象，实现类默认是16个长度</span></span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 拼接字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="comment">// 获取拼接内容长度</span></span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="comment">// 扩展存储数组长度</span></span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        <span class="comment">// 把拼接数据拷贝到源数组</span></span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        <span class="comment">// 更新数组长度</span></span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保数组长度够用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">            expandCapacity(minimumCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩展存储数组长度</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = value.length * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minimumCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">            newCapacity = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过扩展数组长度的方法可以看出，当数组长度不够时，每次都是扩展了两倍的长度，<br>所以一般建议预估一下结果最终的长度，避免做不必要的事。</p><p>StringBuffer、StringBuilder的功能大同小异，区别是StringBuffer的方法都加了同步关键字，以保证线程安全</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.dooioo.commons.Randoms;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试String、StringBuffer、StringBuilder的线程安全</span></span><br><span class="line"><span class="comment"> * 500组不重复字符串，100个线程进行拼接操作，看最终结果长度是否是500*32*100</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：liuxing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> ：2016-03-15 01:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> threadCount = <span class="number">100</span>;</span><br><span class="line">    ExecutorService executor;</span><br><span class="line">    List&lt;String&gt; testData = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据准备</span></span><br><span class="line"><span class="comment">     * 500个不重复的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 生成32位的随机数，防止使用字符串池</span></span><br><span class="line">            testData.add(Randoms.getPrimaryKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试String</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 编译不会通过</span></span><br><span class="line"><span class="comment">//        final String str = "";</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        List&lt;Future&gt; futures = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; threadCount; i++) &#123;</span></span><br><span class="line"><span class="comment">//            futures.add(executor.submit(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//                for (String s : testData) &#123;</span></span><br><span class="line"><span class="comment">//                    str += s;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                return true;</span></span><br><span class="line"><span class="comment">//            &#125;));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        for (Future future : futures) &#123;</span></span><br><span class="line"><span class="comment">//            future.get();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        Assert.assertEquals("String线程不安全", 500*32*100, str.length());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试StringBuffer</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AbstractStringBuilder#append(String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringBuffer</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            futures.add(executor.submit(() -&gt; &#123;</span><br><span class="line">                testData.forEach(s -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        buffer.append(s);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Future future : futures) &#123;</span><br><span class="line">            future.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(<span class="string">"StringBuffer线程不安全"</span>, <span class="number">500</span> * <span class="number">32</span> * <span class="number">100</span>, buffer.toString().length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试StringBuilder</span></span><br><span class="line"><span class="comment">     * 会出现下标越界和字符拼接丢失</span></span><br><span class="line"><span class="comment">     * 查看StringBuilder的源码，它内部自动扩展字符数组时是先确定新数组长度，再拷贝旧数据。</span></span><br><span class="line"><span class="comment">     * 极端情况：当a线程中一次append正在进行时，确定了新长度后，线程切换，另一个线程b写入了较短的字符串，</span></span><br><span class="line"><span class="comment">     * 但还没更新内部count计数，于是就在数组后面留下空白；然后a切回来，拷贝原有的数据（实即b写入的短字符串加上末尾空格），</span></span><br><span class="line"><span class="comment">     * 然后a将新数据append到数组中，实际上就排在了空白后面。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AbstractStringBuilder#append(String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringBuilder</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            futures.add(executor.submit(() -&gt; &#123;</span><br><span class="line">                testData.forEach(s -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        builder.append(s);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Future future : futures) &#123;</span><br><span class="line">            future.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(<span class="string">"StringBuilder线程不安全"</span>, <span class="number">500</span> * <span class="number">32</span> * <span class="number">100</span>, builder.toString().length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试同步的StringBuilder</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AbstractStringBuilder#append(String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSyncStringBuilder</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            futures.add(executor.submit(() -&gt; &#123;</span><br><span class="line">                testData.forEach(s -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (builder) &#123;</span><br><span class="line">                            builder.append(s);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Future future : futures) &#123;</span><br><span class="line">            future.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(<span class="string">"StringBuilder线程不安全，即使加了synchronized"</span>, <span class="number">500</span> * <span class="number">32</span> * <span class="number">100</span>, builder.toString().length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单比较String、StringBuffer、StringBuilder在赋值后是否对象引用会改变</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"000"</span>;</span><br><span class="line">        System.out.println(str.hashCode());</span><br><span class="line">        str += <span class="string">"123"</span>;</span><br><span class="line">        System.out.println(str.hashCode());</span><br><span class="line"></span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">"000"</span>);</span><br><span class="line">        System.out.println(buffer.hashCode());</span><br><span class="line">        buffer.append(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(buffer.hashCode());</span><br><span class="line"></span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"000"</span>);</span><br><span class="line">        System.out.println(builder.hashCode());</span><br><span class="line">        builder.append(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(builder.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>StringBuffer是线程安全的</p><p>StringBuilder多线程会抛出异常，字符串长度不准确，线程不安全</p><p>对StringBuilder对象加上synchronized能制造线程安全</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ArrayIndexOutOfBoundsException</span><br><span class="line">at java.lang.String.getChars(String.java:<span class="number">814</span>)</span><br><span class="line">at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="number">422</span>)</span><br><span class="line">at java.lang.StringBuilder.append(StringBuilder.java:<span class="number">136</span>)</span><br><span class="line">at com.dooioo.lang.AbstractStringBuilderTest.lambda$<span class="keyword">null</span>$<span class="number">2</span>(AbstractStringBuilderTest.java:<span class="number">124</span>)</span><br><span class="line">at com.dooioo.lang.AbstractStringBuilderTest$$Lambda$<span class="number">3</span>/<span class="number">138527898</span>.accept(Unknown Source)</span><br><span class="line">at java.util.ArrayList.forEach(ArrayList.java:<span class="number">1249</span>)</span><br><span class="line">at com.dooioo.lang.AbstractStringBuilderTest.lambda$testStringBuilder$<span class="number">3</span>(AbstractStringBuilderTest.java:<span class="number">122</span>)</span><br><span class="line">at com.dooioo.lang.AbstractStringBuilderTest$$Lambda$<span class="number">1</span>/<span class="number">411631404</span>.call(Unknown Source)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1142</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">617</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br><span class="line">java.lang.AssertionError: StringBuilder线程不安全 </span><br><span class="line">Expected :<span class="number">1600000</span></span><br><span class="line">Actual   :<span class="number">1450240</span></span><br><span class="line"> &lt;Click to see difference&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">at org.junit.Assert.fail(Assert.java:<span class="number">88</span>)</span><br><span class="line">at org.junit.Assert.failNotEquals(Assert.java:<span class="number">834</span>)</span><br><span class="line">at org.junit.Assert.assertEquals(Assert.java:<span class="number">645</span>)</span><br><span class="line">at com.dooioo.lang.AbstractStringBuilderTest.testStringBuilder(AbstractStringBuilderTest.java:<span class="number">139</span>)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</span><br><span class="line">at org.junit.runners.model.FrameworkMethod$<span class="number">1</span>.runReflectiveCall(FrameworkMethod.java:<span class="number">50</span>)</span><br><span class="line">at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:<span class="number">12</span>)</span><br><span class="line">at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:<span class="number">47</span>)</span><br><span class="line">at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:<span class="number">17</span>)</span><br><span class="line">at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:<span class="number">26</span>)</span><br><span class="line">at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:<span class="number">325</span>)</span><br><span class="line">at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:<span class="number">78</span>)</span><br><span class="line">at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:<span class="number">57</span>)</span><br><span class="line">at org.junit.runners.ParentRunner$<span class="number">3</span>.run(ParentRunner.java:<span class="number">290</span>)</span><br><span class="line">at org.junit.runners.ParentRunner$<span class="number">1</span>.schedule(ParentRunner.java:<span class="number">71</span>)</span><br><span class="line">at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:<span class="number">288</span>)</span><br><span class="line">at org.junit.runners.ParentRunner.access$<span class="number">000</span>(ParentRunner.java:<span class="number">58</span>)</span><br><span class="line">at org.junit.runners.ParentRunner$<span class="number">2</span>.evaluate(ParentRunner.java:<span class="number">268</span>)</span><br><span class="line">at org.junit.runners.ParentRunner.run(ParentRunner.java:<span class="number">363</span>)</span><br><span class="line">at org.junit.runner.JUnitCore.run(JUnitCore.java:<span class="number">137</span>)</span><br><span class="line">at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:<span class="number">119</span>)</span><br><span class="line">at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:<span class="number">42</span>)</span><br><span class="line">at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:<span class="number">234</span>)</span><br><span class="line">at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:<span class="number">74</span>)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</span><br><span class="line">at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">144</span>)</span><br></pre></td></tr></table></figure><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>结合上面的分析，可以看出String使用”+“拼接字符，每次都会开辟新的内存空间，然后修改变量的指向，同时也会频繁触发GC。<br>那么我们来测试一下具体性能差异有多少。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * StringContactTest</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：liuxing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> ：2016-03-15 06:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringContactTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testContact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        String s  = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">            s += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"String耗时: "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBufferContact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">            buffer.append(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要注意，StringBuffer的toString和StringBuilder的toString有点不一样哦</span></span><br><span class="line">        buffer.toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"StringBuffer耗时: "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBuilderContact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">            builder.append(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        builder.toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"StringBuilder耗时: "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分5、50、500、5000、50000次拼接测试</p><p>5</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">StringBuilder耗时: 53216</span><br><span class="line">String耗时: 10565</span><br><span class="line">StringBuffer耗时: 37100</span><br></pre></td></tr></table></figure><p>50</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">StringBuilder耗时: 77982</span><br><span class="line">String耗时: 65830</span><br><span class="line">StringBuffer耗时: 80627</span><br></pre></td></tr></table></figure><p>500</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">StringBuilder耗时: 1672791</span><br><span class="line">String耗时: 5102420</span><br><span class="line">StringBuffer耗时: 1405787</span><br></pre></td></tr></table></figure><p>5000</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">StringBuilder耗时: 17866567</span><br><span class="line">String耗时: 166399935</span><br><span class="line">StringBuffer耗时: 9257570</span><br></pre></td></tr></table></figure><p>50000</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">StringBuilder耗时: 33779794</span><br><span class="line">String耗时: 8160426817</span><br><span class="line">StringBuffer耗时: 3683921</span><br></pre></td></tr></table></figure><p>小数据量用哪种都无所谓，String甚至更快，数据量大的时候就不要用String了，本来还要测试500000+，但是太慢了，就没测试了</p><h2 id="延伸知识"><a href="#延伸知识" class="headerlink" title="延伸知识"></a>延伸知识</h2><p>分析上面东东时，使用的一些还未深入测试的知识点</p><h3 id="查看java字节码"><a href="#查看java字节码" class="headerlink" title="查看java字节码"></a>查看java字节码</h3><p>1.javac –verbose查看运行类加载的jar</p><pre><code>javac –verbose Test.java</code></pre><p>2.javap查看字节码</p><pre><code>javap –c Testjavap –verbose Test</code></pre><p>查看字节码对比String的字面量形式和new创建的差异，待定！</p><h3 id="查看jvm的图形工具"><a href="#查看jvm的图形工具" class="headerlink" title="查看jvm的图形工具"></a>查看jvm的图形工具</h3><p>常用的jvm图形分析工具，待定！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用java有很长一段时间了，一直都是用的一些框架。&lt;br&gt;还从未深入思考过一些java基础的东西&lt;br&gt;写代码时大家常说，字符串拼接不要用String，要用StringBuffer、StringBuilder，&lt;br&gt;今天写篇文字总结一下String、StringBuff
      
    
    </summary>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
    
      <category term="String" scheme="http://liuxing.info/tags/String/"/>
    
      <category term="StringBuffer" scheme="http://liuxing.info/tags/StringBuffer/"/>
    
      <category term="StringBuilder" scheme="http://liuxing.info/tags/StringBuilder/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ使用（一）安装篇</title>
    <link href="http://liuxing.info/2016/01/31/RabbitMQ%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85%E7%AF%87"/>
    <id>http://liuxing.info/2016/01/31/RabbitMQ使用（一）安装篇</id>
    <published>2016-01-31T05:22:00.000Z</published>
    <updated>2019-07-02T01:06:43.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装erlang语言环境"><a href="#安装erlang语言环境" class="headerlink" title="安装erlang语言环境"></a>安装erlang语言环境</h2><p>安装依赖文件</p><blockquote><p>yum install ncurses-devel<br>  yum -y install openssl*<br>  yum -y install ssl*<br>  yum -y install xmlto<br>  yum -y install python-simplejson<br>  yum -y install python</p></blockquote><p>进入 <a href="http://www.erlang.org/download.html" target="_blank" rel="noopener">http://www.erlang.org/download.html</a> 选择源文件下载</p><blockquote><p>wget <a href="http://www.erlang.org/download/otp_src_17.5.tar.gz" target="_blank" rel="noopener">http://www.erlang.org/download/otp_src_17.5.tar.gz</a><br>tar zxvf otp_src_17.5.tar.gz<br>cd otp_src_17.5</p></blockquote><p>阅读HOTO/INSTALL.md文件 </p><blockquote><p>./configure<br>  make &amp;&amp; make install </p></blockquote><p>安装完成以后，执行erl看是否能打开eshell，用’halt().’退出，注意后面的点号，那是erlang的结束符。</p><blockquote><p>[root@iZ113aowxo2Z ~]# erl<br>  Erlang/OTP 17 [erts-6.4] [source] [64-bit] [async-threads:10]      [hipe] [kernel-poll:false]<br>  Eshell V6.4  (abort with ^G)<br>  1&gt; 9+1.<br>  10<br>  2&gt; halt().</p></blockquote><h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><p>安装依赖</p><blockquote><p>yum install xmlto</p></blockquote><p>创建主文件夹</p><blockquote><p>mkdir rabbitmq<br>  cd rabbitmq</p></blockquote><p>直接使用RPM</p><blockquote><p>wget <a href="http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm" target="_blank" rel="noopener">http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm</a><br>  rpm -ivh rabbitmq-server-3.6.0-1.noarch.rpm</p></blockquote><p>编译安装包<br>进入<a href="http://www.rabbitmq.com/download.html选择最新的源码包" target="_blank" rel="noopener">http://www.rabbitmq.com/download.html选择最新的源码包</a></p><blockquote><p> wget <a href="http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0.tar.xz" target="_blank" rel="noopener">http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0.tar.xz</a><br>  xz -d rabbitmq-server-3.6.0.tar.xz<br>  tar xvf rabbitmq-server-3.6.0.tar<br>  cd rabbitmq-server-3.6.0<br>  make<br>  make install TARGET_DIR=/opt/rabbitmq SBIN_DIR=/opt/rabbitmq/sbin MAN_DIR=/opt/rabbitmq/man DOC_INSTALL_DIR=/opt/rabbitmq/doc</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>启动MQ</p><blockquote><p>rabbitmq-server -detached</p></blockquote><p>查看状态</p><blockquote><p>rabbitmqctl status</p></blockquote><p>启用管理插件</p><blockquote><p>mkdir /etc/rabbitmq/<br>  rabbitmq-plugins enable rabbitmq_management </p></blockquote><p>停止服务</p><blockquote><p>rabbitmqctl stop</p></blockquote><p>添加账号<br>PS：默认账号guest只能在localhost访问</p><blockquote><p>rabbitmqctl add_user admin admin</p></blockquote><p>设置管理员</p><blockquote><p>rabbitmqctl set_user_tags admin administrator</p></blockquote><p>设置读写权限<br>命令使用户admin具有/vhost1这个virtual host中所有资源的配置、写、读权限以便管理其中的资源</p><blockquote><p>rabbitmqctl set_permissions -p /vhost1 admin ‘.<em>‘ ‘.</em>‘ ‘.*’</p></blockquote><p>查看账号</p><blockquote><p>rabbitmqctl list_users</p></blockquote><p>加入账号到配置</p><blockquote><p>vi /etc/rabbitmq/rabbitmq.config<br>[<br>    {rabbit, [{loopback_users, [“admin”]}]}<br>  ].</p></blockquote><p>重启后 <a href="http://ip:15672" target="_blank" rel="noopener">http://ip:15672</a> 登录管理界面了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装erlang语言环境&quot;&gt;&lt;a href=&quot;#安装erlang语言环境&quot; class=&quot;headerlink&quot; title=&quot;安装erlang语言环境&quot;&gt;&lt;/a&gt;安装erlang语言环境&lt;/h2&gt;&lt;p&gt;安装依赖文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;yum
      
    
    </summary>
    
      <category term="MQ" scheme="http://liuxing.info/categories/MQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://liuxing.info/tags/RabbitMQ/"/>
    
      <category term="MQ" scheme="http://liuxing.info/tags/MQ/"/>
    
      <category term="消息队列" scheme="http://liuxing.info/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat-Jdbc-Pool参数说明</title>
    <link href="http://liuxing.info/2016/01/05/Tomcat-Jdbc-Pool%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"/>
    <id>http://liuxing.info/2016/01/05/Tomcat-Jdbc-Pool参数说明</id>
    <published>2016-01-05T03:36:00.000Z</published>
    <updated>2019-07-02T01:06:43.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Tomcat 在 7.0 以前的版本都是使用commons-dbcp做为连接池的实现，但是DBCP存在一些问题： </p><ul><li>DBCP 是单线程的，为了保证线程安全会锁整个连接池 </li><li>DBCP 性能不佳</li><li>DBCP 太复杂，超过60个类，发展滞后。 </li></ul><p>因此，通常J2EE中还会使用其它的高性能连接池，如C3P0，还有阿里系的druid等。<br>为此，Tomcat 从 7.0 开始引入一个新的模块： Tomcat Jdbc Pool<br>Tomcat Jdbc Pool 近乎兼容 DBCP，性能更高 </p><ul><li>异步方式获取连接 </li><li>Tomcat Jdbc Pool是Tomcat的一个模块，基于Tomcat-Juli，使用Tomcat的日志框架 </li><li>使用 javax.sql.PooledConnection 接口获取连接 </li><li>支持高并发应用环境 </li><li>超简单，核心文件只有8个，比 c3p0 还少 </li><li>更好的空闲连接处理机制 </li><li>支持 JMX </li><li>支持 XA Connection。 </li><li>Tomcat Jdbc Pool 可在 Tomcat 中直接使用，也可以在独立的应用中使用。 </li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>通用属性</p><table><thead><tr><th align="left">属性名</th><th align="left">描述(DBCP/Tomcat jdbc-pool 差别 )</th><th align="left">DBCP默认值</th><th align="left">jdbc-pool默认值</th></tr></thead><tbody><tr><td align="left">username</td><td align="left">用户名</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">password</td><td align="left">密码</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">url</td><td align="left">建立连接的URL</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">driverClassName</td><td align="left">驱动的完整有效的java类名</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">connectionProperties</td><td align="left">(String) 当建立新连接时被发送给JDBC 驱动的连接参数，格式必须是 [propertyName=property;]<br>*注意 ：参数user/password 将被明确传递，所以不需要包括在这里。</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">defaultAutoCommit</td><td align="left">(boolean) 连接池创建的连接的默认的auto-commit 状态</td><td align="left">true</td><td align="left">driver default</td></tr><tr><td align="left">defaultReadOnly</td><td align="left">(boolean) 连接池创建的连接的默认的read-only 状态。 如果没有设置则setReadOnly 方法将不会被调用。 ( 某些驱动不支持只读模式， 比如：Informix)</td><td align="left">driver default</td><td align="left">driver default</td></tr><tr><td align="left">defaultTransactionIsolation</td><td align="left">(String) 连接池创建的连接的默认的TransactionIsolation 状态。 下面列表当中的某一个： ( 参考javadoc) <br>NONE <br>READ_COMMITTED <br>READ_UNCOMMITTED <br>REPEATABLE_READ <br>SERIALIZABLE</td><td align="left">driver default</td><td align="left">driver default</td></tr><tr><td align="left">defaultCatalog</td><td align="left">(String) 连接池创建的连接的默认的catalog</td><td align="left">-</td><td align="left">driver default</td></tr><tr><td align="left">initialSize</td><td align="left">(int) 初始化连接： 连接池启动时创建的初始化连接数量，1。2 版本后支持</td><td align="left">0</td><td align="left">10</td></tr><tr><td align="left">maxActive</td><td align="left">(int) 最大活动连接： 连接池在同一时间能够分配的最大活动连接的数量， 如果设置为非正数则表示不限制</td><td align="left">8</td><td align="left">100</td></tr><tr><td align="left">maxIdle</td><td align="left">(int) 最大空闲连接： 连接池中容许保持空闲状态的最大连接数量， 超过的空闲连接将被释放， 如果设置为负数表示不限制 <br><code>如果启用，将定期检查限制连接，如果空闲时间超过minEvictableIdleTimeMillis 则释放连接 （ 参考testWhileIdle ）</code></td><td align="left">8</td><td align="left">与maxActive相同</td></tr><tr><td align="left">minIdle</td><td align="left">(int) 最小空闲连接： 连接池中容许保持空闲状态的最小连接数量， 低于这个数量将创建新的连接， 如果设置为0 则不创建 <br><code>如果连接验证失败将缩小这个值（ 参考testWhileIdle ）</code></td><td align="left">0</td><td align="left">与initialSize 相同</td></tr><tr><td align="left">maxWait</td><td align="left">(int) 最大等待时间： 当没有可用连接时， 连接池等待连接被归还的最大时间( 以毫秒计数)， 超过时间则抛出异常， 如果设置为-1 表示无限等待</td><td align="left">无限</td><td align="left">30000（30秒）</td></tr><tr><td align="left">validationQuery</td><td align="left">(String) SQL 查询， 用来验证从连接池取出的连接， 在将连接返回给调用者之前。 如果指定， 则查询必须是一个SQL SELECT 并且必须返回至少一行记录 <br> <code>查询不必返回记录，但这样将不能抛出SQL异常</code></td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">testOnBorrow</td><td align="left">(boolean) 指明是否在从池中取出连接前进行检验， 如果检验失败， 则从池中去除连接并尝试取出另一个。注意： 设置为true 后如果要生效，validationQuery 参数必须设置为非空字符串 <br> <code>参考validationInterval以获得更有效的验证</code></td><td align="left">true</td><td align="left">false</td></tr><tr><td align="left">testOnReturn</td><td align="left">(boolean) 指明是否在归还到池中前进行检验 注意： 设置为true 后如果要生效，validationQuery 参数必须设置为非空字符串</td><td align="left">false</td><td align="left">false</td></tr><tr><td align="left">testWhileIdle</td><td align="left">(boolean) 指明连接是否被空闲连接回收器( 如果有) 进行检验。 如果检测失败， 则连接将被从池中去除。注意： 设置为true 后如果要生效，validationQuery 参数必须设置为非空字符串</td><td align="left">false</td><td align="left">false</td></tr><tr><td align="left">timeBetweenEvictionRunsMillis</td><td align="left">(int) 在空闲连接回收器线程运行期间休眠的时间值， 以毫秒为单位。 如果设置为非正数， 则不运行空闲连接回收器线程 <br> <code>这个值不应该小于1秒，它决定线程多久验证连接或丢弃连接</code></td><td align="left">-1</td><td align="left">5000（5秒）</td></tr><tr><td align="left">numTestsPerEvictionRun</td><td align="left">(int) 在每次空闲连接回收器线程( 如果有) 运行时检查的连接数量</td><td align="left">false</td><td align="left">未使用</td></tr><tr><td align="left">minEvictableIdleTimeMillis</td><td align="left">连接在池中保持空闲而不被空闲连接回收器线程( 如果有) 回收的最小时间值，单位毫秒</td><td align="left">1000 * 60 * 30（30分钟）</td><td align="left">60000（60秒）</td></tr><tr><td align="left">poolPreparedStatements</td><td align="left">(boolean) 开启池的prepared statement 池功能</td><td align="left">false</td><td align="left">未使用</td></tr><tr><td align="left">maxOpenPreparedStatements</td><td align="left">(int)statement 池能够同时分配的打开的statements 的最大数量， 如果设置为0 表示不限制</td><td align="left">不限制</td><td align="left">未使用</td></tr><tr><td align="left">accessToUnderlyingConnectionAllowed</td><td align="left">(boolean) 控制PoolGuard 是否容许获取底层连接 <br> <code>jdbc-pool中未使用此属性；可以通过调用连接的unwrap方法取得控制权。参考javax。sql。DataSource接口，通过反射调用getConnection方法，或强制转换为javax。sql。PooledConnection对象。</code></td><td align="left">false</td><td align="left">未使用</td></tr><tr><td align="left">removeAbandoned</td><td align="left">(boolean) 标记是否删除泄露的连接， 如果他们超过了removeAbandonedTimout 的限制。 如果设置为true， 连接被认为是被泄露并且可以被删除， 如果空闲时间超过removeAbandonedTimeout。 设置为true 可以为写法糟糕的没有关闭连接的程序修复数据库连接。<br> <code>参考logAbandoned</code></td><td align="left">false</td><td align="left">false</td></tr><tr><td align="left">removeAbandonedTimeout</td><td align="left">(int) 泄露的连接可以被删除的超时值， 单位秒 <br> 应设置为应用中查询执行最长的时间</td><td align="left">300</td><td align="left">60</td></tr><tr><td align="left">logAbandoned</td><td align="left">(boolean) 标记当Statement 或连接被泄露时是否打印程序的stack traces 日志。被泄露的Statements 和连接的日志添加在每个连接打开或者生成新的Statement， 因为需要生成stack trace 。</td><td align="left">false</td><td align="left">false</td></tr></tbody></table><hr><p>Tomcat jdbc-pool 新增属性</p><table><thead><tr><th align="left">属性名</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">validatorClassName</td><td align="left">(String)实现org.apache.tomcat.jdbc.pool.Validator接口的类名，必须存在默认或明确的无参构造方 法。将建立一个指定类的实例作为验证器，用来代替执行查询的连接验证。例如：com.mycompany.project.SimpleValidator。</td><td align="left">-</td></tr><tr><td align="left">initSQL</td><td align="left">(String) 当连接第一次建立时执行的SQL</td><td align="left">-</td></tr><tr><td align="left">jdbcInterceptors</td><td align="left">(String)（jdbc拦截器——jdbc-pool的高级扩展属 性）用分号分隔的、继承org.apache.tomcat.jdbc.pool.JdbcInterceptor的类名列表。这些拦截器将被插入到对 java.sql.Connection操作之前的拦截器链上。<br>预制的拦截器有：<br>org.apache.tomcat.jdbc.pool.interceptor.ConnectionState - 追踪自动提交、只读状态、catalog和事务隔离等级等状态。（keeps track of auto commit， read only， catalog and transaction isolation level.）org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer - 追踪打开的statement，当连接被归还时关闭它们。（keeps track of opened statements， and closes them when the connection is returned to the pool.）<br>更多预制拦截器详细描述请参见JDBC拦截器部分</td><td align="left">-</td></tr><tr><td align="left">validationInterval</td><td align="left">(long) 避免过度验证，保证验证不超过这个频率——以毫秒为单位。如果一个连接应该被验证，但上次验证未达到指定间隔，将不再次验证。</td><td align="left">30000（30秒）</td></tr><tr><td align="left">jmxEnabled</td><td align="left">(boolean) 是否将连接注册到JMX</td><td align="left">true</td></tr><tr><td align="left">fairQueue</td><td align="left">(boolean) 如果被设为true ，getConnection 方法将被以先进先出的方式对待。此属性使用 org.apache.tomcat.jdbc.pool.FairBlockingQueue 实现闲置连接列表。<br>如果需要使用异步连接回收，这个标记是必须的。<br>这个标记确保线程取得连接的顺序和他们调用getConnection 方法的顺序是相同的。<br>在性能测试中，这个标记对锁和锁等待有非常大的影响。当fairQueue=true ，将有一个依赖于操作系统的线程作为决定线程。如果是Linux 系统（ 系统属性os.name=Linux ）可以在线程池的类加载之前设置系统属性 org.apache.tomcat.jdbc.pool.FairBlockingQueue.ignoreOS=true 关闭Linux 特定行为但仍然使用公平队列</td><td align="left">true</td></tr><tr><td align="left">abandonWhenPercentageFull</td><td align="left">(int)正在被使用的连接超过这个百分比以前被丢弃的连接不会被断开或报告。这个值应被设为0-100之间。默认值为0，意味着达到 removeAbandonedTimeout 时将被尽快关闭。</td><td align="left">0</td></tr><tr><td align="left">maxAge</td><td align="left">(long)保持连接的最大毫秒数。当一个连接被归还时，连接池将检查是否满足：现在时间-连接时长&gt;maxAge，如果条件满足，连接将被关闭而不是回到池中。默认值为0，标识禁用该功能。</td><td align="left">0</td></tr><tr><td align="left">useEquals</td><td align="left">(boolean)如果希望ProxyConnection类使用String.equals方法对比方法名，设为true；否则将使用==判断。这个属性不会影响单独配置的拦截器。</td><td align="left">true</td></tr><tr><td align="left">suspectTimeout</td><td align="left">(int)以秒为单位的超时时间（怀疑超时）。类似 removeAbandonedTimeout，但不会将连接丢弃甚至关闭，如果logAbandoned为true，则 只是记录一个警告。如果这个值小于等于0，不会有怀疑超时检测被执行。怀疑检测只有当超时时间大于0并且连接未丢弃，或者丢弃检测被禁用的情况下才占用空间。如果一个连接被怀疑，将记录一条警告消息，并发送一个JMX通知。</td><td align="left">0</td></tr><tr><td align="left">rollbackOnReturn</td><td align="left">(boolean)如果autoCommit==false，当连接被归还时，通过调用连接的rollback方法中断事务。</td><td align="left">false</td></tr><tr><td align="left">commitOnReturn</td><td align="left">(boolean)如果autoCommit==false，当连接被归还时，通过调用连接的commit方法完成事务。如果rollbackOnReturn==ture，这个属性将被忽略。</td><td align="left">false</td></tr><tr><td align="left">alternateUsernameAllowed</td><td align="left">(boolean)为了提高性能，默认情况下，jdbc-pool将忽略 DataSource.getConnection(username,password)调用，直接返回一个以已有的全局配置的用户名和密码创建的连 接。连接池仍然可以用不同的用户名和密码，但已经通过旧的用户名和密码创建的连接将被关闭，然后重新以新的用户名和密码连接。这样连接池将以全局级别管理 连接数，而不是schema级别。设置这个属性为true来启用 DataSource.getConnection(username,password)方法描述的行为。<br> 这个属性为bug 50025 增加。</td><td align="left">false</td></tr><tr><td align="left">dataSource</td><td align="left">(javax.sql.DataSource)向连接池注入一个数据源，连接池将使用这个数据源索取连接，而不是通过java.sql.Driver接口建立。当您希望池化XA连接或者使用数据源而不是url时，这个属性非常有用。</td><td align="left">-</td></tr><tr><td align="left">dataSourceJNDI</td><td align="left">(String)用来建立数据连接的JNDI名称。参考dataSource属性。</td><td align="left">-</td></tr><tr><td align="left">useDisposableConnectionFacade</td><td align="left">(boolean)如果您希望在连接上建立一道屏障防止连接关闭之后被重新使用，设置这个属性为true。这个属性用来预防线程保持已关闭连接的引用，并在上面执行查询动作。</td><td align="left">true</td></tr><tr><td align="left">logValidationErrors</td><td align="left">(boolean)如果设置为true，将在验证相位时向日志文件写入错误。如果值为true，错误将被记录为SEVER。默认值是false以向后兼容。</td><td align="left">false</td></tr><tr><td align="left">propagateInterruptState</td><td align="left">(boolean)设置这个属性为true，可以传播一个被中断的线程（还没有清除中断状态）的中断状态。默认值为false以向后兼容。</td><td align="left">false</td></tr></tbody></table><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parentDataSource"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"org.apache.tomcat.jdbc.pool.DataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:maxWait</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:removeAbandoned</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:removeAbandonedTimeout</span>=<span class="string">"180"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:connectionProperties</span>=<span class="string">"clientEncoding=UTF-8"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:validationQuery</span>=<span class="string">"SELECT 1"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:validationInterval</span>=<span class="string">"30000"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:testOnBorrow</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:testOnReturn</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:testWhileIdle</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:timeBetweenEvictionRunsMillis</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:minEvictableIdleTimeMillis</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:logAbandoned</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:defaultAutoCommit</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">          </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">parent</span>=<span class="string">"parentDataSource"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:driverClassName</span>=<span class="string">"com.microsoft.sqlserver.jdbc.SQLServerDriver"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:url</span>=<span class="string">"jdbc:sqlserver://127.0.0.1:1433;DatabaseName=test;sendStringParametersAsUnicode=false"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:username</span>=<span class="string">"test"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:password</span>=<span class="string">"test"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:initialSize</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:maxActive</span>=<span class="string">"500"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:maxIdle</span>=<span class="string">"500"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:minIdle</span>=<span class="string">"100"</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Tomcat 在 7.0 以前的版本都是使用commons-dbcp做为连接池的实现，但是DBCP存在一些问题： &lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
    
      <category term="连接池" scheme="http://liuxing.info/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
      <category term="数据源" scheme="http://liuxing.info/tags/%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    
      <category term="Jdbc" scheme="http://liuxing.info/tags/Jdbc/"/>
    
  </entry>
  
  <entry>
    <title>Shadowsocks科学上网</title>
    <link href="http://liuxing.info/2015/09/09/shadowsocks%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91"/>
    <id>http://liuxing.info/2015/09/09/shadowsocks科学上网</id>
    <published>2015-09-09T02:09:00.000Z</published>
    <updated>2019-07-02T01:06:43.328Z</updated>
    
    <content type="html"><![CDATA[<p>由于一些大家都懂的原因，访问GitHub或者Google需要进行特殊的”配置”。<br>之前一直用红杏的方式，后来红杏不行了，最近发现了ShadowSocks，折腾一下发现稳定性、速度都比红杏要好很多，推荐给大家使用。</p><hr><p><code>有内网代理的可以直接跳到</code><a href="#配置浏览器插件">配置浏览器插件</a><br><code>有内网代理的可以直接跳到</code><a href="#配置浏览器插件">配置浏览器插件</a><br><code>有内网代理的可以直接跳到</code><a href="#配置浏览器插件">配置浏览器插件</a><br>重要的事情说三遍!</p><hr><p>先购买ss套餐，推荐下面这个</p><p><a href="https://www.gogoweixin.com/aff.php?aff=125" target="_blank" rel="noopener">https://www.gogoweixin.com/aff.php?aff=125</a></p><p>进入 服务 &gt; 试用&amp;购买 &gt; 优质线路套餐 &gt; 全能套餐15G流量包</p><p>50元15G，用完为止，不限时</p><h2 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h2><ul><li>下载各平台的软件<br>  Windows / MAC / Android<br>  链接:<a href="https://pan.baidu.com/s/1yFnuC_tg0NlqVgLTsYFsTw" target="_blank" rel="noopener">https://pan.baidu.com/s/1yFnuC_tg0NlqVgLTsYFsTw</a>  密码:0vk7</li><li>运行软件,设置账号信息(以<code>MAC</code>平台为例)<br>  <img src="/images/ss/01.png" alt="打开设置"><br>  <img src="/images/ss/03.png" alt="设置服务器信息"><br>  <img src="/images/ss/02.png" alt="使用自动代理模式"></li></ul><h2 id="配置浏览器插件"><a href="#配置浏览器插件" class="headerlink" title="配置浏览器插件"></a>配置浏览器插件</h2><p><code>以下教程的使用场景是chrome</code></p><p><strong>离线插件地址</strong><br>链接:<a href="https://pan.baidu.com/s/1yFnuC_tg0NlqVgLTsYFsTw" target="_blank" rel="noopener">https://pan.baidu.com/s/1yFnuC_tg0NlqVgLTsYFsTw</a>  密码:0vk7</p><p><strong>安装到chrome</strong></p><p><img src="/images/ss/04.png" alt="chrome安装插件"></p><p><strong>配置插件</strong></p><p>1.使用自己购买的服务,启动shadowsocks后,本机启动一个socks5的代理<br>代理协议选择<code>socks5</code>,地址是<code>127.0.0.1</code>,端口是<code>1080</code><br>配置完成后,点应用选项保存</p><p>2.使用内网代理地址的设置对应的 协议 IP 端口<br>socks5 192.168.3.51 1080<br>http 192.168.3.51 8123<br>配置完成后,点应用选项保存</p><p><img src="/images/ss/05.png" alt="配置代理信息"></p><p>3.设置自动切换<br><img src="/images/ss/06.png" alt="添加规则列表"></p><p>规则列表地址:<del><code>http://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt</code></del></p><p>注意：上面的规则地址已过期</p><p>新规则列表地址:<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code></p><p><img src="/images/ss/07.png" alt="添加规则列表"></p><p><img src="/images/ss/08.png" alt="改为自动切换"></p><p>有问题欢迎留言交流!!!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于一些大家都懂的原因，访问GitHub或者Google需要进行特殊的”配置”。&lt;br&gt;之前一直用红杏的方式，后来红杏不行了，最近发现了ShadowSocks，折腾一下发现稳定性、速度都比红杏要好很多，推荐给大家使用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;有内网代理的可以直
      
    
    </summary>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="linux" scheme="http://liuxing.info/tags/linux/"/>
    
      <category term="ss" scheme="http://liuxing.info/tags/ss/"/>
    
      <category term="shadowsocks" scheme="http://liuxing.info/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>重试机制的分析</title>
    <link href="http://liuxing.info/2015/07/08/%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%E7%9A%84%E5%88%86%E6%9E%90"/>
    <id>http://liuxing.info/2015/07/08/重试机制的分析</id>
    <published>2015-07-07T16:22:00.000Z</published>
    <updated>2019-07-02T01:06:43.331Z</updated>
    
    <content type="html"><![CDATA[<p><em>记录一下今天碰到的问题</em></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于经常跟网络编程打交道的你来说，并不是你的每次请求，服务端都会给你想要的结果。<br>重试机制虽然并不能解决这种情况，但是却可以大大减少这种情况的发生。</p><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>最近几天发现系统里面的solr数据频繁的出现数据同步不及时，统计数据以及分析日志后发现</p><ul><li>近期合并了几家公司，数据量增加了1倍多，200w+ &gt; 400w+（数据量增加后优化搜索，可以另起话题）。</li><li>访问用户增加后随之网络IO不稳定（暂定）。</li><li>使用的是其他同事基于solrj开发的工具包，不知是否是最优化配置。</li><li>提交数据后出现异常，只是简单的捕获处理。</li></ul><h2 id="土办法"><a href="#土办法" class="headerlink" title="土办法"></a>土办法</h2><p>先简单的加上一个重试机制。</p><p>原代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    inquirySolrService.commitBean(bean);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理后</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> retry = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> (retry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inquirySolrService.commitBean(bean);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage(), e);</span><br><span class="line">        retry --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来这样已经满足了，但是这种逻辑在好几个地方都有，同样的代码，想想就恶心。<br>想起在使用Spring RestTemplate / HttpClient的时候，可以设置一个重试的处理器。<br>重试机制是理解的，但是很好奇Spring到底是怎么处理的？毕竟大神们整的东西还是有学习的地方的！</p><h2 id="对RestTemplate重试的分析"><a href="#对RestTemplate重试的分析" class="headerlink" title="对RestTemplate重试的分析"></a>对RestTemplate重试的分析</h2><h3 id="处理器分析"><a href="#处理器分析" class="headerlink" title="处理器分析"></a>处理器分析</h3><p><strong>具体使用配置</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认的重试处理器</span></span><br><span class="line">httpClientBuilder.setRetryHandler(<span class="keyword">new</span> DefaultHttpRequestRetryHandler(<span class="number">2</span>, <span class="keyword">true</span>));</span><br></pre></td></tr></table></figure><p><strong>HttpRequestRetryHandler</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpRequestRetryHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retryRequest</span><span class="params">(IOException exception, <span class="keyword">int</span> executionCount, HttpContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DefaultHttpRequestRetryHandler</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultHttpRequestRetryHandler</span> <span class="keyword">implements</span> <span class="title">HttpRequestRetryHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultHttpRequestRetryHandler INSTANCE = <span class="keyword">new</span> DefaultHttpRequestRetryHandler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重试次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> retryCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否重试</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> requestSentRetryEnabled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这几类异常不重试</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Class&lt;? extends IOException&gt;&gt; nonRetriableClasses;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DefaultHttpRequestRetryHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">int</span> retryCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">boolean</span> requestSentRetryEnabled,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> Collection&lt;Class&lt;? extends IOException&gt;&gt; clazzes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.retryCount = retryCount;</span><br><span class="line">        <span class="keyword">this</span>.requestSentRetryEnabled = requestSentRetryEnabled;</span><br><span class="line">        <span class="keyword">this</span>.nonRetriableClasses = <span class="keyword">new</span> HashSet&lt;Class&lt;? extends IOException&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Class&lt;? extends IOException&gt; clazz: clazzes) &#123;</span><br><span class="line">            <span class="keyword">this</span>.nonRetriableClasses.add(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultHttpRequestRetryHandler</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> retryCount, <span class="keyword">final</span> <span class="keyword">boolean</span> requestSentRetryEnabled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(retryCount, requestSentRetryEnabled, Arrays.asList(</span><br><span class="line">                InterruptedIOException.class,</span><br><span class="line">                UnknownHostException.class,</span><br><span class="line">                ConnectException.class,</span><br><span class="line">                SSLException.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认配置3次重试，但是没有开启</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultHttpRequestRetryHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重试处理的核心方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retryRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> IOException exception,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">int</span> executionCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> HttpContext context)</span> </span>&#123;</span><br><span class="line">        Args.notNull(exception, <span class="string">"Exception parameter"</span>);</span><br><span class="line">        Args.notNull(context, <span class="string">"HTTP context"</span>);</span><br><span class="line">        <span class="keyword">if</span> (executionCount &gt; <span class="keyword">this</span>.retryCount) &#123;</span><br><span class="line">            <span class="comment">// Do not retry if over max retry count</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.nonRetriableClasses.contains(exception.getClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> Class&lt;? extends IOException&gt; rejectException : <span class="keyword">this</span>.nonRetriableClasses) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rejectException.isInstance(exception)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> HttpClientContext clientContext = HttpClientContext.adapt(context);</span><br><span class="line">        <span class="keyword">final</span> HttpRequest request = clientContext.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(requestIsAborted(request))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handleAsIdempotent(request)) &#123;</span><br><span class="line">            <span class="comment">// Retry if the request is considered idempotent</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!clientContext.isRequestSent() || <span class="keyword">this</span>.requestSentRetryEnabled) &#123;</span><br><span class="line">            <span class="comment">// Retry if the request has not been sent fully or</span></span><br><span class="line">            <span class="comment">// if it's OK to retry methods that have been sent</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// otherwise do not retry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong><br>这个处理器的逻辑不是很复杂，配置重试次数和重试开关，某几种异常不进行重试等等，都是Http请求特有的业务处理方法。<br>对于排除的异常配置，很好理解，就是非常明确这几类异常没必要重试了。</p><h3 id="底层运行逻辑"><a href="#底层运行逻辑" class="headerlink" title="底层运行逻辑"></a>底层运行逻辑</h3><p>其实RestTemplate是没有重试的运行逻辑（配置httpclient的方式），底层还是httpclient。<br>底层有好几个地方调用了<code>retryRequest()</code>逻辑，重试处理逻辑大致一样，挑RetryExec这个类吧！因为它代码比较少！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryExec</span> <span class="keyword">implements</span> <span class="title">ClientExecChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClientExecChain requestExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpRequestRetryHandler retryHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetryExec</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> ClientExecChain requestExecutor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> HttpRequestRetryHandler retryHandler)</span> </span>&#123;</span><br><span class="line">        Args.notNull(requestExecutor, <span class="string">"HTTP request executor"</span>);</span><br><span class="line">        Args.notNull(retryHandler, <span class="string">"HTTP request retry handler"</span>);</span><br><span class="line">        <span class="keyword">this</span>.requestExecutor = requestExecutor;</span><br><span class="line">        <span class="keyword">this</span>.retryHandler = retryHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CloseableHttpResponse <span class="title">execute</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> HttpRoute route,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> HttpRequestWrapper request,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> HttpClientContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> HttpExecutionAware execAware)</span> <span class="keyword">throws</span> IOException, HttpException </span>&#123;</span><br><span class="line">        Args.notNull(route, <span class="string">"HTTP route"</span>);</span><br><span class="line">        Args.notNull(request, <span class="string">"HTTP request"</span>);</span><br><span class="line">        Args.notNull(context, <span class="string">"HTTP context"</span>);</span><br><span class="line">        <span class="keyword">final</span> Header[] origheaders = request.getAllHeaders();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> execCount = <span class="number">1</span>;; execCount++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.requestExecutor.execute(route, request, context, execAware);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ex) &#123;</span><br><span class="line">                <span class="comment">// 检查可确定的中断逻辑，退出</span></span><br><span class="line">                <span class="comment">// 代码略</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 校验是否重试</span></span><br><span class="line">                <span class="keyword">if</span> (retryHandler.retryRequest(ex, execCount, context)) &#123;</span><br><span class="line">                    <span class="comment">// 记录日志和其他业务方法</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 业务处理，并抛出异常，退出</span></span><br><span class="line">                    <span class="comment">// 代码略</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上还是一个递归的逻辑，方法定义一个execCount计数，正常执行完毕就跳出循环。<br>出现异常时，用计数器去检查是否重试和比较重试次数，不通过就抛异常跳出循环。<br>好吧，我也没想到其实就是这样的！<br>考虑到一些其他框架里面都有重试的机制，逻辑应该都差不多，差异的只是对自己特有业务规则的处理。</p><p>httpclient底层执行请求时还有几个有意思的重试。<br>它把建立连接和请求内容等步骤又额外拆分成了独立的几个重试。<br>我猜想这样的好处是避免一个步骤出错导致整个流程重复执行。</p><h2 id="提取重试执行工具"><a href="#提取重试执行工具" class="headerlink" title="提取重试执行工具"></a>提取重试执行工具</h2><p>本着重复代码不要写第二次的原则，还是硬着头皮提取了一个重试执行工具</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>：RetryUtil重试执行工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：liuxing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>：2015-07-08 01:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(RetryUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecuteFunction</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> retryCount</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwIfFail</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(<span class="keyword">int</span> retryCount, <span class="keyword">long</span> interval, TimeUnit timeUnit, <span class="keyword">boolean</span> throwIfFail, ExecuteFunction function)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (function == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; retryCount; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                function.execute();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == retryCount - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (throwIfFail) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (timeUnit != <span class="keyword">null</span> &amp;&amp; interval &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            timeUnit.sleep(interval);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                            LOGGER.error(e1.getMessage(), e1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有间隔的重试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> retryCount</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(<span class="keyword">int</span> retryCount, <span class="keyword">long</span> interval, TimeUnit timeUnit, ExecuteFunction handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        retry(retryCount, interval, timeUnit, <span class="keyword">false</span>, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不间隔重试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> retryCount</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(<span class="keyword">int</span> retryCount, ExecuteFunction function)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        retry(retryCount, -<span class="number">1</span>, <span class="keyword">null</span>, function);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用重试工具执行方法，对比下来可读性好了很多</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> retry = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> (retry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inquirySolrService.commitBean(bean);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage(), e);</span><br><span class="line">        retry --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    RetryUtil.retry(<span class="number">3</span>, <span class="number">50L</span>, TimeUnit.MILLISECONDS, () -&gt; &#123;</span><br><span class="line">        inquirySolrService.commitBean(bean);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>PS：保持好奇心，平常碰到的简单问题也记录总结一下，挺有意思的！</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;记录一下今天碰到的问题&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于经常跟网络编程打交道的你来说，并不是你的每次请求，服务端都会给你想要的
      
    
    </summary>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
    
      <category term="Java" scheme="http://liuxing.info/tags/Java/"/>
    
      <category term="重试工具" scheme="http://liuxing.info/tags/%E9%87%8D%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Spring JMS粗译</title>
    <link href="http://liuxing.info/2015/07/05/Spring%20JMS%E7%B2%97%E8%AF%91"/>
    <id>http://liuxing.info/2015/07/05/Spring JMS粗译</id>
    <published>2015-07-05T13:30:00.000Z</published>
    <updated>2019-07-02T01:06:43.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="24-1介绍"><a href="#24-1介绍" class="headerlink" title="24.1介绍"></a>24.1介绍</h2><p>Spring提供了JMS集成框架简化了JMS API的使用，像Spring JDBC API的使用。</p><p>JMS的功能大致上分为两块，叫做消息发送和消息监听。JmsTemplate 用于发送消息和同步消息监听。和Java EE的事件驱动Bean风格类似，对于异步接收消息，Spring提供了一些消息监听容器来创建消息驱动的POJO（MDP）。</p><p>包 <code>org.springframework.jms.core</code> 提供使用JMS的核心功能。 就象为JDBC提供的 JdbcTemplate一样，它提供了JMS模板类来处理资源的创建和释放以简化JMS的使用。Spring模板类的公共设计原则就是通过提供工具方法去执行公共的操作，并将实际的处理任务委派到用户实现的回调接口上，从而完成更复杂的操作。JMS模板也遵循这样的设计原则。这些类提供众多便利的方法来发送消息、同步接收消息、使用户可以接触到JMS session和消息产生者。</p><p>包 <code>org.springframework.jms.support</code> 提供 <code>JMSException</code> 的转换功能。它将受控的 <code>JMSException</code> 异常层次转换到一个对应的非受控异常层次。任何受控 <code>javax.jms.JMSException</code> 异常的子类都被包装在非受控  <code>UncategorizedJmsException</code> 异常里。</p><p>包 <code>org.springframework.jms.support.converter</code> 提供一个 <code>MessageConverter</code> 用来抽象Java对象和JMS消息之间的转换操作。</p><p>包 <code>org.springframework.jms.support.destination</code> 为管理JMS目的地提供多种策略，例如为存储在JNDI中的目的地提供一个服务定位器。</p><p>包 <code>org.springframework.jms.annotation</code> 提供了必要的基础设施 支持注解驱动的端点侦听器使用 <code>@JmsListener</code>。</p><p>包 <code>org.springframework.jms.config</code> 提供的解析器实现 jms 命名空间以及java配置支持容器和配置监听器、创建端点侦听器。</p><p>包 <code>org.springframework.jms.connection</code> 提供一个适合在独立应用中使用的 <code>ConnectionFactory</code> 的实现。它还为JMS提供了一个Spring的 <code>PlatformTransactionManager</code> 的实现（现在叫做 <code>JmsTransactionManager</code>）。这样可以把JMS作为一个事务资源无缝地集成到Spring的事务管理机制中去。</p><h2 id="24-2使用Spring-JMS"><a href="#24-2使用Spring-JMS" class="headerlink" title="24.2使用Spring JMS"></a>24.2使用Spring JMS</h2><h3 id="24-2-1-JmsTemplate"><a href="#24-2-1-JmsTemplate" class="headerlink" title="24.2.1 JmsTemplate"></a>24.2.1 JmsTemplate</h3><p>使用 <strong>JmsTemplate</strong> 的代码只需要实现规范中定义的回调接口。<strong>MessageCreator</strong> 回调接口通过 <strong>JmsTemplate</strong> 中调用代码提供的<strong>Session</strong>来创建一条消息。然而，为了允许更复杂的JMS API应用，回调接口<strong>SessionCallback</strong> 为用户提供JMS session，并且回调接口<strong>ProducerCallback</strong> 将<strong>Session</strong>和<strong>MessageProducer</strong>对显露给用户。</p><p>JMS API有两种发送方法，一种采用发送模式、优先级和存活时间作为服务质量（QOS）参数，另一种使用无需QOS参数的缺省值方法。由于在 JmsTemplate 中有许多种发送方法，QOS参数通过bean的属性方式进行设置，从而避免在多种发送方法中重复。同样，使用 setReceiveTimeout 属性值来设置同步接收调用的超时值。</p><p>某些JMS供应者允许通过ConnectionFactory的配置来设置缺省的QOS值。这样在调用 MessageProducer 的发送方法 send(Destination destination, Message message) 时会使用那些不同的QOS缺省值，而不是JMS规范中定义的值。所以，为了提供对QOS值的一致管理，JmsTemplate必须通过设置布尔值属性 isExplicitQosEnabled 为true，使它能够使用自己的QOS值。</p><blockquote><p>JmsTemplate 类的实例 一经配置便是线程安全 的。 这很重要，因为这意味着你可以配置一个 JmsTemplate 的单例，然后把这个 共享的 引用安全的实例注入多个协作的对象中。 要清楚一点，JmsTemplate 是有状态的，因为它维护了 ConnectionFactory 的引用，但这个状态不属于会话状态。</p></blockquote><p>Spring Framework 4.1提供了一个<strong>JmsMessagingTemplate</strong>，这个是对JmsTemplate的包装，主要用来发送最基本的消息内容，即<code>org.springframework.messaging.Message</code></p><h3 id="24-2-2连接"><a href="#24-2-2连接" class="headerlink" title="24.2.2连接"></a>24.2.2连接</h3><p>JmsTemplate 需要一个对 ConnectionFactory 的引用。ConnectionFactory 是JMS规范的一部分，并且是使用JMS的入口。客户端应用通常用它作工厂配合JMS提供者去创建连接，并封装许多和供应商相关的配置参数，例如SSL的配置选项。</p><p>当在EJB里使用JMS时，供应商会提供JMS接口的实现，这样们可以参与声明式事务管理并提供连接池和会话池。 为了使用这个JMS实现，Java EE容器通常要求你在EJB或servlet部署描述符中声明一个JMS连接工厂做为 resource-ref。 为确保可以在EJB内使用 JmsTemplate 的这些特性，客户应用应当确保它引用了被管理的ConnectionFactory实现。</p><p><strong>缓存消息传递资源</strong><br>标准的API执行流程如下：<br>ConnectionFactory-&gt;Connection-&gt;Session-&gt;MessageProducer-&gt;send</p><p>从创建到发送有三个中间对象的创建和销毁，为了提高性能，Spring提供了<strong>ConnectionFactory</strong></p><p><strong>SingleConnectionFactory</strong><br>Spring提供了一个 ConnectionFactory 接口的实现，SingleConnectionFactory，它将在所有的 createConnection 调用中返回一个相同的 Connection，并忽略所有对 close的调用。这在测试和独立环境中相当有用，因为多个 JmsTemplate 调用可以使用同一个连接以跨越多个事务。SingleConnectionFactory 通常引用一个来自JNDI的标准 ConnectionFactory。</p><p><strong>CachingConnectionFactory</strong><br>CachingConnectionFactory类扩展自SingleConnectionFactory，主要用于提供缓存JMS资源功能。具体包括MessageProducer、MessageConsumer和Session的缓存功能。<br>默认情况下，CachingConnectionFactory只缓存一个session，在它的JavaDoc中，它声明对于低并发情况下这是足够的。可以使用SessionCacheSize进行配置。</p><h3 id="24-2-3目的地管理"><a href="#24-2-3目的地管理" class="headerlink" title="24.2.3目的地管理"></a>24.2.3目的地管理</h3><p>和连接工厂一样，目的地是可以在JNDI中存储和获取的JMS管理的对象。配置一个Spring应用上下文时，可以使用JNDI工厂类 JndiObjectFactoryBean 把对你对象的引用依赖注入到JMS目的地中。然而，如果在应用中有大量的目的地，或者JMS供应商提供了特有的高级目的地管理特性，这个策略常常显得很麻烦。创建动态目的地或支持目的地的命名空间层次就是这种高级目的地管理的例子。JmsTemplate 将目的地名称到JMS目的地对象的解析委派给 DestinationResolver 接口的一个实现。JndiDestinationResolver 是 JmsTemplate 使用的默认实现，并且提供动态目的地解析。同时 JndiDestinationResolver 作为JNDI中的目的地服务定位器，还可选择回退去使用 DynamicDestinationResolver 中的行为。</p><p>经常见到一个JMS应用中使用的目的地只有在运行时才知道，因此，当部署一个应用时，它不能用可管理的方式创建。这是经常发生的，因为在互相作用的系统组件间有些共享应用逻辑会在运行的时候按照共同的命名规范创建消息目的地。虽然动态创建目的地不是JMS规范的一部分，但是大多数供应商已经提供了这个功能。用户为动态创建的目的地定义和临时目的地不同的名字，并且通常不被注册到JNDI中。不同供应商创建动态消息目的地所使用的API差异很大，因为和目的地相关的属性是供应商特有的。然而，有时由供应商会作出一个简单的实现选择-忽略JMS规范中的警告，使用 TopicSession 的方法 createTopic(String topicName) 或者 QueueSession 的方法 createQueue(String queueName) 来创建一个带默认值属性的新目的地。依赖于供应商的实现，DynamicDestinationResolver 也可能创建一个物理上的目的地，而不再仅仅是一个解析。</p><p>布尔属性 pubSubDomain 用来配置 JmsTemplate 使用什么样的JMS域。这个属性的默认值是false，使用点到点的域，也就是队列。在1.0.2的实现中，这个属性值用来决定 JmsTemplate 将消息发送到一个 Queue 还是一个 Topic。这个标志在1.1的实现中对发送操作没有影响。然而，在这两个JMS版本中，这个属性决定了通过接口 DestinationResolver 的实现来决定如何解析动态消息目的地。</p><p>你还可以通过属性 defaultDestination 配置一个带有默认目的地的 JmsTemplate。不指明目的地的发送和接受操作将使用该默认目的地。</p><h3 id="24-2-4消息监听容器"><a href="#24-2-4消息监听容器" class="headerlink" title="24.2.4消息监听容器"></a>24.2.4消息监听容器</h3><p>在EJB世界里，JMS消息最常用的功能之一是用于实现消息驱动Bean（MDB）。Spring提供了一个方法来创建消息驱动的POJO（MDP），并且不会把用户绑定在某个EJB容器上。</p><p>通常用消息监听器容器从JMS消息队列接收消息并驱动被注射进来的MDP。消息监听器容器负责消息接收的多线程处理并分发到各MDP中。一个消息侦听容器是MDP和消息提供者之间的一个中介，用来处理消息接收的注册，事务管理的参与，资源获取和释放，异常转换等等。这使得应用开发人员可以专注于开发和接收消息（可能的响应）相关的（复杂）业务逻辑，把和JMS基础框架有关的样板化的部分委托给框架处理。</p><p><strong>SimpleMessageListenerContainer</strong><br>这个消息侦听容器是最简单的。它在启动时创建固定数量的JMS session并在容器的整个生命周期中使用它们。这个类不能动态的适应运行时的要求或参与消息接收的事务处理。然而它对JMS提供者的要求也最低。它只需要简单的JMS API。</p><p><strong>DefaultMessageListenerContainer</strong><br>这个消息侦听器使用的最多。和 SimpleMessageListenerContainer 相反，这个子类可以动态适应运行时侯的要求，也可以参与事务管理。每个收到的消息都注册到一个XA事务中（如果使用 JtaTransactionManager 配置过），这样就可以利用XA事务语义的优势了。这个类在对JMS提供者的低要求和提供包括事务参于等的强大功能上取得了很好的平衡。</p><h3 id="24-2-5事务管理"><a href="#24-2-5事务管理" class="headerlink" title="24.2.5事务管理"></a>24.2.5事务管理</h3><p>Spring提供了 JmsTransactionManager 为单个JMS ConnectionFactory 管理事务。这将允许JMS应用利用Spring的事务管理功能。JmsTransactionManager 绑定 ConnectionFactory 的一个Connection/Session对到线程上，来提供本地资源事务。JmsTemplate 自动检测到这些事务性资源从而对它们进行操作。</p><p>在Java EE环境中，SingleConnectionFactory将把Connection和Session放到缓冲池中，因此这些资源在事务中得到了有效的复用。在独立环境中使用Spring的 SingleConnectionFactory 会存在共享的JMS Connection，但每个事务有自己独立的 Session。另外可以考虑使用供应商特定的池适配器,，如ActiveMQ的 PooledConnectionFactory 类。</p><p>JmsTemplate 也可以和 JtaTransactionManager 以及具有XA能力的JMS ConnectionFactory一起使用来提供分布式事务。记住这需要使用JTA事务管理器或合适的可配置的XA ConnectionFactory！（参考你所使用的J2EE服务器/JMS供应商的文档。）</p><p>当使用JMS API从一个 Connection 中创建 Session 时，在受管理的和非受管理的事务环境下重用代码会可能会让人迷惑。这是因为JMS API只有一个工厂方法来创建 Session ，并且它需要用于事务和模式确认的值。在受管理的环境下，由事务结构环境负责设置这些值，这样在供应商包装的JMS连接中可以忽略这些值。当在一个非管理性的环境中使用 JmsTemplate 时，你可以通过使用属性 SessionTransacted 和 SessionAcknowledgeMode 来指定这些值。当 JmsTemplate 配合 PlatformTransactionManager 使用时，模板将一直被赋予一个事务性JMS的 Session。</p><h2 id="24-3发送消息"><a href="#24-3发送消息" class="headerlink" title="24.3发送消息"></a>24.3发送消息</h2><p>JmsTemplate 包含许多方便的方法来发送消息。有些发送方法可以使用 javax.jms.Destination 对象指定目的地，也可以使用字符串在JNDI中查找目的地。没有目的地参数的发送方法使用默认的目的地。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Queue;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.MessageCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsQueueSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionFactory</span><span class="params">(ConnectionFactory cf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jmsTemplate = <span class="keyword">new</span> JmsTemplate(cf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQueue</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jmsTemplate.send(<span class="keyword">this</span>.queue, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(<span class="string">"hello queue world"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子使用 MessageCreator 回调接口从提供的 Session 对象中创建一个文本消息，并且通过一个 ConnectionFactory 的引用来创建 JmsTemplate。提供了一个无参数的构造器和 connectionFactory 可用于创建实例（使用一个BeanFactory或者普通Java代码）。或者考虑继承Spring的基类 JmsGatewaySupport，它对JMS配置具有内置的Bean属性。</p><p>方法 send(String destinationName, MessageCreator creator) 让你利用目的地的字符串名字发送消息。如果这个名字在JNDI中注册，你应当将模板中的 destinationResolver 属性设置为 JndiDestinationResolver 的一个实例。<br>如果你创建 JmsTemplate 并指定一个默认的目的地，send(MessageCreator c) 发送消息到这个目的地。</p><h3 id="24-3-1使用消息转换器"><a href="#24-3-1使用消息转换器" class="headerlink" title="24.3.1使用消息转换器"></a>24.3.1使用消息转换器</h3><p>为便于发送领域模型对象，JmsTemplate 有多种以一个Java对象为参数并做为消息数据内容的发送方法。JmsTemplate 里可重载的方法 convertAndSend 和 receiveAndConvert 将转换的过程委托给接口 MessageConverter 的一个实例。这个接口定义了一个简单的合约用来在Java对象和JMS消息间进行转换。缺省的实现 SimpleMessageConverter 支持 String 和 TextMessage，byte[] 和 BytesMesssage，以及 java.util.Map 和 MapMessage 之间的转换。使用转换器，可以使你和你的应用关注于通过JMS接收和发送的业务对象而不用操心它是具体如何表达成JMS消息的。</p><p>目前的沙箱模型包括一个 MapMessageConverter，它使用反射转换JavaBean和 MapMessage。其他流行可选的实现方式包括使用已存在的XML编组的包，例如JAXB、Castor、XMLBeans或XStream的转换器来创建一个表示对象的 TextMessage。</p><p>为方便那些不能以通用方式封装在转换类里的消息属性，消息头和消息体的设置，通过 MessagePostProcessor 接口你可以在消息被转换后并且在发送前访问该消息。下例展示了如何在 java.util.Map 已经转换成一个消息后更改消息头和属性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendWithConversion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"Name"</span>, <span class="string">"Mark"</span>);</span><br><span class="line">    map.put(<span class="string">"Age"</span>, <span class="keyword">new</span> Integer(<span class="number">47</span>));</span><br><span class="line">    jmsTemplate.convertAndSend(<span class="string">"testQueue"</span>, map, <span class="keyword">new</span> MessagePostProcessor() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">            message.setIntProperty(<span class="string">"AccountID"</span>, <span class="number">1234</span>);</span><br><span class="line">            message.setJMSCorrelationID(<span class="string">"123-00001"</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将产生以下消息格式</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">MapMessage=&#123;</span><br><span class="line">Header=&#123;</span><br><span class="line">... standard headers ...</span><br><span class="line">CorrelationID=&#123;123-00001&#125;</span><br><span class="line">&#125;</span><br><span class="line">Properties=&#123;</span><br><span class="line">AccountID=&#123;Integer:1234&#125;</span><br><span class="line">&#125;</span><br><span class="line">Fields=&#123;</span><br><span class="line">Name=&#123;String:Mark&#125;</span><br><span class="line">Age=&#123;Integer:47&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24-3-2-SessionCallback和ProducerCallback"><a href="#24-3-2-SessionCallback和ProducerCallback" class="headerlink" title="24.3.2 SessionCallback和ProducerCallback"></a>24.3.2 SessionCallback和ProducerCallback</h3><p>虽然send操作适用于许多常见的使用场景，但是有时你需要在一个JMS Session 或者 MessageProducer 上执行多个操作。接口 SessionCallback 和 ProducerCallback 分别提供了JMS Session 和 Session / MessageProducer 对。JmsTemplate 上的 execute() 方法执行这些回调方法。</p><h2 id="24-4接收消息"><a href="#24-4接收消息" class="headerlink" title="24.4接收消息"></a>24.4接收消息</h2><h3 id="24-4-1同步接收"><a href="#24-4-1同步接收" class="headerlink" title="24.4.1同步接收"></a>24.4.1同步接收</h3><p>虽然JMS一般都和异步处理相关，但它也可以同步的方式使用消息。可重载的 receive(..) 方法提供了这种功能。在同步接收中，接收线程被阻塞直至获得一个消息，有可能出现线程被无限阻塞的危险情况。属性 receiveTimeout 指定了接收器可等待消息的延时时间。</p><h3 id="24-4-2异步接收消息驱动pojo"><a href="#24-4-2异步接收消息驱动pojo" class="headerlink" title="24.4.2异步接收消息驱动pojo"></a>24.4.2异步接收消息驱动pojo</h3><blockquote><p>Spring还提供一个 @JmsListener 的注解，以非嵌入式的方式异步接受消息。</p></blockquote><p>类似于EJB世界里流行的消息驱动Bean（MDB），消息驱动POJO（MDP）作为JMS消息的接收器。MDP的一个约束（但也请看下面的有关 javax.jms.MessageListener 类的讨论）是它必须实现 javax.jms.MessageListener 接口。另外当你的POJO将以多线程的方式接收消息时必须确保你的代码是线程-安全的。</p><p>以下是MDP的一个简单实现:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> TextMessage) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(((TextMessage) message).getText());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (JMSException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must be of type TextMessage"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦你实现了 MessageListener 后就可以创建一个消息侦听容器。<br>请看下面例子是如何定义和配置一个随Sping发行的消息侦听容器的（这个例子用 DefaultMessageListenerContainer）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageListener"</span> <span class="attr">class</span>=<span class="string">"jmsexample.ExampleListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- and this is the message listener container --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsContainer"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"destination"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"messageListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于各个消息侦听容器实现的功能请参阅相关的Spring Javadoc文档。</p><h3 id="24-4-3-SessionAwareMessageListener接口"><a href="#24-4-3-SessionAwareMessageListener接口" class="headerlink" title="24.4.3 SessionAwareMessageListener接口"></a>24.4.3 SessionAwareMessageListener接口</h3><p>SessionAwareMessageListener 接口是一个Spring专门用来提供类似于JMS MessageListener 的接口，也提供了从接收 Message 来访问JMS Session 的消息处理方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.jms.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionAwareMessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Session session)</span> <span class="keyword">throws</span> JMSException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你希望你的MDP可以响应所有接收到的消息（使用 onMessage(Message, Session) 方法提供的 Session）那么你可以选择让你的MDP实现这个接口（优先于标准的JMS MessageListener 接口)。所有随Spring发行的支持MDP的消息侦听容器都支持 MessageListener 或 SessionAwareMessageListener 接口的实现。要注意的是实现了 SessionAwareMessageListener 接口的类通过接口和Spring有了耦合。是否选择使用它完全取决于开发者或架构师。</p><p>请注意 SessionAwareMessageListener 接口的 ‘onMessage(..)’ 方法会抛出 JMSException异常。和标准JMS MessageListener 接口相反，当使用 SessionAwareMessageListener 接口时，客户端代码负责处理任何抛出的异常。</p><h3 id="24-4-4-MessageListenerAdapter"><a href="#24-4-4-MessageListenerAdapter" class="headerlink" title="24.4.4 MessageListenerAdapter"></a>24.4.4 MessageListenerAdapter</h3><p>MessageListenerAdapter 类是Spring的异步支持消息类中的不变类（final class）：简而言之，它允许你几乎将 任意 一个类做为MDP显露出来（当然有某些限制）。</p><p>考虑如下接口定义。注意虽然这个接口既不是从 MessageListener 也不是从 SessionAwareMessageListener 继承来得，但通过 MessageListenerAdapter 类依然可以当作一个MDP来使用。同时也请注意各种消息处理方法是如何根据他们可以接收并处理消息的内容来进行强类型匹配的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Map message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">byte</span>[] message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Serializable message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMessageDelegate</span> <span class="keyword">implements</span> <span class="title">MessageDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别请注意，上面的 MessageDelegate 接口（上文中 DefaultMessageDelegate 类）的实现完全 不 依赖于JMS。它是一个真正的POJO，我们可以通过如下配置把它设置成MDP。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageListener"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.adapter.MessageListenerAdapter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"jmsexample.DefaultMessageDelegate"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- and this is the message listener container... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsContainer"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"destination"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"messageListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是另外一个只能处理接收JMS TextMessage 消息的MDP示例。注意消息处理方法是如何实际调用 ‘receive’ （在 MessageListenerAdapter 中默认的消息处理方法的名字是 ‘handleMessage’）的，但是它是可配置的（你下面就将看到）。注意 ‘receive(..)’ 方法是如何使用强制类型来只接收和处理JMS TextMessage消息的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TextMessageDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(TextMessage message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultTextMessageDelegate</span> <span class="keyword">implements</span> <span class="title">TextMessageDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>辅助的 MessageListenerAdapter 类配置文件类似如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageListener"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.adapter.MessageListenerAdapter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"jmsexample.DefaultTextMessageDelegate"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultListenerMethod"</span> <span class="attr">value</span>=<span class="string">"receive"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- we don't want automatic message context extraction --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请注意，如果上面的 ‘messageListener’ 收到一个不是 TextMessage 类型的JMS Message，将会产生一个 IllegalStateException 异常（随之产生的其他异常只被捕获而不处理）。<br>MessageListenerAdapter 还有一个功能就是如果处理方法返回一个非空值，它将自动返回一个响应 消息。<br>请看下面的接口及其实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponsiveTextMessageDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// notice the return type...</span></span><br><span class="line">    <span class="function">String <span class="title">receive</span><span class="params">(TextMessage message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResponsiveTextMessageDelegate</span> <span class="keyword">implements</span> <span class="title">ResponsiveTextMessageDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面的 DefaultResponsiveTextMessageDelegate 和 MessageListenerAdapter 联合使用，那么任意从执行 ‘receive(..)’ 方法返回的非空值都将（缺省情况下）转换成一个 TextMessage。这个返回的 TextMessage 将被发送到原来的 Message 中JMS Reply-To属性定义的 目的地（如果存在），或者是 MessageListenerAdapter 设置（如果配置了）的缺省 目的地；如果没有定义 目的地，那么将产生一个 InvalidDestinationException 异常（此异常将不会只被捕获而不处理，它 将沿着调用堆栈上传）。</p><h3 id="24-4-5事务中的消息处理"><a href="#24-4-5事务中的消息处理" class="headerlink" title="24.4.5事务中的消息处理"></a>24.4.5事务中的消息处理</h3><p>在消息监听器的调用中使用事务只需要重新配置监听器容器<br>通过监听器容器定义中的 sessionTransacted 标记可以轻松的激活本地资源事务。每次消息监听器的调用都在激活的JMS事务中执行，执行失败时，消息接收将发生回滚。这个本地事务还将包含响应信息的发送（通过 SessionAwareMessageListener），但其它资源的操作（例如访问数据库）是独立的。经常会发生类似于数据库处理已提交但消息处理提交失败的情况，因此需要在监听器的实现中进行重复消息的检测。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsContainer"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"destination"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"messageListener"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionTransacted"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当参与外部管理的事务时，你需要使用支持外来事务的监听器容器：通常是 DefaultMessageListenerContainer 来配置事务管理器。</p><p>参与XA事务时，消息监听器容器需要配置 JtaTransactionManager（默认会委托给J2EE服务器事务子系统）。注意以下JMS ConnectionFactory需要具有XA能力并注册JTA事务协调器！（参考你所使用的J2EE服务器中JNDI资源的配置。）这样，消息接收就像数据库访问一样作为同一个事务的一部分（具有统一提交的语义，仅仅增加了XA事务日志的额外开销）。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.jta.JtaTransactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>然后你只需要把它添加到早先配置好的容器中。这个容器将处理剩下的事情。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsContainer"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"destination"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"messageListener"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="24-5JCA消息端点的支持"><a href="#24-5JCA消息端点的支持" class="headerlink" title="24.5JCA消息端点的支持"></a>24.5JCA消息端点的支持</h2><p>从Spring2.5版本开始，Spring也提供了基于JCA MessageListener 容器的支持。 JmsMessageEndpointManager 将根据供应者 ResourceAdapter 的类名自动地决定 ActivationSpec 类名。因此，通常它只提供如下例所示的Spring的通用 JmsActivationSpecConfig 。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resourceAdapter"</span> <span class="attr">ref</span>=<span class="string">"resourceAdapter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"activationSpecConfig"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destinationName"</span> <span class="attr">value</span>=<span class="string">"myQueue"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"myMessageListener"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外,你可以设置一个 JmsMessageEndpointManager 指定 ActivationSpec 对象。  ActivationSpec 对象可以通过JNDI查找来完成 (使用 <code>&lt;jee:jndi-lookup&gt;</code> )。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resourceAdapter"</span> <span class="attr">ref</span>=<span class="string">"resourceAdapter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"activationSpec"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ra.ActiveMQActivationSpec"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">value</span>=<span class="string">"myQueue"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destinationType"</span> <span class="attr">value</span>=<span class="string">"javax.jms.Queue"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"myMessageListener"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用Spring的 ResourceAdapterFactoryBean， 目标 ResourceAdapter 可以像下例描述的那样本地配置。 在一些环境里（如WebLogic）也可以通过JNDI查找来完成。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceAdapter"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jca.support.ResourceAdapterFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"resourceAdapter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ra.ActiveMQResourceAdapter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serverUrl"</span> <span class="attr">value</span>=<span class="string">"tcp://localhost:61616"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"workManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jca.work.SimpleTaskWorkManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请参考 JmsMessageEndpointManager、JmsActivationSpecConfig 和 ResourceAdapterFactoryBean 部分的JavaDoc，以获得更详细的信息。</p><p>Spring也提供了并不与JMS绑定的通用JCA消息端点管理器： org.springframework.jca.endpoint.GenericMessageEndpointManager。 它允许使用任何类型的消息监听器（例如CCI MessageListener）和任何提供者特定的ActivationSpec对象。从所涉及的JCA提供者的文档可以找到这个连接器的实际能力，从 GenericMessageEndpointManager 的JavaDoc中可以找到Spring特有的配置细节。</p><blockquote><p>基于JCA的消息端点管理器与EJB 2.1的Message-Driven Beans很相似，它使用了相同的资源提供者约定。像EJB 2.1 MDB一样，任何被JCA提供者支持的消息监听器接口都可以在Spring Context中使用。尽管如此，Spring仍为JMS提供了显式的“方便的”支持，很显然是因为JMS是JCA端点管理约定中最通用的端点API。</p></blockquote><h2 id="24-6注解驱动的监听器"><a href="#24-6注解驱动的监听器" class="headerlink" title="24.6注解驱动的监听器"></a>24.6注解驱动的监听器</h2><p>异步接受消息最简单的方法是使用<code>@JmsListener</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"myDestination"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">(String data)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中，收到destination为“myDestination”的消息后，processOrder方法将被执行。</p><p>带注解的监听方法，底层是使用JmsListenerContainerFactory容器</p><h3 id="24-6-1启用端点侦听器的注解"><a href="#24-6-1启用端点侦听器的注解" class="headerlink" title="24.6.1启用端点侦听器的注解"></a>24.6.1启用端点侦听器的注解</h3><p>Bean配置的方式：</p><p>为了使用@JmsListener注解，需要添加 @EnableJms 到 @Configuration 类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJms</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">jmsListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory =</span><br><span class="line">                <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory());</span><br><span class="line">        factory.setDestinationResolver(destinationResolver());</span><br><span class="line">        factory.setConcurrency(<span class="string">"3-10"</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用DefaultJmsListenerContainerFactory作为消息监听容器，setConcurrency用于配置消费线程，这里是最小3个，最大10个。</p><p>XML的方式：<br>使用<code>&lt;jms:annotation-driven&gt;</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jms:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsListenerContainerFactory"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.jms.config.DefaultJmsListenerContainerFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destinationResolver"</span> <span class="attr">ref</span>=<span class="string">"destinationResolver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"concurrency"</span> <span class="attr">value</span>=<span class="string">"3-10"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="24-6-2编程注册端点"><a href="#24-6-2编程注册端点" class="headerlink" title="24.6.2编程注册端点"></a>24.6.2编程注册端点</h3><p>JmsListenerEndpoint提供一个JMS端点模型和负责模型配置容器。允许我们以编程方式配置除了jmsListener外的端点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJms</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> <span class="keyword">implements</span> <span class="title">JmsListenerConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureJmsListeners</span><span class="params">(JmsListenerEndpointRegistrar registrar)</span> </span>&#123;</span><br><span class="line">        SimpleJmsListenerEndpoint endpoint = <span class="keyword">new</span> SimpleJmsListenerEndpoint();</span><br><span class="line">        endpoint.setId(<span class="string">"myJmsEndpoint"</span>);</span><br><span class="line">        endpoint.setDestination(<span class="string">"anotherQueue"</span>);</span><br><span class="line">        endpoint.setMessageListener(message -&gt; &#123;</span><br><span class="line">            <span class="comment">// processing</span></span><br><span class="line">        &#125;);</span><br><span class="line">        registrar.registerEndpoint(endpoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们使用SimpleJmsListenerEndpoint提供要调用的实际消息监听者，但你也可以建立自己的端点变量描述自定义调用机制。</p><p>值得注意的是，你也可以完全跳过使用@JmsListener，只通过JmsListenerConfigurer以编程方式注册您的端点。</p><h2 id="24-7JMS命名空间支持"><a href="#24-7JMS命名空间支持" class="headerlink" title="24.7JMS命名空间支持"></a>24.7JMS命名空间支持</h2><p>Spring JMS引入了XML命名空间以简化JMS的配置。使用JMS命名空间元素时，需要引用如下的JMS Schema：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:jms</span>=<span class="string">"http://www.springframework.org/schema/jms"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- bean definitions here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个命名空间由两级元素组成：<code>&lt;listener-container/&gt;</code> 和 <code>&lt;jca-listener-container/&gt;</code>，它们都可以包含一个或这个多个 <listener> 子元素。下面是一个基本配置的示例，包含两个监听器。</listener></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jms:listener-container</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jms:listener</span> <span class="attr">destination</span>=<span class="string">"queue.orders"</span> <span class="attr">ref</span>=<span class="string">"orderService"</span> <span class="attr">method</span>=<span class="string">"placeOrder"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jms:listener</span> <span class="attr">destination</span>=<span class="string">"queue.confirmations"</span> <span class="attr">ref</span>=<span class="string">"confirmationLogger"</span> <span class="attr">method</span>=<span class="string">"log"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">jms:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的例子等同于在<a href="#2444-messagelisteneradapter">24.4.4MessageListenerAdapter</a>的示例中，定义两个不同的监听器容器和两个不同的 MessageListenerAdapter 。除了上面的属性外，listener 元素还具有几个可选的属性。下面的表格列出了所有的属性：</p><p><strong>表24.1 JMS listener 元素的属性</strong> </p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">监听器容器的Bean名称。如果没有指定，将自动生成一个Bean名称。</td></tr><tr><td align="left">destination （必须）</td><td align="left">监听器目的地的名称，由 DestinationResolver 的策略决定。</td></tr><tr><td align="left">ref （必须）</td><td align="left">处理对象的Bean名称</td></tr><tr><td align="left">method</td><td align="left">处理器中被调用的方法名。如果 ref 指向 MessageListener 或者 Spring SessionAwareMessageListener，则这个属性可以被忽略。</td></tr><tr><td align="left">response-destination</td><td align="left">默认的响应目的地是发送响应消息抵达的目的地。 这用于请求消息没有包含”JMSReplyTo”域的情况。响应目的地类型被监听器容器的”destination-type”属性决定。记住：这仅仅适用于有返回值的监听器方法，因为每个结果对象都会被转化成响应消息。</td></tr><tr><td align="left">subscription</td><td align="left">持久订阅的名称，如果需要的话。</td></tr><tr><td align="left">selector</td><td align="left">监听器的一个可选的消息选择器。</td></tr><tr><td align="left">concurrency</td><td align="left">并发的数量，格式：5（最大），3-5（最小和最大）</td></tr></tbody></table><p><code>&lt;listener-container/&gt;</code>元素也有几个可选的属性。 这些属性允许像 基本的 JMS设置和资源引用一样来定义不同的策略 （例如 taskExecutor 和 destinationResolver）。 使用这些属性，可以定义很广泛的定制监听器容器，同时仍享有命名空间的便利。</p><p>这样的设置可以自动公开一个 JmsListenerContainerFactory</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jms:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"myConnectionFactory"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">task-executor</span>=<span class="string">"myTaskExecutor"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">destination-resolver</span>=<span class="string">"myDestinationResolver"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">transaction-manager</span>=<span class="string">"myTransactionManager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">concurrency</span>=<span class="string">"10"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jms:listener</span> <span class="attr">destination</span>=<span class="string">"queue.orders"</span> <span class="attr">ref</span>=<span class="string">"orderService"</span> <span class="attr">method</span>=<span class="string">"placeOrder"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jms:listener</span> <span class="attr">destination</span>=<span class="string">"queue.confirmations"</span> <span class="attr">ref</span>=<span class="string">"confirmationLogger"</span> <span class="attr">method</span>=<span class="string">"log"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">jms:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面的表格描述了所有可用的属性。参考 AbstractMessageListenerContainer 类和具体子类的Javadoc来了解每个属性的细节。这部分的Javadoc也提高那个了事务选择和消息传输场景的讨论。</p><p><strong>表24.2 JMS &lt; listener-container &gt;元素的属性</strong> </p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">container-type</td><td align="left">监听器容器的类型。可用的选项是： default、simple、default102 或者 simple102 （默认值是 ‘default’）。</td></tr><tr><td align="left">container-class</td><td align="left">定制监听器容器实现类的完全限定类名。默认是Spring标准使用DefaultMessageListenerContainer或SimpleMessageListenerContainer</td></tr><tr><td align="left">factory-id</td><td align="left">公开此元素被定义为一个JmsListenerContainerFactory与指定id，以便它们可以与其他的端点被重新使用的设置。</td></tr><tr><td align="left">connection-factory</td><td align="left">JMS ConnectionFactory Bean的引用（默认的Bean名称是 ‘connectionFactory’）。</td></tr><tr><td align="left">task-executor</td><td align="left">JMS监听器调用者Spring TaskExecutor 的引用。</td></tr><tr><td align="left">destination-resolver</td><td align="left">DestinationResolver 策略的引用，用以解析JMS Destinations。</td></tr><tr><td align="left">message-converter</td><td align="left">MessageConverter 策略的引用，用以转换JMS Messages 成监听器方法的参数。默认值是 SimpleMessageConverter。</td></tr><tr><td align="left">error-handler</td><td align="left">异常处理的策略</td></tr><tr><td align="left">destination-type</td><td align="left">监听器的JMS目的地类型。可用的选项包含： queue、topic 或者 durableTopic （默认值是 ‘queue’）。</td></tr><tr><td align="left">client-id</td><td align="left">这个监听器容器在JMS客户端的id。</td></tr><tr><td align="left">cache</td><td align="left">The cache level for JMS resources:<code>none</code>,<code>connection</code>,<code>session</code>,<code>consumer</code> or<code>auto</code>. By default (<code>auto</code>), the cache level will effectively be “consumer”, unless an external transaction manager has been specified - in which case the effective default will be<code>none</code> (assuming Java EE-style transaction management where the given ConnectionFactory is an XA-aware pool).</td></tr><tr><td align="left">acknowledge</td><td align="left">本地JMS应答模式。可用的选项包含： auto、client、dups-ok 或者 transacted （默认值是 ‘auto’）。 ‘transacted’ 的值可激活本地事务性 Session。 也可以通过指定下面介绍的 transaction-manager 属性。</td></tr><tr><td align="left">transaction-manager</td><td align="left">Spring PlatformTransactionManager 的引用。</td></tr><tr><td align="left">concurrency</td><td align="left">每个监听器可激活的Session最大并发数。</td></tr><tr><td align="left">prefetch</td><td align="left">加载进每个Session的最大消息数。记住增加这个值会造成并发空闲。</td></tr><tr><td align="left">receive-timeout</td><td align="left">接受消息的超时时间，单位是毫秒，默认是1000，-1表示没超时</td></tr><tr><td align="left">back-off</td><td align="left">发生冲突时的强制性重传延迟，如果 BackOffExecution 实现返回 <code>BackOffExecution #STOP</code> , 侦听器容器不会进一步尝试恢复，设置的recovery-interval 值将被忽略。默认是一个 FixedBackOff 与 5000毫秒的时间间隔</td></tr><tr><td align="left">recovery-interval</td><td align="left">指定时间间隔恢复的尝试,以毫秒为单位。 方便 方法创建一个 FixedBackOff 指定的时间间隔。 更多的复苏 选项,可以考虑指定一个<code>back-off</code>的实例。 默认值是5000毫秒。</td></tr><tr><td align="left">phase</td><td align="left">这个容器的生命周期阶段应该启动和停止。越低值在这个容器将开始和后来将停止。默认值是Integer.MAX_VALUE 这意味着容器尽可能晚地将开始和停止快越好。</td></tr></tbody></table><p>使用“jms” Schema支持来配置基于JCA的监听器容器很相似</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jms:jca-listener-container</span> <span class="attr">resource-adapter</span>=<span class="string">"myResourceAdapter"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">destination-resolver</span>=<span class="string">"myDestinationResolver"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">transaction-manager</span>=<span class="string">"myTransactionManager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">concurrency</span>=<span class="string">"10"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jms:listener</span> <span class="attr">destination</span>=<span class="string">"queue.orders"</span> <span class="attr">ref</span>=<span class="string">"myMessageListener"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">jms:jca-listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>表24.3 JMS &lt; jca-listener-container / &gt;元素的属性</strong></p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">factory-id</td><td align="left">公开此元素被定义为一个JmsListenerContainerFactory与指定id，以便它们可以与其他的端点被重新使用的设置。</td></tr><tr><td align="left">resource-adapter</td><td align="left">JCA ResourceAdapter Bean 的一个引用（默认的Bean名称是’resourceAdapter’）</td></tr><tr><td align="left">activation-spec-factory</td><td align="left">JmsActivationSpecFactory 的一个引用。 默认自动检测JMS提供者和它的 ActivationSpec 类 （参考 DefaultJmsActivationSpecFactory）</td></tr><tr><td align="left">destination-resolver</td><td align="left">DestinationResolver 策略的引用，用以解析JMS Destinations。</td></tr><tr><td align="left">message-converter</td><td align="left">MessageConverter 策略的引用，用以转换JMS Messages 成监听器方法参数。 默认值是 SimpleMessageConverter</td></tr><tr><td align="left">destination-type</td><td align="left">监听器的JMS目的地类型。可用的选项包含 queue、topic 或者 durableTopic 默认是 ‘queue’）。</td></tr><tr><td align="left">client-id</td><td align="left">这个监听器容器在JMS客户端的id。</td></tr><tr><td align="left">acknowledge</td><td align="left">本地JMS应答模式。可用的选项包含：auto、client、dups-ok 或者 transacted （默认值是 ‘auto’）。 ‘transacted’ 的值可激活本地事务性 Session。 也可以通过指定下面介绍的 transaction-manager 属性</td></tr><tr><td align="left">transaction-manager</td><td align="left">Spring JtaTransactionManager 或者 javax.transaction.TransactionManager 的引用，用以为传进的消息应用XA事务。 如果没有指定，将使用本地应答模型（参见“acknowledge”属性）。</td></tr><tr><td align="left">concurrency</td><td align="left">每个监听器可激活的Session最大并发数。</td></tr><tr><td align="left">prefetch</td><td align="left">加载进每个Session的最大消息数。记住增加这个值会造成并发空闲。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;24-1介绍&quot;&gt;&lt;a href=&quot;#24-1介绍&quot; class=&quot;headerlink&quot; title=&quot;24.1介绍&quot;&gt;&lt;/a&gt;24.1介绍&lt;/h2&gt;&lt;p&gt;Spring提供了JMS集成框架简化了JMS API的使用，像Spring JDBC API的使用。&lt;/p&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://liuxing.info/tags/Spring/"/>
    
      <category term="JMS" scheme="http://liuxing.info/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cache使用</title>
    <link href="http://liuxing.info/2015/06/18/Spring%20Cache%E4%BD%BF%E7%94%A8"/>
    <id>http://liuxing.info/2015/06/18/Spring Cache使用</id>
    <published>2015-06-17T16:27:00.000Z</published>
    <updated>2019-07-02T01:06:43.325Z</updated>
    
    <content type="html"><![CDATA[<p><em>记录下自己项目在用的Spring Cache的使用方式。</em><br><em>Spring的抽象已经做得够好了，适合于大多数场景，非常复杂的就需要自己AOP实现了。</em><br><em>Spring官网的文档挺不错的，但是对Cache这块的介绍不是很详细，结合网上大牛的博文，汇总下文。</em></p><h2 id="缓存概念"><a href="#缓存概念" class="headerlink" title="缓存概念"></a>缓存概念</h2><blockquote><h3 id="缓存简介"><a href="#缓存简介" class="headerlink" title="缓存简介"></a>缓存简介</h3><p>缓存，我的理解是：让数据更接近于使用者；工作机制是：先从缓存中读取数据，如果没有再从慢速设备上读取实际数据（数据也会存入缓存）；缓存什么：那些经常读取且不经常修改的数据/那些昂贵（CPU/IO）的且对于相同的请求有相同的计算结果的数据。如CPU–L1/L2–内存–磁盘就是一个典型的例子，CPU需要数据时先从L1/L2中读取，如果没有到内存中找，如果还没有会到磁盘上找。还有如用过Maven的朋友都应该知道，我们找依赖的时候，先从本机仓库找，再从本地服务器仓库找，最后到远程仓库服务器找；还有如京东的物流为什么那么快？他们在各个地都有分仓库，如果该仓库有货物那么送货的速度是非常快的。</p><h3 id="缓存命中率"><a href="#缓存命中率" class="headerlink" title="缓存命中率"></a>缓存命中率</h3><p>即从缓存中读取数据的次数 与 总读取次数的比率，命中率越高越好：<br>命中率 = 从缓存中读取次数 / (总读取次数[从缓存中读取次数 + 从慢速设备上读取的次数])<br>Miss率 = 没有从缓存中读取的次数 / (总读取次数[从缓存中读取次数 + 从慢速设备上读取的次数])</p><p>这是一个非常重要的监控指标，如果做缓存一定要健康这个指标来看缓存是否工作良好；</p><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><h4 id="Eviction-policy"><a href="#Eviction-policy" class="headerlink" title="Eviction policy"></a>Eviction policy</h4><p>移除策略，即如果缓存满了，从缓存中移除数据的策略；常见的有LFU、LRU、FIFO：</p><ul><li>FIFO（First In First Out）：先进先出算法，即先放入缓存的先被移除；</li><li>LRU（Least Recently Used）：最久未使用算法，使用时间距离现在最久的那个被移除；</li><li>LFU（Least Frequently Used）：最近最少使用算法，一定时间段内使用次数（频率）最少的那个被移除；</li></ul><h4 id="TTL（Time-To-Live-）"><a href="#TTL（Time-To-Live-）" class="headerlink" title="TTL（Time To Live ）"></a>TTL（Time To Live ）</h4><p>存活期，即从缓存中创建时间点开始直到它到期的一个时间段（不管在这个时间段内有没有访问都将过期）</p><h4 id="TTI（Time-To-Idle）"><a href="#TTI（Time-To-Idle）" class="headerlink" title="TTI（Time To Idle）"></a>TTI（Time To Idle）</h4><p>空闲期，即一个数据多久没被访问将从缓存中移除的时间。</p><p>到此，基本了解了缓存的知识，在Java中，我们一般对调用方法进行缓存控制，比如我调用”findUserById(Long id)”，那么我应该在调用这个方法之前先从缓存中查找有没有，如果没有再掉该方法如从数据库加载用户，然后添加到缓存中，下次调用时将会从缓存中获取到数据。</p><p>自Spring 3.1起，提供了类似于@Transactional注解事务的注解Cache支持，且提供了Cache抽象；在此之前一般通过AOP实现；使用Spring Cache的好处：</p><ul><li>提供基本的Cache抽象，方便切换各种底层Cache；</li><li>通过注解Cache可以实现类似于事务一样，缓存逻辑透明的应用到我们的业务代码上，且只需要更少的代码就可以完成；</li><li>提供事务回滚时也自动回滚缓存；</li><li>支持比较复杂的缓存逻辑；</li></ul><p>对于Spring Cache抽象，主要从以下几个方面学习：</p><ul><li>Cache API及默认提供的实现</li><li>Cache注解</li><li>实现复杂的Cache逻辑</li></ul><footer><strong>缓存简介</strong><cite><a href="http://jinnianshilongnian.iteye.com/blog/2001040" target="_blank" rel="noopener">开涛的博客</a></cite></footer></blockquote><h2 id="Spring-Cache简介"><a href="#Spring-Cache简介" class="headerlink" title="Spring Cache简介"></a>Spring Cache简介</h2><blockquote><p>Spring3.1开始引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如EHCache 或者 OSCache），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。</p><p>Spring的缓存技术还具备相当的灵活性，不仅能够使用 SpEL（Spring Expression Language）来定义缓存的key和各种condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存例如EHCache、memcached集成。</p><p>其特点总结如下：</p><ul><li>通过少量的配置 annotation 注释即可使得既有代码支持缓存</li><li>支持开箱即用 Out-Of-The-Box，即不用安装和部署额外第三方组件即可使用缓存</li><li>支持 Spring Express Language，能使用对象的任何属性或者方法来定义缓存的 key 和 condition</li><li>支持 AspectJ，并通过其实现任何方法的缓存支持</li><li>支持自定义 key 和自定义缓存管理者，具有相当的灵活性和扩展性</li></ul><footer><strong>Spring Cache 介绍</strong><cite><a href="http://www.cnblogs.com/rollenholt/p/4202631.html" target="_blank" rel="noopener">Spring Cache 介绍 - Rollen Holt - 博客园</a></cite></footer></blockquote><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><h3 id="Cache接口"><a href="#Cache接口" class="headerlink" title="Cache接口"></a>Cache接口</h3><p><code>理解这个接口有助于我们实现自己的缓存管理器</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到底层使用的缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">getNativeCache</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key得到一个ValueWrapper，然后调用其get方法获取值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ValueWrapper <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key，和value的类型直接获取value  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Object key, Class&lt;T&gt; type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果值不存在，则添加，用来替代如下代码</span></span><br><span class="line"><span class="comment"> * Object existingValue = cache.get(key);</span></span><br><span class="line"><span class="comment"> * if (existingValue == null) &#123;</span></span><br><span class="line"><span class="comment"> *     cache.put(key, value);</span></span><br><span class="line"><span class="comment"> *     return null;</span></span><br><span class="line"><span class="comment"> * &#125; else &#123;</span></span><br><span class="line"><span class="comment"> *     return existingValue;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ValueWrapper <span class="title">putIfAbsent</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key删数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evict</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存值的Wrapper  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ValueWrapper</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h4><p>默认已经实现了几个常用的cache<br>位于spring-context-x.RELEASE.jar和spring-context-support-x.RELEASE.jar的cache目录下</p><ul><li>ConcurrentMapCache：基于java.util.concurrent.ConcurrentHashMap</li><li>GuavaCache：基于Google的Guava工具</li><li>EhCacheCache：基于Ehcache</li><li>JCacheCache：基于javax.cache.Cache（不常用）</li></ul><h3 id="CacheManager"><a href="#CacheManager" class="headerlink" title="CacheManager"></a>CacheManager</h3><p><code>用来管理多个cache</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据cache名获取cache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Cache <span class="title">getCache</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到所有cache的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Collection&lt;String&gt; <span class="title">getCacheNames</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="默认实现-1"><a href="#默认实现-1" class="headerlink" title="默认实现"></a>默认实现</h4><p>对应Cache接口的默认实现</p><ul><li>ConcurrentMapCacheManager / ConcurrentMapCacheFactoryBean</li><li>GuavaCacheManager</li><li>EhCacheCacheManager / EhCacheManagerFactoryBean</li><li>JCacheCacheManager / JCacheManagerFactoryBean</li></ul><h3 id="CompositeCacheManager"><a href="#CompositeCacheManager" class="headerlink" title="CompositeCacheManager"></a>CompositeCacheManager</h3><p>用于组合CacheManager，可以从多个CacheManager中轮询得到相应的Cache</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.support.CompositeCacheManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManagers"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"concurrentMapCacheManager"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"guavaCacheManager"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 都找不到时，不返回null，而是返回NOP的Cache --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fallbackToNoOpCache"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>除GuavaCacheManager外，其他Cache都支持Spring事务，如果注解方法出现事务回滚，对应缓存操作也会回滚</p><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>都是Cache自行维护，Spring只提供对外抽象API</p><h2 id="Cache注解"><a href="#Cache注解" class="headerlink" title="Cache注解"></a>Cache注解</h2><p>每个注解都有多个参数，这里不一一列出，建议进入源码查看注释</p><h3 id="启用注解"><a href="#启用注解" class="headerlink" title="启用注解"></a>启用注解</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache:annotation-driven</span> <span class="attr">cache-manager</span>=<span class="string">"cacheManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h3><p>写数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CachePut</span>(value = <span class="string">"addPotentialNoticeCache"</span>, key = <span class="string">"targetClass + '.' + #userCode"</span>)</span><br><span class="line"><span class="keyword">public</span> List&lt;PublicAutoAddPotentialJob.AutoAddPotentialNotice&gt; put(<span class="keyword">int</span> userCode, List&lt;PublicAutoAddPotentialJob.AutoAddPotentialNotice&gt; noticeList) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">"缓存（&#123;&#125;）的公客自动添加潜在客的通知"</span>, userCode);</span><br><span class="line">    <span class="keyword">return</span> noticeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h3><p>失效数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheEvict</span>(value = <span class="string">"addPotentialNoticeCache"</span>, key = <span class="string">"targetClass + '.' + #userCode"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> userCode)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"清除（&#123;&#125;）的公客自动添加潜在客的通知"</span>, userCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h3><p>这个用的比较多<br>用在查询方法上，先从缓存中读取，如果没有再调用方法获取数据，然后把数据添加到缓存中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value = <span class="string">"kyAreaCache"</span>, key=<span class="string">"targetClass + '.' + methodName + '.' + #areaId"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> KyArea <span class="title">findById</span><span class="params">(String areaId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><ol><li>首先执行@CacheEvict（如果beforeInvocation=true且condition 通过），如果allEntries=true，则清空所有</li><li>接着收集@Cacheable（如果condition 通过，且key对应的数据不在缓存），放入cachePutRequests（也就是说如果cachePutRequests为空，则数据在缓存中）</li><li>如果cachePutRequests为空且没有@CachePut操作，那么将查找@Cacheable的缓存，否则result=缓存数据（也就是说只要当没有cache put请求时才会查找缓存）</li><li>如果没有找到缓存，那么调用实际的API，把结果放入result</li><li>如果有@CachePut操作(如果condition 通过)，那么放入cachePutRequests</li><li>执行cachePutRequests，将数据写入缓存（unless为空或者unless解析结果为false）；</li><li>执行@CacheEvict（如果beforeInvocation=false 且 condition 通过），如果allEntries=true，则清空所有</li></ol><h3 id="SpEL上下文数据"><a href="#SpEL上下文数据" class="headerlink" title="SpEL上下文数据"></a>SpEL上下文数据</h3><p>在使用时，#root.methodName 等同于 methodName</p><table><thead><tr><th align="left">名称</th><th align="left">位置</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">methodName</td><td align="left">root对象</td><td align="left">当前被调用的方法名</td><td align="left">#root.methodName</td></tr><tr><td align="left">method</td><td align="left">root对象</td><td align="left">当前被调用的方法</td><td align="left">#root.method.name</td></tr><tr><td align="left">target</td><td align="left">root对象</td><td align="left">当前被调用的目标对象</td><td align="left">#root.target</td></tr><tr><td align="left">targetClass</td><td align="left">root对象</td><td align="left">当前被调用的目标对象类</td><td align="left">#root.targetClass</td></tr><tr><td align="left">args</td><td align="left">root对象</td><td align="left">当前被调用的方法的参数列表</td><td align="left">#root.args[0]</td></tr><tr><td align="left">caches</td><td align="left">root对象</td><td align="left">当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个cache</td><td align="left">#root.caches[0].name</td></tr><tr><td align="left">argument name</td><td align="left">执行上下文</td><td align="left">当前被调用的方法的参数，如findById(Long id)，我们可以通过#id拿到参数</td><td align="left">#user.id</td></tr><tr><td align="left">result</td><td align="left">执行上下文</td><td align="left">方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache evict’的beforeInvocation=false）</td><td align="left">#result</td></tr></tbody></table><h3 id="条件缓存"><a href="#条件缓存" class="headerlink" title="条件缓存"></a>条件缓存</h3><p>主要是在注解内用condition和unless的表达式分别对参数和返回结果进行筛选后缓存</p><h3 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h3><p>多个缓存注解组合使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Caching</span>(</span><br><span class="line">        put = &#123;</span><br><span class="line">                <span class="meta">@CachePut</span>(value = <span class="string">"user"</span>, key = <span class="string">"#user.id"</span>),</span><br><span class="line">                <span class="meta">@CachePut</span>(value = <span class="string">"user"</span>, key = <span class="string">"#user.username"</span>),</span><br><span class="line">                <span class="meta">@CachePut</span>(value = <span class="string">"user"</span>, key = <span class="string">"#user.email"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义缓存注解"><a href="#自定义缓存注解" class="headerlink" title="自定义缓存注解"></a>自定义缓存注解</h3><p>把一些特殊场景的注解包装到一个独立的注解中，比如@Caching组合使用的注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Caching</span>(</span><br><span class="line">        put = &#123;</span><br><span class="line">                <span class="meta">@CachePut</span>(value = <span class="string">"user"</span>, key = <span class="string">"#user.id"</span>),</span><br><span class="line">                <span class="meta">@CachePut</span>(value = <span class="string">"user"</span>, key = <span class="string">"#user.username"</span>),</span><br><span class="line">                <span class="meta">@CachePut</span>(value = <span class="string">"user"</span>, key = <span class="string">"#user.email"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UserSaveCache &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UserSaveCache</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="基于ConcurrentMapCache"><a href="#基于ConcurrentMapCache" class="headerlink" title="基于ConcurrentMapCache"></a>基于ConcurrentMapCache</h3><h4 id="自定义CacheManager"><a href="#自定义CacheManager" class="headerlink" title="自定义CacheManager"></a>自定义CacheManager</h4><p>我需要使用有容量限制和缓存失效时间策略的Cache，默认的ConcurrentMapCacheManager没法满足<br>通过实现CacheManager接口定制出自己的CacheManager。<br>还是拷贝ConcurrentMapCacheManager，使用Guava的Cache做底层容器，因为Guava的Cache容器可以设置缓存策略</p><p><code>新增了exp、maximumSize两个策略变量</code><br><code>修改底层Cache容器的创建</code></p><p>下面只列出自定义的代码，其他的都是Spring的ConcurrentMapCacheManager的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.concurrent.ConcurrentMapCache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能说明：自定义的ConcurrentMapCacheManager，新增超时时间和最大存储限制</span></span><br><span class="line"><span class="comment"> * 作者：liuxing(2015-04-13 18:44)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentMapCacheManager</span> <span class="keyword">implements</span> <span class="title">CacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间，秒（自定义）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> exp = <span class="number">1800</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大存储数量 （自定义）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maximumSize = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExp</span><span class="params">(<span class="keyword">long</span> exp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exp = exp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaximumSize</span><span class="params">(<span class="keyword">long</span> maximumSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maximumSize = maximumSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个缓存容器，这个方法改写为使用Guava的Cache</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Cache <span class="title">createConcurrentMapCache</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentMapCache(name, CacheBuilder.newBuilder().expireAfterWrite(<span class="keyword">this</span>.exp, TimeUnit.SECONDS)</span><br><span class="line">                                                                     .maximumSize(<span class="keyword">this</span>.maximumSize)</span><br><span class="line">                                                                     .build()</span><br><span class="line">                                                                     .asMap(), isAllowNullValues());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>xml风格</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 启用缓存注解功能，这个是必须的，否则注解不会生效，指定一个默认的Manager，否则需要在注解使用时指定Manager --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache:annotation-driven</span> <span class="attr">cache-manager</span>=<span class="string">"memoryCacheManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 本地内存缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"memoryCacheManager"</span> <span class="attr">class</span>=<span class="string">"com.dooioo.ky.cache.ConcurrentMapCacheManager"</span> <span class="attr">p:maximumSize</span>=<span class="string">"2000"</span> <span class="attr">p:exp</span>=<span class="string">"1800"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheNames"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>kyMemoryCache<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value = <span class="string">"kyMemoryCache"</span>, key=<span class="string">"targetClass + '.' + methodName"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">queryMobiles</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 业务代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Memcached"><a href="#使用Memcached" class="headerlink" title="使用Memcached"></a>使用Memcached</h3><p>一般常用的缓存当属memcached了，这个就需要自己实现CacheManager和Cache<br>注意我实现的Cache里面有做一些定制化操作，比如对key的处理</p><h4 id="创建MemcachedCache"><a href="#创建MemcachedCache" class="headerlink" title="创建MemcachedCache"></a>创建MemcachedCache</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.dooioo.common.jstl.DyFunctions;</span><br><span class="line"><span class="keyword">import</span> com.dooioo.commons.Strings;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Joiner;</span><br><span class="line"><span class="keyword">import</span> net.rubyeye.xmemcached.MemcachedClient;</span><br><span class="line"><span class="keyword">import</span> net.rubyeye.xmemcached.exception.MemcachedException;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.support.SimpleValueWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能说明：自定义spring的cache的实现，参考cache包实现</span></span><br><span class="line"><span class="comment"> * 作者：liuxing(2015-04-12 13:57)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemcachedCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MemcachedCache.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的别名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * memcached客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> MemcachedClient client;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存过期时间，默认是1小时</span></span><br><span class="line"><span class="comment">     * 自定义的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> exp = <span class="number">3600</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否对key进行base64加密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> base64Key = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前缀名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNativeCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ValueWrapper <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object = <span class="keyword">this</span>.client.get(handleKey(objectToString(key)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MemcachedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (object != <span class="keyword">null</span> ? <span class="keyword">new</span> SimpleValueWrapper(object) : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Object key, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object object = <span class="keyword">this</span>.client.get(handleKey(objectToString(key)));</span><br><span class="line">            <span class="keyword">return</span> (T) object;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MemcachedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//            this.evict(key);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.set(handleKey(objectToString(key)), exp, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MemcachedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ValueWrapper <span class="title">putIfAbsent</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.delete(handleKey(objectToString(key)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MemcachedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.flushAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MemcachedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MemcachedClient <span class="title">getClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClient</span><span class="params">(MemcachedClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExp</span><span class="params">(<span class="keyword">int</span> exp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exp = exp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBase64Key</span><span class="params">(<span class="keyword">boolean</span> base64Key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.base64Key = base64Key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">handleKey</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (base64Key) &#123;</span><br><span class="line">            <span class="keyword">return</span> Joiner.on(EMPTY_SEPARATOR).skipNulls().join(<span class="keyword">this</span>.prefix, DyFunctions.base64Encode(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Joiner.on(EMPTY_SEPARATOR).skipNulls().join(<span class="keyword">this</span>.prefix, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换key，去掉空格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">objectToString</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> Strings.replace((String) object, <span class="string">" "</span>, <span class="string">"_"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> object.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EMPTY_SEPARATOR = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建MemcachedCacheManager"><a href="#创建MemcachedCacheManager" class="headerlink" title="创建MemcachedCacheManager"></a>创建MemcachedCacheManager</h4><p>继承AbstractCacheManager</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.support.AbstractCacheManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能说明：memcachedCacheManager</span></span><br><span class="line"><span class="comment"> * 作者：liuxing(2015-04-12 15:13)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemcachedCacheManager</span> <span class="keyword">extends</span> <span class="title">AbstractCacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;Cache&gt; caches;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Collection&lt;? extends Cache&gt; loadCaches() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.caches;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCaches</span><span class="params">(Collection&lt;Cache&gt; caches)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.caches = caches;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cache <span class="title">getCache</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getCache(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 启用缓存注解功能，这个是必须的，否则注解不会生效，指定一个默认的Manager，否则需要在注解使用时指定Manager --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache:annotation-driven</span> <span class="attr">cache-manager</span>=<span class="string">"cacheManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- memcached缓存管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"com.dooioo.ky.cache.MemcachedCacheManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"caches"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.dooioo.ky.cache.MemcachedCache"</span> <span class="attr">p:client-ref</span>=<span class="string">"ky.memcachedClient"</span> <span class="attr">p:name</span>=<span class="string">"kyAreaCache"</span> <span class="attr">p:exp</span>=<span class="string">"86400"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.dooioo.ky.cache.MemcachedCache"</span> <span class="attr">p:client-ref</span>=<span class="string">"ky.memcachedClient"</span> <span class="attr">p:name</span>=<span class="string">"kyOrganizationCache"</span> <span class="attr">p:exp</span>=<span class="string">"3600"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value = <span class="string">"kyAreaCache"</span>, key=<span class="string">"targetClass + '.' + methodName + '.' + #areaId"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> KyArea <span class="title">findById</span><span class="params">(String areaId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>更多复杂的使用场景和注解语法请自行谷歌！</p><p><strong>参考</strong><br><a href="http://docs.spring.io/spring/docs/4.1.x/spring-framework-reference/html/cache.html" target="_blank" rel="noopener">http://docs.spring.io/spring/docs/4.1.x/spring-framework-reference/html/cache.html</a></p><p><a href="http://www.cnblogs.com/rollenholt/p/4202631.html" target="_blank" rel="noopener">http://www.cnblogs.com/rollenholt/p/4202631.html</a></p><p><a href="http://jinnianshilongnian.iteye.com/blog/2001040" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/2001040</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;记录下自己项目在用的Spring Cache的使用方式。&lt;/em&gt;&lt;br&gt;&lt;em&gt;Spring的抽象已经做得够好了，适合于大多数场景，非常复杂的就需要自己AOP实现了。&lt;/em&gt;&lt;br&gt;&lt;em&gt;Spring官网的文档挺不错的，但是对Cache这块的介绍不是很详细，结
      
    
    </summary>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://liuxing.info/tags/Spring/"/>
    
      <category term="Cache" scheme="http://liuxing.info/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Linux统计内存块</title>
    <link href="http://liuxing.info/2015/06/17/linux%E7%BB%9F%E8%AE%A1%E5%86%85%E5%AD%98%E5%9D%97"/>
    <id>http://liuxing.info/2015/06/17/linux统计内存块</id>
    <published>2015-06-16T17:02:00.000Z</published>
    <updated>2019-07-02T01:06:43.327Z</updated>
    
    <content type="html"><![CDATA[<p><em>纯粹备忘</em></p><h2 id="统计内存块"><a href="#统计内存块" class="headerlink" title="统计内存块"></a>统计内存块</h2><p>pmap -x $pid | awk ‘{ if($3 &gt; 64000 &amp;&amp; $3 &lt; 65537) count++ } END { print count }’</p><h2 id="导出内存块明细"><a href="#导出内存块明细" class="headerlink" title="导出内存块明细"></a>导出内存块明细</h2><p>pmap -x $pid &gt; pmap.log</p><h2 id="导出核心进程内存"><a href="#导出核心进程内存" class="headerlink" title="导出核心进程内存"></a>导出核心进程内存</h2><p>sudo gdb -q –pid=4990</p><p>–pid后面跟着的是jvm的进程id<br>(gdb) generate-core-file </p><p>这里调用命令生成gcore的dump文件<br>(gdb) detach </p><p>detach是用来断开与jvm的连接的<br>(gdb) quit</p><p>指定内存块：<br>内存地址从pmap结果中查询<br> dump memory memory.bin 0x0007f5f38000000 0x0007f5f394af000</p><p>导出核心进程内存（正式库数据太大不建议）<br>gdb –pid $pid<br>gcore   [文件名]    #   产生core dump文件</p><p><a href="http://blog.chinaunix.net/uid-24020646-id-2419921.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-24020646-id-2419921.html</a></p><h2 id="核心进程内存转换为heap-dump"><a href="#核心进程内存转换为heap-dump" class="headerlink" title="核心进程内存转换为heap dump"></a>核心进程内存转换为heap dump</h2><p>$JAVA_HOME/bin/jmap -dump:format=b,file=heap.hprof $JAVA_HOME/bin/java core.63278<br>/usr/java/jdk1.8.0_40/bin/jmap -dump:format=b,file=heap.hprof /usr/java/jdk1.8.0_40/bin/java memory.bin<br>/usr/local/java/jdk1.8.0_20/bin/jmap -dump:format=b,file=heap.hprof /usr/local/java/jdk1.8.0_20/bin/java memory.bin<br><a href="http://itindex.net/detail/50907-jmap-gcore-dump" target="_blank" rel="noopener">http://itindex.net/detail/50907-jmap-gcore-dump</a></p><p><a href="http://www.ibm.com/developerworks/cn/java/j-memoryanalyzer/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/java/j-memoryanalyzer/</a></p><h2 id="导入本地使用MAT工具分析"><a href="#导入本地使用MAT工具分析" class="headerlink" title="导入本地使用MAT工具分析"></a>导入本地使用MAT工具分析</h2><h2 id="使用libtcmalloc优化linux内存管理"><a href="#使用libtcmalloc优化linux内存管理" class="headerlink" title="使用libtcmalloc优化linux内存管理"></a>使用libtcmalloc优化linux内存管理</h2><p>gperftools+libunwind</p><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><p>find / -name “libunwind*” </p><p>jhat -J-Xmx1024M heap.hprof </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;纯粹备忘&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;统计内存块&quot;&gt;&lt;a href=&quot;#统计内存块&quot; class=&quot;headerlink&quot; title=&quot;统计内存块&quot;&gt;&lt;/a&gt;统计内存块&lt;/h2&gt;&lt;p&gt;pmap -x $pid | awk ‘{ if($3 &amp;gt; 6400
      
    
    </summary>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="linux" scheme="http://liuxing.info/tags/linux/"/>
    
      <category term="Java" scheme="http://liuxing.info/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat的APR优化</title>
    <link href="http://liuxing.info/2015/06/17/Tomcat%E7%9A%84APR%E4%BC%98%E5%8C%96"/>
    <id>http://liuxing.info/2015/06/17/Tomcat的APR优化</id>
    <published>2015-06-16T16:53:00.000Z</published>
    <updated>2019-07-02T01:06:43.326Z</updated>
    
    <content type="html"><![CDATA[<p><em>什么是APR？</em></p><blockquote><p>Tomcat可以使用APR来提供超强的可伸缩性和性能，更好地集成本地服务器技术。</p><p>APR(Apache Portable Runtime)是一个高可移植库，它是Apache HTTP Server 2.x的核心。</p><p>APR有很多用途，包括访问高级IO功能(例如sendfile,epoll和OpenSSL)，OS级别功能(随机数生成，系统状态等等)，本地进程管理(共享内存，NT管道和UNIX sockets)。这些功能可以使Tomcat作为一个通常的前台WEB服务器，能更好地和其它本地web技术集成，总体上让Java更有效率作为一个高性能web服务器平台而不是简单作为后台容器。</p><p>在产品环境中，特别是直接使用Tomcat做WEB服务器的时候，应该使用Tomcat Native来提高其性能。</p><footer><strong>Apache Portable Runtime</strong><cite><a href="http://apr.apache.org/" target="_blank" rel="noopener">Welcome! - the Apache Portable Runtime Project</a></cite></footer></blockquote><h2 id="安装apr"><a href="#安装apr" class="headerlink" title="安装apr"></a>安装apr</h2><p>yum install -y apr-devel openssl-devel gcc</p><p>查看安装目录<br>rpm -ql apr-devel<br>rpm -ql openssl-devel</p><p>apr目录：/usr/bin/apr-1-config</p><h2 id="安装native"><a href="#安装native" class="headerlink" title="安装native"></a>安装native</h2><p>拷贝：tomcat/bin目录下的tomcat-native.tar.gz到某个位置<br>解压：tar zxvf tomcat-native.tar.gz</p><pre><code>cd  tomcat-native-1.1.32-src/jni/native/./configure --with-apr=/usr/bin/apr-1-config --with-java-home=$JAVA_HOME ./configure --with-apr=/usr/local/apache2/ --with-java-home=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home --with-ssl=yes</code></pre><p>可选：</p><pre><code>--with-ssl=yesmake &amp; make install</code></pre><h2 id="配置tomcat"><a href="#配置tomcat" class="headerlink" title="配置tomcat"></a>配置tomcat</h2><pre><code>vim catalina.shexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/apr/lib</code></pre><p>将tomcat/config/service.xml 的protocol 改为</p><pre><code>org.apache.coyote.http11.Http11AprProtocol</code></pre><h2 id="重启查看日志"><a href="#重启查看日志" class="headerlink" title="重启查看日志"></a>重启查看日志</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/kgdxpr/archive/2013/08/07/3243657.html" target="_blank" rel="noopener">http://www.cnblogs.com/kgdxpr/archive/2013/08/07/3243657.html</a></p><p><a href="http://blog.csdn.net/qingchn/article/details/7895851" target="_blank" rel="noopener">http://blog.csdn.net/qingchn/article/details/7895851</a></p><p><a href="http://tomcat.apache.org/native-doc/" target="_blank" rel="noopener">http://tomcat.apache.org/native-doc/</a></p><p><a href="http://neptune.iteye.com/blog/125101" target="_blank" rel="noopener">http://neptune.iteye.com/blog/125101</a></p><p><a href="http://www.cnblogs.com/chuncn/archive/2010/10/17/1853915.html" target="_blank" rel="noopener">http://www.cnblogs.com/chuncn/archive/2010/10/17/1853915.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;什么是APR？&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Tomcat可以使用APR来提供超强的可伸缩性和性能，更好地集成本地服务器技术。&lt;/p&gt;
&lt;p&gt;APR(Apache Portable Runtime)是一个高可移植库，它是Apache HTTP Se
      
    
    </summary>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="tomcat" scheme="http://liuxing.info/tags/tomcat/"/>
    
      <category term="APR" scheme="http://liuxing.info/tags/APR/"/>
    
  </entry>
  
  <entry>
    <title>使用Google-Perftools优化tomcat</title>
    <link href="http://liuxing.info/2015/06/17/%E4%BD%BF%E7%94%A8google-perftools%E4%BC%98%E5%8C%96tomcat"/>
    <id>http://liuxing.info/2015/06/17/使用google-perftools优化tomcat</id>
    <published>2015-06-16T16:41:00.000Z</published>
    <updated>2019-07-02T01:06:43.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个工具可让开发创建更强大的应用程序，特别是那些用C++模版开发的多线程应用程序，包括<a href="http://www.oschina.net/p/tcmalloc" target="_blank" rel="noopener">TCMalloc</a>, heap-checker, heap-profiler 和cpu-profiler。</p><footer><strong>开源中国社区</strong><cite><a href="http://www.oschina.net/p/perftools" target="_blank" rel="noopener">Google PerfTools首页、文档和下载</a></cite></footer></blockquote><h2 id="前置依赖"><a href="#前置依赖" class="headerlink" title="前置依赖"></a>前置依赖</h2><p>避免后续安装错误</p><pre><code>yum install -y gcc*yum install zlib* openssl* -y   </code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>切换到工作目录</p><pre><code>cd /usr/local/src 或 ~/src</code></pre><p>下载：</p><pre><code>wget http://download.savannah.gnu.org/releases/libunwind/libunwind-0.99-alpha.tar.gzwget http://googledrive.com/host/0B6NtGsLhIcf7MWxMMF9JdTN3UVk/gperftools-2.4.tar.gz</code></pre><p>1.针对 64 位操作系统必须安装 libunwind 库</p><pre><code>tar zxvf libunwind-1.1.tar.gzcd libunwind-1.1/CFLAGS=-fPIC ./configure --enable-shared --enable-frame-pointersmake CFLAGS=-fPICmake CFLAGS=-fPIC installcd ../</code></pre><p>查找：</p><pre><code>find /usr/ -name “libunwind*”</code></pre><p>卸载：</p><pre><code>make CFLAGS=-fPIC uninstall</code></pre><p>2.安装 google-perftools 优化</p><pre><code>tar zxvf gperftools-2.0.tar.gzcd gperftools-2.0/./configure --enable-shared --enable-frame-pointersmake &amp;&amp; make installecho &quot;/usr/local/lib&quot; &gt; /etc/ld.so.conf.d/usr_local_lib.conf/sbin/ldconfig</code></pre><p><code>有依赖没有安装?</code></p><pre><code>./configure --enable-shared --enable-frame-pointers  </code></pre><p><code>make check 依然报错？</code></p><p><a href="http://xkorey.iteye.com/blog/1648567" target="_blank" rel="noopener">http://xkorey.iteye.com/blog/1648567</a></p><p><code>./libtool: line 1125: g++: command not found</code></p><pre><code>yum install -y gcc* </code></pre><p>tomcat启动程序配置</p><pre><code>export LD_PRELOAD=/usr/local/lib/libtcmalloc.so</code></pre><p>查看是否生效</p><pre><code>/usr/sbin/lsof -n | grep tcmalloc</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://www.centos.bz/2012/01/google-perftools-speed-up-mysql-tcmalloc/" target="_blank" rel="noopener">https://www.centos.bz/2012/01/google-perftools-speed-up-mysql-tcmalloc/</a><br><a href="http://blog.sina.com.cn/s/blog_8d05143b01012b87.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_8d05143b01012b87.html</a><br><a href="http://xkorey.iteye.com/blog/1648567" target="_blank" rel="noopener">http://xkorey.iteye.com/blog/1648567</a><br><a href="http://shopwwi.com/thread-673-1-1.html" target="_blank" rel="noopener">http://shopwwi.com/thread-673-1-1.html</a><br><a href="http://blog.csdn.net/wind19/article/details/10381291" target="_blank" rel="noopener">http://blog.csdn.net/wind19/article/details/10381291</a></p><p><a href="http://blog.chinaunix.net/uid-20687780-id-3029851.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-20687780-id-3029851.html</a><br><a href="http://blog.hackroad.com/operations-engineer/linux_server/1285.html" target="_blank" rel="noopener">http://blog.hackroad.com/operations-engineer/linux_server/1285.html</a></p><h3 id="linux安装软件"><a href="#linux安装软件" class="headerlink" title="linux安装软件"></a>linux安装软件</h3><p><a href="http://www.cnblogs.com/chuncn/archive/2010/10/17/1853915.html" target="_blank" rel="noopener">http://www.cnblogs.com/chuncn/archive/2010/10/17/1853915.html</a></p><p><a href="http://www.educity.cn/wenda/353955.html" target="_blank" rel="noopener">http://www.educity.cn/wenda/353955.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;这个工具可让开发创建更强大的应用程序，特别是那些用C++模版开发的多线程应用程序，包括&lt;a href=&quot;http://www.oschina.net/p/tcmalloc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TCMallo
      
    
    </summary>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="tomcat" scheme="http://liuxing.info/tags/tomcat/"/>
    
      <category term="linux" scheme="http://liuxing.info/tags/linux/"/>
    
      <category term="perftools" scheme="http://liuxing.info/tags/perftools/"/>
    
  </entry>
  
  <entry>
    <title>MemAdmin管理Memcached</title>
    <link href="http://liuxing.info/2015/06/17/MemAdmin%E7%AE%A1%E7%90%86Memcached"/>
    <id>http://liuxing.info/2015/06/17/MemAdmin管理Memcached</id>
    <published>2015-06-16T16:24:00.000Z</published>
    <updated>2019-07-02T01:06:43.324Z</updated>
    
    <content type="html"><![CDATA[<p><em>MemAdmin是一款可视化的Memcached管理与监控工具，基于 PHP5 &amp; JQuery 开发，体积小，操作简单。</em></p><blockquote><p>主要功能：</p><ul><li>服务器参数监控：STATS、SETTINGS、ITEMS、SLABS、SIZES实时刷新</li><li>服务器性能监控：GET、DELETE、INCR、DECR、CAS等常用操作命中率实时监控</li><li>支持数据遍历，方便对存储内容进行监视</li><li>支持条件查询，筛选出满足条件的KEY或VALUE</li><li>数组、JSON等序列化字符反序列显示</li><li>兼容memcache协议的其他服务，如Tokyo Tyrant (遍历功能除外)</li><li>支持服务器连接池，多服务器管理切换方便简洁</li></ul><footer><strong>开源中国社区</strong><cite><a href="http://www.oschina.net/p/memadmin" target="_blank" rel="noopener">MemAdmin首页、文档和下载</a></cite></footer></blockquote><h2 id="查看依赖"><a href="#查看依赖" class="headerlink" title="查看依赖"></a>查看依赖</h2><h3 id="查看Apache版本"><a href="#查看Apache版本" class="headerlink" title="查看Apache版本"></a>查看Apache版本</h3><pre><code>apachectl -v</code></pre><h3 id="查看PHP环境"><a href="#查看PHP环境" class="headerlink" title="查看PHP环境"></a>查看PHP环境</h3><pre><code>php -v</code></pre><p><a href="http://nan1hao.blog.51cto.com/753570/602610/" target="_blank" rel="noopener">http://nan1hao.blog.51cto.com/753570/602610/</a></p><h2 id="安装Apache和PHP（如果没有的话）"><a href="#安装Apache和PHP（如果没有的话）" class="headerlink" title="安装Apache和PHP（如果没有的话）"></a>安装Apache和PHP（如果没有的话）</h2><p><a href="http://blog.csdn.net/czp11210/article/details/8750506" target="_blank" rel="noopener">http://blog.csdn.net/czp11210/article/details/8750506</a></p><h2 id="安装PHP的memcached扩展"><a href="#安装PHP的memcached扩展" class="headerlink" title="安装PHP的memcached扩展"></a>安装PHP的memcached扩展</h2><pre><code>RPM –ivh php-pear-1.9.4-4.el6.noarch.rpm RPM –ivh php-pecl-memcache-3.0.5-4.el6.x86_64.rpm</code></pre><p>或 <code>yum install</code> 安装</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>追加内容</p><pre><code>echo &quot;abcd&quot; &gt;&gt; a.txt #命令示例</code></pre><p>重启Apache </p><pre><code>service httpd restart</code></pre><p>找不到服务？<a href="http://blog.csdn.net/zwfcan/article/details/8231864" target="_blank" rel="noopener">http://blog.csdn.net/zwfcan/article/details/8231864</a></p><p>搜索Apache目录</p><pre><code>find / -name httpd.conf</code></pre><p>##安装memadmin<br>    tar –zxvf memadmin-1.0.12.tar.gz<br>    mv memadmin  /var/www/html</p><pre><code>vi /etc/httpd/conf/httpd.conf</code></pre><p>1.DocumentRoot “/var/www/html”<br>2.DirectoryIndex index.html index.html.var index.php<br>3.&lt;Directory “/var/www/html”&gt; …</p><p><em>很久没用了，还有些使用截图需要补上，待续…</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;MemAdmin是一款可视化的Memcached管理与监控工具，基于 PHP5 &amp;amp; JQuery 开发，体积小，操作简单。&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;主要功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器参数监控：STATS、SETTINGS、I
      
    
    </summary>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Memcached" scheme="http://liuxing.info/tags/Memcached/"/>
    
      <category term="MemAdmin" scheme="http://liuxing.info/tags/MemAdmin/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装jdk</title>
    <link href="http://liuxing.info/2015/06/17/linux%E5%AE%89%E8%A3%85jdk"/>
    <id>http://liuxing.info/2015/06/17/linux安装jdk</id>
    <published>2015-06-16T16:17:00.000Z</published>
    <updated>2019-07-02T01:06:43.327Z</updated>
    
    <content type="html"><![CDATA[<p><em>记录一下</em></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>cd /usr/local/java/ </code></pre><p>或</p><pre><code>cd /usr/java/tar -zxvf 文件名.tar.gz</code></pre><p>可以修改文件夹读写、所有者、所属组<br><a href="http://www.tuicool.com/articles/b6bimiz" target="_blank" rel="noopener">http://www.tuicool.com/articles/b6bimiz</a></p><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p>全局方式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0_40</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JRE_HOME</span>/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile <span class="comment">#使更改的配置立即生效</span></span><br></pre></td></tr></table></figure><p>用户环境变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/java/jdk1.8.0_40</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile <span class="comment">#使更改的配置生效</span></span><br><span class="line"></span><br><span class="line">java -version <span class="comment">#查看版本</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;记录一下&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;cd /usr/local/java/ &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或&lt;/p&gt;
      
    
    </summary>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="linux" scheme="http://liuxing.info/tags/linux/"/>
    
      <category term="jdk" scheme="http://liuxing.info/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>Wget下载jdk</title>
    <link href="http://liuxing.info/2015/06/17/wget%E4%B8%8B%E8%BD%BDjdk"/>
    <id>http://liuxing.info/2015/06/17/wget下载jdk</id>
    <published>2015-06-16T16:02:00.000Z</published>
    <updated>2019-07-02T01:06:43.328Z</updated>
    
    <content type="html"><![CDATA[<p><em>通常需要下载jdk时，直接用wget命令是不行的。那么，如何解决呢？</em><br><em>只需要在wget的时候加上一个特殊的cookie就可以搞定</em></p><p><strong>JDK 7</strong></p><pre><code>wget --no-cookies --no-check-certificate --header &quot;Cookie:gpw_e24=http%3a%2f%2fwww.oracle.com%2ftechnetwork%2fjava%2fjavase%2fdownloads%2fjdk7-downloads-1880260.html;oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/7u75-b13/jdk-7u75-linux-x64.tar.gz</code></pre><p><strong>JDK 8</strong></p><pre><code>wget --no-cookies --no-check-certificate --header &quot;Cookie:gpw_e24=http%3a%2f%2fwww.oracle.com%2ftechnetwork%2fjava%2fjavase%2fdownloads%2fjdk8-downloads-2133151.html;oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u40-b26/jdk-8u40-linux-x64.tar.gz</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;通常需要下载jdk时，直接用wget命令是不行的。那么，如何解决呢？&lt;/em&gt;&lt;br&gt;&lt;em&gt;只需要在wget的时候加上一个特殊的cookie就可以搞定&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK 7&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget -
      
    
    </summary>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="linux" scheme="http://liuxing.info/tags/linux/"/>
    
      <category term="wget" scheme="http://liuxing.info/tags/wget/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令备忘</title>
    <link href="http://liuxing.info/2015/06/16/linux%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98"/>
    <id>http://liuxing.info/2015/06/16/linux命令备忘</id>
    <published>2015-06-16T15:58:00.000Z</published>
    <updated>2019-07-02T01:06:43.327Z</updated>
    
    <content type="html"><![CDATA[<p><em>记录一下自己常用的linux命令</em></p><p>独立用户需要配置path,切换到根目录查看path</p><pre><code>vi .bash_profile</code></pre><p>重新给文件夹赋权限</p><pre><code>chown -R yishou apache-tomcat-7.0.47</code></pre><p>修改密码</p><pre><code>passwd yishou</code></pre><p>新增用户，会自动创建同名文件夹</p><pre><code>useradd loupan</code></pre><p>删除用户</p><pre><code>userdel keybox</code></pre><p>创建文件夹</p><pre><code>mkdir yishou</code></pre><p>防止环境配置修改之后不立即生效，退出重新登录也可以</p><pre><code>source .bash_profile</code></pre><p>根据名字查找进程</p><pre><code>ps -aux | grep estat</code></pre><p>关闭防火墙<br>    /etc/init.d/iptables stop</p><p>关闭开机启动</p><pre><code>chkconfig --level 2345 iptables off</code></pre><p>赋权限</p><pre><code>chmod 777 origimagesdisk</code></pre><p>MAC修改hosts</p><pre><code>sudo vi /etc/hosts</code></pre><p>查看文件夹使用情况</p><pre><code>du --max-depth=1 -h</code></pre><p>linux新建tomcat无法启动<br><code>Cannot find bin/catalina.sh</code><br><em>The file is absent or does not have execute permission</em><br><em>This file is needed to run this program</em></p><p>原因： 没有权限<br>解决 ： chmod 777 *.sh </p><p>添加开机启动</p><pre><code>vi /etc/rc.local</code></pre><p>jvisualvm</p><p>修改mac最大连接数，默认128</p><pre><code>sudo sysctl -w kern.ipc.somaxconn=</code></pre><p>linux ssh互信</p><pre><code>ssh-keygen -t rsacd ~/.ssh scp -r id_rsa.pub keyuan@192.168.3.51:/home/keyuan/.ssh/authorized_keys</code></pre><p>配置java环境变量</p><pre><code>export JAVA_HOME=/usr/local/java/jdk1.8.0_40export JRE_HOME=$JAVA_HOMEexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$PATH</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;记录一下自己常用的linux命令&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;独立用户需要配置path,切换到根目录查看path&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vi .bash_profile&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重新给文件夹赋权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chown 
      
    
    </summary>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="linux" scheme="http://liuxing.info/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>GitHub博客搭建</title>
    <link href="http://liuxing.info/2015/06/14/GitHub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA"/>
    <id>http://liuxing.info/2015/06/14/GitHub博客搭建</id>
    <published>2015-06-13T18:52:00.000Z</published>
    <updated>2019-07-03T01:02:10.615Z</updated>
    
    <content type="html"><![CDATA[<p><em>GitHub带你装逼带你飞！你值得拥有！</em></p><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>*<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。*<br><em>GitHub作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如<a href="https://github.com/jquery/jquery" target="_blank" rel="noopener">jQuery</a>、<a href="https://github.com/twitter/bootstrap" target="_blank" rel="noopener">Twitter</a>等。</em><br><em>为使项目更方便的被人理解，介绍页面少不了，甚至会需要完整的文档站，GitHub替你想到了这一点，他提供了<a href="http://pages.github.com" target="_blank" rel="noopener">GitHub Pages</a>的服务，不仅可以方便的为项目建立介绍站点，也可以用来建立个人博客。</em></p><p>GitHub Pages有以下几个优点</p><ul><li><em>轻量级的博客系统，没有麻烦的配置</em></li><li><em>使用标记语言，比如 <a href="http://markdown.tw" target="_blank" rel="noopener">Markdown</a></em></li><li><em>无需自己搭建服务器</em></li><li><em>根据GitHub的限制，对应的每个站有300MB空间</em></li><li><em>可以绑定自己的域名</em></li></ul><p>当然他也有缺点</p><ul><li><em>使用<a href="https://github.com/jekyll/jekyll" target="_blank" rel="noopener">Jekyll</a>模板系统，相当于静态页发布，适合博客，文档介绍等。</em></li><li><em>动态程序的部分相当局限，比如没有评论，不过还好我们有解决方案。</em></li><li><em>基于Git，很多东西需要动手，不像Wordpress有强大的后台。</em></li></ul><p>大致介绍到此，作为个人博客来说，简洁清爽的表达自己的工作、心得，就已达目标，所以Github Pages是我认为此需求最完美的解决方案了。</p><h2 id="GitHub配置"><a href="#GitHub配置" class="headerlink" title="GitHub配置"></a>GitHub配置</h2><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>传送口：<a href="https://github.com/join" target="_blank" rel="noopener">https://github.com/join</a> ，自行搞定，否则放弃吧…</p><p><strong>PS</strong>：<em><code>不要取奇怪的用户名，比如大小写混合，建议小写字母+数字组合，否则pages会碰到问题！</code></em></p><h3 id="配置Pages"><a href="#配置Pages" class="headerlink" title="配置Pages"></a>配置Pages</h3><p><strong>新增仓库</strong>：<a href="https://github.com/new" target="_blank" rel="noopener">https://github.com/new</a></p><ul><li>Repository name：github账号.github.io</li><li>Description：随便输入点描述</li><li>public</li><li>Initialize this repository with a README</li><li>.gitignore 选择初始的文件忽略，我选的java</li><li>Licenses：我选的NPL（GNU General Public License v2.0）</li></ul><p><strong>配置</strong></p><ul><li>选择右侧操作区的<code>settings</code></li><li>选择<code>Launch automatic page generator</code></li><li>输入一些基本说明，非必要</li><li>选择<code>Load README.md</code></li><li>继续<code>Continue to layouts</code></li><li>选择模板（随便选个）</li><li>发布<code>Publish page</code></li><li>此时进入<code>settings</code>应该会有<code>Your site is published at http://username.github.io</code>的条提示，访问一下，神奇吧！</li><li>如果404，请检查你的仓库名或账号名，删除仓库重来，删除也是在<code>settings</code>最底部</li></ul><h2 id="绑定独立域名"><a href="#绑定独立域名" class="headerlink" title="绑定独立域名"></a>绑定独立域名</h2><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>不绑定独立域名则可以直接跳到 <strong>使用hexo</strong></p><p>传送门：<a href="https://www.godaddy.com" target="_blank" rel="noopener">https://www.godaddy.com</a> 支持支付宝<br>域名的购买不用多讲，注册、选域名、支付，有网购经验的都毫无压力。<br>记得先找优惠券：<a href="http://www.dute.me" target="_blank" rel="noopener">http://www.dute.me</a></p><p>推荐几个翻译插件</p><a href="https://chrome.google.com/webstore/detail/%E5%A4%9A%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg" target="_blank" rel="noopener">多词典划译</a><a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb" target="_blank" rel="noopener">Google翻译</a><p>没有VPN？<br>注册红杏：<a href="http://honx.in/_U9m44oIaA3c2nFTX" target="_blank" rel="noopener">http://honx.in/_U9m44oIaA3c2nFTX</a><br>公益红杏：<a href="http://help.honx.in/posts/view/32854" target="_blank" rel="noopener">http://help.honx.in/posts/view/32854</a> </p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>传送门：<a href="https://www.dnspod.cn/" target="_blank" rel="noopener">https://www.dnspod.cn/</a></p><ul><li>首先添加域名记录，可参考DNSPod的帮助文档：<a href="https://www.dnspod.cn/Support" target="_blank" rel="noopener">https://www.dnspod.cn/Support</a><br>  添加域名记录后，进入会有个加载配置啥的，不要保存，使用默认的两个解析就行</li><li>在DNSPod自己的域名下添加一条<a href="http://baike.baidu.com/view/65575.htm" target="_blank" rel="noopener">A记录</a>，地址就是Github Pages的服务IP地址：103.245.222.133（最好自行ping获取最新的ip）</li><li>在域名注册商处修改DNS服务:去Godaddy修改Nameservers为这两个地址：f1g1ns1.dnspod.net、f1g1ns2.dnspod.net。如果你不明白在哪里修改，可以参考这里：<a href="https://www.dnspod.cn/support/index/fid/119" target="_blank" rel="noopener">Godaddy注册的域名如何使用DNSPod</a></li><li>等待域名解析生效</li></ul><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>在刚创建的GitHub仓库根目录下添加<code>CNAME</code>文件，写入你申请的域名，等待生效。</p><h2 id="使用hexo"><a href="#使用hexo" class="headerlink" title="使用hexo"></a>使用hexo</h2><p>基于github pages的不足，我们使用hexo博客框架</p><p>因为hexo的文档写的太好了，就没我啥事了！</p><p>传送门：<a href="http://hexo.io/zh-cn/" target="_blank" rel="noopener">http://hexo.io/zh-cn/</a></p><p>有任何问题，欢迎评论交流！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;GitHub带你装逼带你飞！你值得拥有！&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;*&lt;a href=&quot;https://github.com
      
    
    </summary>
    
      <category term="系统配置" scheme="http://liuxing.info/categories/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="GitHub Pages" scheme="http://liuxing.info/tags/GitHub-Pages/"/>
    
      <category term="Blog" scheme="http://liuxing.info/tags/Blog/"/>
    
      <category term="Godaddy" scheme="http://liuxing.info/tags/Godaddy/"/>
    
      <category term="DNSPod" scheme="http://liuxing.info/tags/DNSPod/"/>
    
      <category term="Hexo" scheme="http://liuxing.info/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>RestTemplate实践</title>
    <link href="http://liuxing.info/2015/05/21/RestTemplate%E5%AE%9E%E8%B7%B5"/>
    <id>http://liuxing.info/2015/05/21/RestTemplate实践</id>
    <published>2015-05-21T02:56:27.000Z</published>
    <updated>2019-07-02T01:06:43.324Z</updated>
    
    <content type="html"><![CDATA[<p><em>什么是RestTemplate？</em></p><blockquote><p>RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率。<br>调用RestTemplate的默认构造函数，RestTemplate对象在底层通过使用java.net包下的实现创建HTTP 请求，可以通过使用ClientHttpRequestFactory指定不同的HTTP请求方式。<br>ClientHttpRequestFactory接口主要提供了两种实现方式</p><ul><li>一种是SimpleClientHttpRequestFactory，使用J2SE提供的方式（既java.net包提供的方式）创建底层的Http请求连接。</li><li>一种方式是使用HttpComponentsClientHttpRequestFactory方式，底层使用HttpClient访问远程的Http服务，使用HttpClient可以配置连接池和证书等信息。</li></ul></blockquote><hr><p><a href="#完整的实例代码">最新实例代码</a> 更新于<code>2015-07-30</code></p><h2 id="xml配置的方式"><a href="#xml配置的方式" class="headerlink" title="xml配置的方式"></a>xml配置的方式</h2><p>请查看RestTemplate源码了解细节，知其然知其所以然！</p><p>RestTemplate默认是使用SimpleClientHttpRequestFactory，内部是调用jdk的HttpConnection，默认超时为-1</p><p>@Autowired<br>RestTemplate simpleRestTemplate<br>@Autowired<br>RestTemplate restTemplate</p><h3 id="基于jdk的spring的RestTemplate"><a href="#基于jdk的spring的RestTemplate" class="headerlink" title="基于jdk的spring的RestTemplate"></a>基于jdk的spring的RestTemplate</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">"byName"</span> <span class="attr">default-lazy-init</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--方式一、使用jdk的实现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ky.requestFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.client.SimpleClientHttpRequestFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"readTimeout"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectTimeout"</span> <span class="attr">value</span>=<span class="string">"5000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleRestTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.client.RestTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"ky.requestFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverters"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.FormHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/plain;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用Httpclient连接池的方式"><a href="#使用Httpclient连接池的方式" class="headerlink" title="使用Httpclient连接池的方式"></a>使用Httpclient连接池的方式</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">"byName"</span> <span class="attr">default-lazy-init</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--方式二、使用httpclient的实现，带连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ky.pollingConnectionManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.http.impl.conn.PoolingHttpClientConnectionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--整个连接池的并发--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"1000"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--每个主机的并发--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultMaxPerRoute"</span> <span class="attr">value</span>=<span class="string">"1000"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ky.httpClientBuilder"</span> <span class="attr">class</span>=<span class="string">"org.apache.http.impl.client.HttpClientBuilder"</span> <span class="attr">factory-method</span>=<span class="string">"create"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionManager"</span> <span class="attr">ref</span>=<span class="string">"ky.pollingConnectionManager"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启重试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"retryHandler"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.http.impl.client.DefaultHttpRequestRetryHandler"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultHeaders"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.http.message.BasicHeader"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"User-Agent"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.16 Safari/537.36"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.http.message.BasicHeader"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"Accept-Encoding"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"gzip,deflate"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.http.message.BasicHeader"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"Accept-Language"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"zh-CN"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ky.httpClient"</span> <span class="attr">factory-bean</span>=<span class="string">"ky.httpClientBuilder"</span> <span class="attr">factory-method</span>=<span class="string">"build"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ky.clientHttpRequestFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.client.HttpComponentsClientHttpRequestFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"ky.httpClient"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接超时时间，毫秒--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectTimeout"</span> <span class="attr">value</span>=<span class="string">"5000"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--读写超时时间，毫秒--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"readTimeout"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"restTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.client.RestTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"ky.clientHttpRequestFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"errorHandler"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.client.DefaultResponseErrorHandler"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverters"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.FormHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/plain;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="bean初始化-静态工具"><a href="#bean初始化-静态工具" class="headerlink" title="bean初始化+静态工具"></a>bean初始化+静态工具</h2><p><strong>线程安全的单例（懒汉模式）</strong></p><h3 id="基于jdk的spring的RestTemplate-1"><a href="#基于jdk的spring的RestTemplate-1" class="headerlink" title="基于jdk的spring的RestTemplate"></a>基于jdk的spring的RestTemplate</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.client.SimpleClientHttpRequestFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.FormHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.StringHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.DefaultResponseErrorHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>：基于jdk的spring的RestTemplate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：liuxing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>：2015-05-18 09:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SimpleRestClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SimpleClientHttpRequestFactory requestFactory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setReadTimeout(<span class="number">5000</span>);</span><br><span class="line">        requestFactory.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加转换器</span></span><br><span class="line">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> StringHttpMessageConverter(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> FormHttpMessageConverter());</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> MappingJackson2XmlHttpMessageConverter());</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter());</span><br><span class="line"></span><br><span class="line">        restTemplate = <span class="keyword">new</span> RestTemplate(messageConverters);</span><br><span class="line">        restTemplate.setRequestFactory(requestFactory);</span><br><span class="line">        restTemplate.setErrorHandler(<span class="keyword">new</span> DefaultResponseErrorHandler());</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">"SimpleRestClient初始化完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SimpleRestClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestTemplate <span class="title">getClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Httpclient连接池的方式-1"><a href="#使用Httpclient连接池的方式-1" class="headerlink" title="使用Httpclient连接池的方式"></a>使用Httpclient连接池的方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.Header;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.HttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.DefaultConnectionKeepAliveStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.DefaultHttpRequestRetryHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.conn.PoolingHttpClientConnectionManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message.BasicHeader;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.client.HttpComponentsClientHttpRequestFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.FormHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.StringHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.DefaultResponseErrorHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>：使用spring的restTemplate替代httpclient工具</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：liuxing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>：2015-05-18 08:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SimpleRestClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 长连接保持30秒</span></span><br><span class="line">        PoolingHttpClientConnectionManager pollingConnectionManager = <span class="keyword">new</span> PoolingHttpClientConnectionManager(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 总连接数</span></span><br><span class="line">        pollingConnectionManager.setMaxTotal(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 同路由的并发数</span></span><br><span class="line">        pollingConnectionManager.setDefaultMaxPerRoute(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        HttpClientBuilder httpClientBuilder = HttpClients.custom();</span><br><span class="line">        httpClientBuilder.setConnectionManager(pollingConnectionManager);</span><br><span class="line">        <span class="comment">// 重试次数，默认是3次，没有开启</span></span><br><span class="line">        httpClientBuilder.setRetryHandler(<span class="keyword">new</span> DefaultHttpRequestRetryHandler(<span class="number">2</span>, <span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">// 保持长连接配置，需要在头添加Keep-Alive</span></span><br><span class="line">        httpClientBuilder.setKeepAliveStrategy(DefaultConnectionKeepAliveStrategy.INSTANCE);</span><br><span class="line"></span><br><span class="line">        List&lt;Header&gt; headers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        headers.add(<span class="keyword">new</span> BasicHeader(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.16 Safari/537.36"</span>));</span><br><span class="line">        headers.add(<span class="keyword">new</span> BasicHeader(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip,deflate"</span>));</span><br><span class="line">        headers.add(<span class="keyword">new</span> BasicHeader(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN,zh;q=0.8,en;q=0.6"</span>));</span><br><span class="line">        headers.add(<span class="keyword">new</span> BasicHeader(<span class="string">"Connection"</span>, <span class="string">"keep-alive"</span>));</span><br><span class="line"></span><br><span class="line">        httpClientBuilder.setDefaultHeaders(headers);</span><br><span class="line"></span><br><span class="line">        HttpClient httpClient = httpClientBuilder.build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// httpClient连接配置，底层是配置RequestConfig</span></span><br><span class="line">        HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient);</span><br><span class="line">        <span class="comment">// 连接超时</span></span><br><span class="line">        clientHttpRequestFactory.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// 数据读取超时时间，即SocketTimeout</span></span><br><span class="line">        clientHttpRequestFactory.setReadTimeout(<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// 连接不够用的等待时间，不宜过长，必须设置，比如连接不够用时，时间过长将是灾难性的</span></span><br><span class="line">        clientHttpRequestFactory.setConnectionRequestTimeout(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 缓冲请求数据，默认值是true。通过POST或者PUT大量发送数据时，建议将此属性更改为false，以免耗尽内存。</span></span><br><span class="line">        <span class="comment">// clientHttpRequestFactory.setBufferRequestBody(false);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加内容转换器</span></span><br><span class="line">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> StringHttpMessageConverter(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> FormHttpMessageConverter());</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> MappingJackson2XmlHttpMessageConverter());</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter());</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> ByteArrayHttpMessageConverter());</span><br><span class="line"></span><br><span class="line">        restTemplate = <span class="keyword">new</span> RestTemplate(messageConverters);</span><br><span class="line">        restTemplate.setRequestFactory(clientHttpRequestFactory);</span><br><span class="line">        restTemplate.setErrorHandler(<span class="keyword">new</span> DefaultResponseErrorHandler());</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">"RestClient初始化完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RestClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestTemplate <span class="title">getClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>api里面可以做自动的参数匹配：<br>如：<a href="http://you" target="_blank" rel="noopener">http://you</a> domainn name/test?empNo={empNo}，则下面方法的最后一个参数为数据匹配参数，会自动根据key进行查找，然后替换</p><p>API没有声明异常，注意进行异常处理</p><p>更多使用语法请查看API文档</p><h3 id="完整的实例代码"><a href="#完整的实例代码" class="headerlink" title="完整的实例代码"></a>完整的实例代码</h3><p>定义一个异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.NestedRuntimeException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.HttpClientErrorException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.HttpServerErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包装一个RestClient请求时抛出的异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：liuxing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> ：2015-07-15 21:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClientException</span> <span class="keyword">extends</span> <span class="title">NestedRuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HttpStatus statusCode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态码文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String statusText;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常时返回的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String responseBody;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回的头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HttpHeaders responseHeaders;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RestClientException</span><span class="params">(Exception exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(exception.getMessage(), exception);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> HttpServerErrorException) &#123;</span><br><span class="line">            HttpServerErrorException e = (HttpServerErrorException) exception;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.statusCode = e.getStatusCode();</span><br><span class="line">            <span class="keyword">this</span>.statusText = e.getStatusText();</span><br><span class="line">            <span class="keyword">this</span>.responseBody = e.getResponseBodyAsString();</span><br><span class="line">            <span class="keyword">this</span>.responseHeaders = e.getResponseHeaders();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> HttpClientErrorException) &#123;</span><br><span class="line">            HttpClientErrorException e = (HttpClientErrorException) exception;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.statusCode = e.getStatusCode();</span><br><span class="line">            <span class="keyword">this</span>.statusText = e.getStatusText();</span><br><span class="line">            <span class="keyword">this</span>.responseBody = e.getResponseBodyAsString();</span><br><span class="line">            <span class="keyword">this</span>.responseHeaders = e.getResponseHeaders();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.statusText = exception.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> statusCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatusCode</span><span class="params">(HttpStatus statusCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.statusCode = statusCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> statusText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatusText</span><span class="params">(String statusText)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.statusText = statusText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResponseBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResponseBody</span><span class="params">(String responseBody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseBody = responseBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getResponseHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseHeaders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResponseHeaders</span><span class="params">(HttpHeaders responseHeaders)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseHeaders = responseHeaders;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工具集</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.dooioo.se.commons.Lang;</span><br><span class="line"><span class="keyword">import</span> com.dooioo.se.utils.RestClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.MapUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.ParameterizedTypeReference;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.LinkedMultiValueMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.MultiValueMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * httpclient工具类,基于httpclient 4.x</span></span><br><span class="line"><span class="comment"> * 不需要设置header的情况：</span></span><br><span class="line"><span class="comment"> * 1.普通的非校验型请求</span></span><br><span class="line"><span class="comment"> * 2.普通的表单请求</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * 需要设置header的情况：</span></span><br><span class="line"><span class="comment"> * 1.头部带token校验的请求</span></span><br><span class="line"><span class="comment"> * 2.提交json数据的请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 刘兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2014-3-7 下午7:48:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url          请求地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method       请求方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回的数据类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange(url, method, <span class="keyword">null</span>, <span class="keyword">null</span>, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url          请求地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method       请求方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers      设置的头信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回的数据类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, HttpHeaders headers, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange(url, method, headers, <span class="keyword">null</span>, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url          请求地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method       请求方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body         要提交的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回数据类型</span></span><br><span class="line"><span class="comment">     *                     返回bean时指定Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, Object body, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange(url, method, <span class="keyword">null</span>, body, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url          请求地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method       请求方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpHeaders  请求头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body         要提交的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回数据类型</span></span><br><span class="line"><span class="comment">     *                     返回bean时指定Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, HttpHeaders httpHeaders, Object body, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpEntity&lt;?&gt; requestEntity = <span class="keyword">new</span> HttpEntity(body, httpHeaders);</span><br><span class="line">            requestEntity = convert(requestEntity);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uriVariables.length == <span class="number">1</span> &amp;&amp; uriVariables[<span class="number">0</span>] <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">                Map&lt;String, ?&gt; _uriVariables = (Map&lt;String, ?&gt;) uriVariables[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span> getClient().exchange(url, method, requestEntity, responseType, _uriVariables).getBody();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> getClient().exchange(url, method, requestEntity, responseType, uriVariables).getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RestClientException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url          请求地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method       请求方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回的数据类型，例：new ParameterizedTypeReference&lt;List&lt;Bean&gt;&gt;()&#123;&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, ParameterizedTypeReference&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange(url, method, <span class="keyword">null</span>, <span class="keyword">null</span>, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url          请求地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method       请求方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers      设置的头信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回的数据类型，例：new ParameterizedTypeReference&lt;List&lt;Bean&gt;&gt;()&#123;&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, HttpHeaders headers, ParameterizedTypeReference&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange(url, method, headers, <span class="keyword">null</span>, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url          请求地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method       请求方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body         要提交的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回数据类型，例：new ParameterizedTypeReference&lt;List&lt;Bean&gt;&gt;()&#123;&#125;</span></span><br><span class="line"><span class="comment">     *                     返回bean时指定Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, Object body, ParameterizedTypeReference&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange(url, method, <span class="keyword">null</span>, body, responseType, uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url          请求地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method       请求方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpHeaders  请求头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body         要提交的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseType 返回数据类型，例：new ParameterizedTypeReference&lt;List&lt;Bean&gt;&gt;()&#123;&#125;</span></span><br><span class="line"><span class="comment">     *                     返回bean时指定Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriVariables url自动匹配替换的参数，如url为api/&#123;a&#125;/&#123;b&#125;,参数为["1","2"],则解析的url为api/1/2，使用Map参数时，遵循按key匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RestClientException RestClient异常，包含状态码和非200的返回内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exchange</span><span class="params">(String url, HttpMethod method, HttpHeaders httpHeaders, Object body, ParameterizedTypeReference&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpEntity&lt;?&gt; requestEntity = <span class="keyword">new</span> HttpEntity(body, httpHeaders);</span><br><span class="line">            requestEntity = convert(requestEntity);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uriVariables.length == <span class="number">1</span> &amp;&amp; uriVariables[<span class="number">0</span>] <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">                Map&lt;String, ?&gt; _uriVariables = (Map&lt;String, ?&gt;) uriVariables[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span> getClient().exchange(url, method, requestEntity, responseType, _uriVariables).getBody();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> getClient().exchange(url, method, requestEntity, responseType, uriVariables).getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RestClientException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得一个RestTemplate客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestTemplate <span class="title">getClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RestClientBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个application/x-www-form-urlencoded头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpHeaders <span class="title">buildBasicFORMHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个application/json头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpHeaders <span class="title">buildBasicJSONHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个text/html头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpHeaders <span class="title">buildBasicHTMLHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        headers.setContentType(MediaType.TEXT_HTML);</span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个json头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrays</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpHeaders <span class="title">buildJSONHeaders</span><span class="params">(Object... arrays)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arrays.length % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"arrays 长度 必须为偶数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpHeaders headers = buildBasicJSONHeaders();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; i++) &#123;</span><br><span class="line">            headers.add(Lang.defaultEmptyStr(arrays[i]), Lang.defaultEmptyStr(arrays[++i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对bean对象转表单模型做处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestEntity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HttpEntity&lt;?&gt; convert(HttpEntity&lt;?&gt; requestEntity) &#123;</span><br><span class="line">        Object body = requestEntity.getBody();</span><br><span class="line">        HttpHeaders headers = requestEntity.getHeaders();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (body == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> requestEntity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">            MultiValueMap&lt;String, String&gt; multiValueMap = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            Map&lt;String, ?&gt; _body = (Map&lt;String, ?&gt;) body;</span><br><span class="line">            <span class="keyword">for</span> (String key : _body.keySet()) &#123;</span><br><span class="line">                multiValueMap.add(key, MapUtils.getString(_body, key));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            requestEntity = <span class="keyword">new</span> HttpEntity&lt;&gt;(multiValueMap, headers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (headers == <span class="keyword">null</span> || !MediaType.APPLICATION_FORM_URLENCODED.equals(headers.getContentType())) &#123;</span><br><span class="line">            <span class="keyword">return</span> requestEntity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> requestEntity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">            <span class="keyword">return</span> requestEntity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">            <span class="keyword">return</span> requestEntity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MultiValueMap&lt;String, Object&gt; formEntity = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Field[] fields = body.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            String name = fields[i].getName();</span><br><span class="line">            String value = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value = BeanUtils.getProperty(body, name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            formEntity.add(name, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpEntity&lt;&gt;(formEntity, headers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Object[] EMPTY_URI_VARIABLES = <span class="keyword">new</span> Object[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> HttpHeaders EMPTY_HEADERS = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, ?&gt; EMPTY_BODY = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> HttpEntity EMPTY_ENTITY = <span class="keyword">new</span> HttpEntity(EMPTY_HEADERS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><strong>RestTemplate API说明和使用参考</strong></p><p><a href="http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="noopener">http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/web/client/RestTemplate.html</a></p><p><a href="http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/http/client/SimpleClientHttpRequestFactory.html" target="_blank" rel="noopener">http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/http/client/SimpleClientHttpRequestFactory.html</a></p><p><a href="http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/http/client/HttpComponentsClientHttpRequestFactory.html" target="_blank" rel="noopener">http://docs.spring.io/spring/docs/4.1.x/javadoc-api/org/springframework/http/client/HttpComponentsClientHttpRequestFactory.html</a></p><p><strong>HttpClient官方示例和参数配置说明</strong></p><p><a href="http://hc.apache.org/httpcomponents-client-4.4.x/examples.html" target="_blank" rel="noopener">http://hc.apache.org/httpcomponents-client-4.4.x/examples.html</a></p><p><a href="http://hc.apache.org/httpcomponents-client-4.4.x/tutorial/html/index.html" target="_blank" rel="noopener">http://hc.apache.org/httpcomponents-client-4.4.x/tutorial/html/index.html</a></p><p><strong>依赖</strong><br><em>spring 3.x以上</em></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.jackson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-mapper-asl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意点</strong></p><p>1.关于httpclient配置的<code>defaultMaxPerRoute</code>和<code>maxTotal</code><br><code>defaultMaxPerRoute</code>：最大路由并发数，以主机为单位<br><code>maxTotal</code>：整个连接池的并发数</p><p>例如：<br><code>defaultMaxPerRoute</code>为10，<code>maxTotal</code>为100<br>假设只会访问<a href="http://www.baidu.com和http://www.google.com" target="_blank" rel="noopener">http://www.baidu.com和http://www.google.com</a><br>那么能同时并发到客源的只能是10，房源也是10，整个连接永远不会到100</p><p>2.部分方法注意查看源码，默认构造里面会新增常用的数据转换器，spring对jackson比较情有独钟，在解析xml和json时，优先使用jackson</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance of the &#123;<span class="doctag">@link</span> RestTemplate&#125; using default settings.</span></span><br><span class="line"><span class="comment"> * Default &#123;<span class="doctag">@link</span> HttpMessageConverter&#125;s are initialized.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> ByteArrayHttpMessageConverter());</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> StringHttpMessageConverter());</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> ResourceHttpMessageConverter());</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> SourceHttpMessageConverter&lt;Source&gt;());</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> AllEncompassingFormHttpMessageConverter());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (romePresent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> AtomFeedHttpMessageConverter());</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> RssChannelHttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (jackson2XmlPresent) &#123;</span><br><span class="line">            messageConverters.add(<span class="keyword">new</span> MappingJackson2XmlHttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jaxb2Present) &#123;</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> Jaxb2RootElementHttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (jackson2Present) &#123;</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (gsonPresent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> GsonHttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance of the &#123;<span class="doctag">@link</span> RestTemplate&#125; based on the given &#123;<span class="doctag">@link</span> ClientHttpRequestFactory&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requestFactory HTTP request factory to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.http.client.SimpleClientHttpRequestFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.http.client.HttpComponentsClientHttpRequestFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RestTemplate</span><span class="params">(ClientHttpRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    setRequestFactory(requestFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看添加转换器的方法外部添加转换器时，this.messageConverters.clear();会先清除已有的，需要注意</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance of the &#123;<span class="doctag">@link</span> RestTemplate&#125; using the given list of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> HttpMessageConverter&#125; to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> messageConverters the list of &#123;<span class="doctag">@link</span> HttpMessageConverter&#125; to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.2.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RestTemplate</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(messageConverters, <span class="string">"'messageConverters' must not be empty"</span>);</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.addAll(messageConverters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the message body converters to use.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;These converters are used to convert from and to HTTP requests and responses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(messageConverters, <span class="string">"'messageConverters' must not be empty"</span>);</span><br><span class="line">    <span class="comment">// Take getMessageConverters() List as-is when passed in here</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.messageConverters != messageConverters) &#123;</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.clear();</span><br><span class="line">            <span class="keyword">this</span>.messageConverters.addAll(messageConverters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;什么是RestTemplate？&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率。&lt;br&gt;调用
      
    
    </summary>
    
      <category term="Java" scheme="http://liuxing.info/categories/Java/"/>
    
    
      <category term="RestTemplate" scheme="http://liuxing.info/tags/RestTemplate/"/>
    
      <category term="httpClient" scheme="http://liuxing.info/tags/httpClient/"/>
    
      <category term="Spring" scheme="http://liuxing.info/tags/Spring/"/>
    
  </entry>
  
</feed>
